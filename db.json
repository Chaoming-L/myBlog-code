{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/tag-bg.jpg","path":"img/tag-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/home-bg-o.jpg","path":"img/home-bg-o.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.css","path":"css/hux-blog.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"themes/huxblog/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1485141474000},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1485141474000},{"_id":"source/CNAME","hash":"380684ab67adbffcd99a9d75ce51da32425c84b6","modified":1490603195249},{"_id":"themes/huxblog/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1485141474000},{"_id":"themes/huxblog/_config.yml","hash":"5d235aa7716657282795ee86d9c9db2374197a66","modified":1485141474000},{"_id":"source/_posts/JS实现快速排序.md","hash":"d916c825649f54a315ff15ae4aa581d320dca85e","modified":1497853843683},{"_id":"source/_posts/JS深复制与浅复制.md","hash":"1f016557721d6599cc7e15d42cad291d001b3162","modified":1499223199322},{"_id":"source/_posts/about-javascript.md","hash":"e010bf9a68eb83c58baf021125fa2e736ff76364","modified":1490599188410},{"_id":"source/_posts/hello-blog.md","hash":"279d03c3bf765aac1de8b252706c20bd65864ad2","modified":1489818239277},{"_id":"source/_posts/javascript-module-loader.md","hash":"c9a3e4a978a2e0ad1a75f852864e645d356600c3","modified":1490599224735},{"_id":"source/_posts/实现链式LazyMan.md","hash":"abee3299c1561184b311a2e21e958456cb81479b","modified":1497591436099},{"_id":"source/_posts/徒手解析URL参数.md","hash":"3e0dd9cb71e585b82d7b86fb582eec2c25acb3f9","modified":1498112544042},{"_id":"source/about/index.md","hash":"810fd4abd0dadfe3e812258fd06f9ba6f34a5600","modified":1490599138472},{"_id":"source/archives/index.md","hash":"754d367e509ce8e550abab63b450302a78cce7ef","modified":1489742466426},{"_id":"source/tags/index.md","hash":"0bc541f4c6a0f21bec67b6717ee86226f0eddf39","modified":1485141474000},{"_id":"source/img/avatar.jpg","hash":"49cfa597392c4a116584c07690efbbc06354acc7","modified":1485141474000},{"_id":"source/img/favicon.ico","hash":"a8ee7712f6560180efccb68546de6ea0d937fff3","modified":1485141474000},{"_id":"source/img/icon_wechat.png","hash":"7fdb00c9017236e05c1b3e6da38a2cc382fd69fa","modified":1485141474000},{"_id":"themes/huxblog/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1485141474000},{"_id":"themes/huxblog/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1485141474000},{"_id":"themes/huxblog/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1485141474000},{"_id":"themes/huxblog/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1485141474000},{"_id":"themes/huxblog/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1485141474000},{"_id":"themes/huxblog/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1485141474000},{"_id":"themes/huxblog/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1485141474000},{"_id":"themes/huxblog/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1485141474000},{"_id":"themes/huxblog/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1485141474000},{"_id":"themes/huxblog/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1485141474000},{"_id":"themes/huxblog/layout/about.ejs","hash":"7f56c71383ef6c156b56d79b3984e07cc466606a","modified":1485141474000},{"_id":"themes/huxblog/layout/archive.ejs","hash":"6c3ed5d914379319efe835a4aa505abbc616c328","modified":1485141474000},{"_id":"themes/huxblog/layout/archives.ejs","hash":"f0046e58cc1dd876133be2bf927aed2b1821cb3e","modified":1485141474000},{"_id":"themes/huxblog/layout/index.ejs","hash":"70ac58c46625300a70791e210daf446afa6d1cd4","modified":1485141474000},{"_id":"themes/huxblog/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1485141474000},{"_id":"themes/huxblog/layout/layout.ejs","hash":"03e278a3b8bc4503183276b6130ac04a8d5b9865","modified":1485141474000},{"_id":"themes/huxblog/layout/page.ejs","hash":"3fde0787e883274563f9de5aaeb8130b667e132a","modified":1485141474000},{"_id":"themes/huxblog/layout/post.ejs","hash":"fd68124c3de2bbe7d870cecadcf684df7cf82519","modified":1485141474000},{"_id":"themes/huxblog/layout/tags.ejs","hash":"a51bf2828af20939d702de1fdae067439a1153c0","modified":1485141474000},{"_id":"source/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1485141474000},{"_id":"source/_posts/JS实现快速排序/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1497591436121},{"_id":"source/_posts/about-javascript/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1490599188402},{"_id":"source/_posts/about-javascript/keep-calm-and-learn-javascript.png","hash":"49ea101b92ce5e136a19e6b11162f8f4126fe01f","modified":1490599188403},{"_id":"source/_posts/实现链式LazyMan/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1497591436121},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1485141474000},{"_id":"source/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1485141474000},{"_id":"themes/huxblog/layout/_partial/footer.ejs","hash":"e325a9953abc1a3751aa1a927bc3ecbdd627803a","modified":1485141474000},{"_id":"themes/huxblog/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1485141474000},{"_id":"themes/huxblog/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1485141474000},{"_id":"themes/huxblog/layout/_partial/head.ejs","hash":"87c544a64ea49b835330135a616deb2e9fd39bbb","modified":1485141474000},{"_id":"themes/huxblog/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1485141474000},{"_id":"themes/huxblog/source/css/hux-blog.css","hash":"c1b0a32ad8075ac09d99fb4d64a9fbc84163abf8","modified":1485141474000},{"_id":"themes/huxblog/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1485141474000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1485141474000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1485141474000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1485141474000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1485141474000},{"_id":"themes/huxblog/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1485141474000},{"_id":"themes/huxblog/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1485141474000},{"_id":"themes/huxblog/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1485141474000},{"_id":"themes/huxblog/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1485141474000},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1485141474000},{"_id":"source/_posts/hello-blog/post-bg-unix-linux.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1485141474000},{"_id":"source/_posts/about-javascript/javascript-java.jpg","hash":"881e35e241a8be40f3c4e3a6f57d5402247c1eb3","modified":1490599188408},{"_id":"source/_posts/javascript-module-loader/post-bg-js-module.jpg","hash":"4a43bfa6b69c79a6ef90bd852fe5756d241733cd","modified":1490599188388},{"_id":"source/img/home-bg.jpg","hash":"a191201c3a98728e6ea66d6827df827ecfcc9d33","modified":1485141474000},{"_id":"themes/huxblog/source/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1485141474000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1485141474000},{"_id":"themes/huxblog/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1485141474000},{"_id":"themes/huxblog/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1485141474000},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1485141474000},{"_id":"themes/huxblog/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1485141474000},{"_id":"themes/huxblog/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1485141474000},{"_id":"source/img/about-bg.jpg","hash":"b5814b2d10eb38dfda0072365567f3823bc34aba","modified":1485141474000}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2017-03-17T08:49:46.559Z","updated":"2017-01-23T03:17:54.000Z","path":"404.html","title":"","comments":1,"_id":"cj4qesf7t0000c4v5u79sqrsc","content":"","excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Hey, this is me.","header-img":"img/about-bg.jpg","comments":1,"_content":"\n\n>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。--Breaking Bad.\n>写写代码，过好生活，思考人生.\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Hey, this is me.\"\nheader-img: \"img/about-bg.jpg\"\ncomments: true\n---\n\n\n>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。--Breaking Bad.\n>写写代码，过好生活，思考人生.\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","updated":"2017-03-27T07:18:58.472Z","path":"about/index.html","_id":"cj4qesf94000uc4v5bwckia4q","content":"<blockquote>\n<p>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。–Breaking Bad.<br>写写代码，过好生活，思考人生.</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\" target=\"_blank\" rel=\"external\">李书航 － 什么是「共产中文腔调」？ </a><br></p>","excerpt":"","more":"<blockquote>\n<p>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。–Breaking Bad.<br>写写代码，过好生活，思考人生.</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a><br></p>"},{"layout":"archives","title":"Archives","description":"Yo~ Man. go go go!","header-img":"img/tag-bg.jpg","_content":"","source":"archives/index.md","raw":"---\nlayout: \"archives\"\ntitle: \"Archives\"\ndescription: \"Yo~ Man. go go go!\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2017-03-17T09:21:06.426Z","updated":"2017-03-17T09:21:06.426Z","path":"archives/index.html","comments":1,"_id":"cj4qesf94000vc4v5lj15xcyn","content":"","excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/tag-bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2017-03-17T08:49:46.675Z","updated":"2017-01-23T03:17:54.000Z","path":"tags/index.html","comments":1,"_id":"cj4qesf94000wc4v5tt5zdixs","content":"","excerpt":"","more":""}],"Post":[{"title":"JS排序算法","subtitle":"数组 排序","author":"Damon","header-img":"post-bg-js-version.jpg","date":"2017-06-16T05:41:37.000Z","_content":"\n## 前言\n\n这篇博文将会写一些自己日常用到的js排序算法.  排序算法一次性写完,个人感觉不太实际,所以会陆续更新比较好.\n\n---\n\n## 代码实现\n\n### 快速排序\n\n```\n/*  输入数组快速排序\n*   @params arr {Array}\n*   @return {Array}\n*/\nfunction quickSort(arr) {\n  while (arr.length <= 1) {\n    return arr\n  }\n\n  let midNumber = Math.floor(arr.length / 2),\n      // 从排序的数组中取出中位元素(splice会修改原来数组)\n      midValue = arr.splice(midNumber,1),\n      left = [],\n      right = []\n\n  for (var i = arr.length - 1; i >= 0; i--) {\n    // 所有元素跟中位元素比较大小, 小于中位数的放在左边数组\n    if (arr[i] < midValue[0]) {\n      left.push(arr[i])\n    } else {\n      right.push(arr[i])\n    }\n  }\n\n  return quickSort(left).concat(midValue,quickSort(right))\n}\n\nvar arr = [2,3,22,11,1]\n\nquickSort(arr)  // [1,2,3,11,22]\n\n```\n\n### Array.prototype.sort()\n\n\nsort() 方法在适当的位置对数组的元素进行排序，并返回数组。默认排序顺序是根据字符串Unicode码点。\nsort(compareFunction) 使用compareFunction进行进阶排序需求。\n\n排序怎么能忘记JS原生的排序方法sort呢?  come on!  二话不说,代码撸起来..\n\n```\nvar fruit = ['cherries', 'apples', 'bananas'];\nfruit.sort();\n// ['apples', 'bananas', 'cherries']\n\nvar scores = [1, 10, 21, 2];\nscores.sort();\n// [1, 10, 2, 21]\n// 注意10在2之前,\n// because '10' comes before '2' in Unicode code point order.\n\nvar things = ['word', 'Word', '1 Word', '2 Words'];\nthings.sort();\n// ['1 Word', '2 Words', 'Word', 'word']\n// 在Unicode中, 数字在大写字母之前,\n// 大写字母在小写字母之前.\n\n```\n\nsort 方法可以使用 函数表达式 方便地书写：\n\n```\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);\n\n// [1, 2, 3, 4, 5]\n\n```\n\n对象可以按照某个属性排序：\n\n```\nvar items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic' },\n  { name: 'Zeros', value: 37 }\n];\n\nitems.sort(function (a, b) {\n  if (a.value > b.value) {\n    return 1;\n  }\n  if (a.value < b.value) {\n    return -1;\n  }\n  // a 必须等于 b\n  return 0;\n});\n\n```\n\ncompareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。\n\n```\n// 需要被排序的数组\nvar list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];\n\n// 对需要排序的元素进行 位置临时存储 和 元素前处理\nvar mapped = list.map((item, i) => (\n { index: i, value: item.toLowerCase() }\n))\n\n// 对处理后的数据进行对个值的排序\nmapped.sort((a, b) => {\n    return +(a.value > b.value) || +(a.value === b.value) - 1\n})\n\n// 根据索引得到排序结果\nlist.map((item) => list[item.index] )\n\n```","source":"_posts/JS实现快速排序.md","raw":"---\ntitle: JS排序算法\nsubtitle: \"数组 排序\"\nauthor: \"Damon\"\nheader-img: \"post-bg-js-version.jpg\"\ndate: 2017-06-16 13:41:37\ntags:\n    - JS\n    - 前端面试\n---\n\n## 前言\n\n这篇博文将会写一些自己日常用到的js排序算法.  排序算法一次性写完,个人感觉不太实际,所以会陆续更新比较好.\n\n---\n\n## 代码实现\n\n### 快速排序\n\n```\n/*  输入数组快速排序\n*   @params arr {Array}\n*   @return {Array}\n*/\nfunction quickSort(arr) {\n  while (arr.length <= 1) {\n    return arr\n  }\n\n  let midNumber = Math.floor(arr.length / 2),\n      // 从排序的数组中取出中位元素(splice会修改原来数组)\n      midValue = arr.splice(midNumber,1),\n      left = [],\n      right = []\n\n  for (var i = arr.length - 1; i >= 0; i--) {\n    // 所有元素跟中位元素比较大小, 小于中位数的放在左边数组\n    if (arr[i] < midValue[0]) {\n      left.push(arr[i])\n    } else {\n      right.push(arr[i])\n    }\n  }\n\n  return quickSort(left).concat(midValue,quickSort(right))\n}\n\nvar arr = [2,3,22,11,1]\n\nquickSort(arr)  // [1,2,3,11,22]\n\n```\n\n### Array.prototype.sort()\n\n\nsort() 方法在适当的位置对数组的元素进行排序，并返回数组。默认排序顺序是根据字符串Unicode码点。\nsort(compareFunction) 使用compareFunction进行进阶排序需求。\n\n排序怎么能忘记JS原生的排序方法sort呢?  come on!  二话不说,代码撸起来..\n\n```\nvar fruit = ['cherries', 'apples', 'bananas'];\nfruit.sort();\n// ['apples', 'bananas', 'cherries']\n\nvar scores = [1, 10, 21, 2];\nscores.sort();\n// [1, 10, 2, 21]\n// 注意10在2之前,\n// because '10' comes before '2' in Unicode code point order.\n\nvar things = ['word', 'Word', '1 Word', '2 Words'];\nthings.sort();\n// ['1 Word', '2 Words', 'Word', 'word']\n// 在Unicode中, 数字在大写字母之前,\n// 大写字母在小写字母之前.\n\n```\n\nsort 方法可以使用 函数表达式 方便地书写：\n\n```\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);\n\n// [1, 2, 3, 4, 5]\n\n```\n\n对象可以按照某个属性排序：\n\n```\nvar items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic' },\n  { name: 'Zeros', value: 37 }\n];\n\nitems.sort(function (a, b) {\n  if (a.value > b.value) {\n    return 1;\n  }\n  if (a.value < b.value) {\n    return -1;\n  }\n  // a 必须等于 b\n  return 0;\n});\n\n```\n\ncompareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。\n\n```\n// 需要被排序的数组\nvar list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];\n\n// 对需要排序的元素进行 位置临时存储 和 元素前处理\nvar mapped = list.map((item, i) => (\n { index: i, value: item.toLowerCase() }\n))\n\n// 对处理后的数据进行对个值的排序\nmapped.sort((a, b) => {\n    return +(a.value > b.value) || +(a.value === b.value) - 1\n})\n\n// 根据索引得到排序结果\nlist.map((item) => list[item.index] )\n\n```","slug":"JS实现快速排序","published":1,"updated":"2017-06-19T06:30:43.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4qesf890001c4v5un29tm6o","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇博文将会写一些自己日常用到的js排序算法.  排序算法一次性写完,个人感觉不太实际,所以会陆续更新比较好.</p>\n<hr>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*  输入数组快速排序</span></div><div class=\"line\">*   @params arr &#123;Array&#125;</div><div class=\"line\">*   @return &#123;Array&#125;</div><div class=\"line\">*/</div><div class=\"line\">function <span class=\"built_in\">quickSort</span>(arr) &#123;</div><div class=\"line\">  <span class=\"keyword\">while</span> (arr.length &lt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> midNumber = <span class=\"type\">Math</span>.floor(arr.length / <span class=\"number\">2</span>),</div><div class=\"line\">      <span class=\"comment\">// 从排序的数组中取出中位元素(splice会修改原来数组)</span></div><div class=\"line\">      midValue = arr.splice(midNumber,<span class=\"number\">1</span>),</div><div class=\"line\">      <span class=\"keyword\">left</span> = [],</div><div class=\"line\">      <span class=\"keyword\">right</span> = []</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    <span class=\"comment\">// 所有元素跟中位元素比较大小, 小于中位数的放在左边数组</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &lt; midValue[<span class=\"number\">0</span>]) &#123;</div><div class=\"line\">      <span class=\"keyword\">left</span>.push(arr[i])</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">right</span>.push(arr[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">quickSort</span>(<span class=\"keyword\">left</span>).concat(midValue,<span class=\"built_in\">quickSort</span>(<span class=\"keyword\">right</span>))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">22</span>,<span class=\"number\">11</span>,<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">quickSort</span>(arr)  <span class=\"comment\">// [1,2,3,11,22]</span></div></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-sort\"><a href=\"#Array-prototype-sort\" class=\"headerlink\" title=\"Array.prototype.sort()\"></a>Array.prototype.sort()</h3><p>sort() 方法在适当的位置对数组的元素进行排序，并返回数组。默认排序顺序是根据字符串Unicode码点。<br>sort(compareFunction) 使用compareFunction进行进阶排序需求。</p>\n<p>排序怎么能忘记JS原生的排序方法sort呢?  come on!  二话不说,代码撸起来..</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fruit = [<span class=\"string\">'cherries'</span>, <span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>];</div><div class=\"line\">fruit.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>, <span class=\"string\">'cherries'</span>]</div><div class=\"line\"></div><div class=\"line\">var scores = [<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>];</div><div class=\"line\">scores.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">21</span>]</div><div class=\"line\"><span class=\"regexp\">//</span> 注意<span class=\"number\">10</span>在<span class=\"number\">2</span>之前,</div><div class=\"line\"><span class=\"regexp\">//</span> because <span class=\"string\">'10'</span> comes before <span class=\"string\">'2'</span> <span class=\"keyword\">in</span> Unicode code point order.</div><div class=\"line\"></div><div class=\"line\">var things = [<span class=\"string\">'word'</span>, <span class=\"string\">'Word'</span>, <span class=\"string\">'1 Word'</span>, <span class=\"string\">'2 Words'</span>];</div><div class=\"line\">things.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"string\">'1 Word'</span>, <span class=\"string\">'2 Words'</span>, <span class=\"string\">'Word'</span>, <span class=\"string\">'word'</span>]</div><div class=\"line\"><span class=\"regexp\">//</span> 在Unicode中, 数字在大写字母之前,</div><div class=\"line\"><span class=\"regexp\">//</span> 大写字母在小写字母之前.</div></pre></td></tr></table></figure>\n<p>sort 方法可以使用 函数表达式 方便地书写：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var numbers = [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>];</div><div class=\"line\">numbers.sort((a, b) =&gt; a - b);</div><div class=\"line\">console.log(numbers);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>\n<p>对象可以按照某个属性排序：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var items = [</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Edward'</span>, <span class=\"string\">value:</span> <span class=\"number\">21</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Sharpe'</span>, <span class=\"string\">value:</span> <span class=\"number\">37</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'And'</span>, <span class=\"string\">value:</span> <span class=\"number\">45</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'The'</span>, <span class=\"string\">value:</span> <span class=\"number\">-12</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Magnetic'</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Zeros'</span>, <span class=\"string\">value:</span> <span class=\"number\">37</span> &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">items.sort(function (a, b) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (a.value &gt; b.value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (a.value &lt; b.value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// a 必须等于 b</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>compareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 需要被排序的数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">list</span> = [<span class=\"string\">'Delta'</span>, <span class=\"string\">'alpha'</span>, <span class=\"string\">'CHARLIE'</span>, <span class=\"string\">'bravo'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对需要排序的元素进行 位置临时存储 和 元素前处理</span></div><div class=\"line\"><span class=\"keyword\">var</span> mapped = <span class=\"keyword\">list</span>.map((item, i) =&gt; (</div><div class=\"line\"> &#123; index: i, value: item.toLowerCase() &#125;</div><div class=\"line\">))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对处理后的数据进行对个值的排序</span></div><div class=\"line\">mapped.sort((a, b) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class=\"number\">1</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 根据索引得到排序结果</span></div><div class=\"line\"><span class=\"keyword\">list</span>.map((item) =&gt; <span class=\"keyword\">list</span>[item.index] )</div></pre></td></tr></table></figure>","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇博文将会写一些自己日常用到的js排序算法.  排序算法一次性写完,个人感觉不太实际,所以会陆续更新比较好.</p>\n<hr>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*  输入数组快速排序</div><div class=\"line\">*   @params arr &#123;Array&#125;</div><div class=\"line\">*   @return &#123;Array&#125;</div><div class=\"line\">*/</span></div><div class=\"line\">function <span class=\"built_in\">quickSort</span>(arr) &#123;</div><div class=\"line\">  <span class=\"keyword\">while</span> (arr.length &lt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> midNumber = <span class=\"type\">Math</span>.floor(arr.length / <span class=\"number\">2</span>),</div><div class=\"line\">      <span class=\"comment\">// 从排序的数组中取出中位元素(splice会修改原来数组)</span></div><div class=\"line\">      midValue = arr.splice(midNumber,<span class=\"number\">1</span>),</div><div class=\"line\">      <span class=\"keyword\">left</span> = [],</div><div class=\"line\">      <span class=\"keyword\">right</span> = []</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    <span class=\"comment\">// 所有元素跟中位元素比较大小, 小于中位数的放在左边数组</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &lt; midValue[<span class=\"number\">0</span>]) &#123;</div><div class=\"line\">      <span class=\"keyword\">left</span>.push(arr[i])</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">right</span>.push(arr[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">quickSort</span>(<span class=\"keyword\">left</span>).concat(midValue,<span class=\"built_in\">quickSort</span>(<span class=\"keyword\">right</span>))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">22</span>,<span class=\"number\">11</span>,<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">quickSort</span>(arr)  <span class=\"comment\">// [1,2,3,11,22]</span></div></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-sort\"><a href=\"#Array-prototype-sort\" class=\"headerlink\" title=\"Array.prototype.sort()\"></a>Array.prototype.sort()</h3><p>sort() 方法在适当的位置对数组的元素进行排序，并返回数组。默认排序顺序是根据字符串Unicode码点。<br>sort(compareFunction) 使用compareFunction进行进阶排序需求。</p>\n<p>排序怎么能忘记JS原生的排序方法sort呢?  come on!  二话不说,代码撸起来..</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fruit = [<span class=\"string\">'cherries'</span>, <span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>];</div><div class=\"line\">fruit.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>, <span class=\"string\">'cherries'</span>]</div><div class=\"line\"></div><div class=\"line\">var scores = [<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>];</div><div class=\"line\">scores.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">21</span>]</div><div class=\"line\"><span class=\"regexp\">//</span> 注意<span class=\"number\">10</span>在<span class=\"number\">2</span>之前,</div><div class=\"line\"><span class=\"regexp\">//</span> because <span class=\"string\">'10'</span> comes before <span class=\"string\">'2'</span> <span class=\"keyword\">in</span> Unicode code point order.</div><div class=\"line\"></div><div class=\"line\">var things = [<span class=\"string\">'word'</span>, <span class=\"string\">'Word'</span>, <span class=\"string\">'1 Word'</span>, <span class=\"string\">'2 Words'</span>];</div><div class=\"line\">things.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"string\">'1 Word'</span>, <span class=\"string\">'2 Words'</span>, <span class=\"string\">'Word'</span>, <span class=\"string\">'word'</span>]</div><div class=\"line\"><span class=\"regexp\">//</span> 在Unicode中, 数字在大写字母之前,</div><div class=\"line\"><span class=\"regexp\">//</span> 大写字母在小写字母之前.</div></pre></td></tr></table></figure>\n<p>sort 方法可以使用 函数表达式 方便地书写：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var numbers = [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>];</div><div class=\"line\">numbers.sort((a, b) =&gt; a - b);</div><div class=\"line\">console.log(numbers);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>\n<p>对象可以按照某个属性排序：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var items = [</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Edward'</span>, <span class=\"string\">value:</span> <span class=\"number\">21</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Sharpe'</span>, <span class=\"string\">value:</span> <span class=\"number\">37</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'And'</span>, <span class=\"string\">value:</span> <span class=\"number\">45</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'The'</span>, <span class=\"string\">value:</span> <span class=\"number\">-12</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Magnetic'</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Zeros'</span>, <span class=\"string\">value:</span> <span class=\"number\">37</span> &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">items.sort(function (a, b) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (a.value &gt; b.value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (a.value &lt; b.value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// a 必须等于 b</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>compareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 需要被排序的数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">list</span> = [<span class=\"string\">'Delta'</span>, <span class=\"string\">'alpha'</span>, <span class=\"string\">'CHARLIE'</span>, <span class=\"string\">'bravo'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对需要排序的元素进行 位置临时存储 和 元素前处理</span></div><div class=\"line\"><span class=\"keyword\">var</span> mapped = <span class=\"keyword\">list</span>.map((item, i) =&gt; (</div><div class=\"line\"> &#123; index: i, value: item.toLowerCase() &#125;</div><div class=\"line\">))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对处理后的数据进行对个值的排序</span></div><div class=\"line\">mapped.sort((a, b) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class=\"number\">1</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 根据索引得到排序结果</span></div><div class=\"line\"><span class=\"keyword\">list</span>.map((item) =&gt; <span class=\"keyword\">list</span>[item.index] )</div></pre></td></tr></table></figure>"},{"title":"JS深复制与浅复制","subtitle":"深复制函数实现","date":"2017-07-03T02:00:53.000Z","author":"Damon","header-img":"/img/about-bg.jpg","_content":"\n## 前言\n\n前段时间学习函数式编程,里面有一个重要的概念就是,函数永远不要对数据作修改。 不修改数据，意味着输入一个变量，经过计算后返回的永远都是一个新的变量。 这么做的好处是让数据可以进行所谓的时间旅行，在任何的时间可以回溯到系统的之前的任意状态，而不引起副作用。\n\nwell！ 复制JS的基本数据类型，再简单不过了，直接创建一个新变量然后进行赋值，这么做就完成简单赋值. 如下:\n```\nvar foo = 'go';\nvar copy = foo; \nfoo = 'gooooooo';\nconsole.log(copy)   // 'go'\n```\n但是,如果复制对象不是基本数据类型,那么就会就会出现以下状况:\n```\nvar object = { obj: { a: 1, b: 2 } };\nvar copy = object;\nobject.obj.a = 100\nconsole.log(copy)   //  { obj: { a: 100, b: 2 } }\n```\n由此可见, copy.obj 只是对object.obj 的一个引用。(这就是浅复制)   \n这并不是我们所期待的结果.我们想要的是,copy对象与object之间再没有任何关系,无论我们怎么修改object。\n所以,这就产生了深复制的需求(复制品 与 被复制品的数据完全独立,修改其中一个对象不会改变另外一个对象)。\n\n## 实现\n\n前面,介绍浅复制和深复制。JS原生没有实现深复制的api,所以只能我们自己造轮子。（万恶的javascript,为什么就没有深复制api呢... 可能是为了省点内存吧?）\n```\nfunction deepClone(obj) {\n    if (typeof obj !== 'object') {\n        return obj\n    }\n    var newObj = Array.isArray(obj) ? [] : {}\n\n    for (var key in obj) {\n        var val = obj[key]\n        if (typeof obj[key] === 'object') {\n            newObj[key] = deepClone(val)\n        } else {\n            newObj[key] = val\n        }\n    }\n    return newObj\n}\n\nvar src = { ss: { w: 1 }, j: [1, { s: 3, j: [2, 4] }] }\nvar copy = deepClone(src)\n\nsrc.ss.w = 444\ncopy.ss.w = '真的6'\nconsole.log(JSON.stringify(src))    // { ss: { w: 444 }, j: [1, { s: 3, j: [2, 4] }] }\nconsole.log(JSON.stringify(copy))   // { ss: { w: '真的6' }, j: [1, { s: 3, j: [2, 4] }] }\n```\n嗯. 以上可以看到复制品和被复制品之间,相互是独立的. 这样我们就可以放心操作他们修改他们,而不必担心任何副作用了(除了多占浏览器一丁点内存外).","source":"_posts/JS深复制与浅复制.md","raw":"---\ntitle: JS深复制与浅复制\nsubtitle: 深复制函数实现\ndate: 2017-07-03 10:00:53\nauthor: \"Damon\"\nheader-img: \"/img/about-bg.jpg\"\ntags:\n    - JS\n    - 前端面试\n---\n\n## 前言\n\n前段时间学习函数式编程,里面有一个重要的概念就是,函数永远不要对数据作修改。 不修改数据，意味着输入一个变量，经过计算后返回的永远都是一个新的变量。 这么做的好处是让数据可以进行所谓的时间旅行，在任何的时间可以回溯到系统的之前的任意状态，而不引起副作用。\n\nwell！ 复制JS的基本数据类型，再简单不过了，直接创建一个新变量然后进行赋值，这么做就完成简单赋值. 如下:\n```\nvar foo = 'go';\nvar copy = foo; \nfoo = 'gooooooo';\nconsole.log(copy)   // 'go'\n```\n但是,如果复制对象不是基本数据类型,那么就会就会出现以下状况:\n```\nvar object = { obj: { a: 1, b: 2 } };\nvar copy = object;\nobject.obj.a = 100\nconsole.log(copy)   //  { obj: { a: 100, b: 2 } }\n```\n由此可见, copy.obj 只是对object.obj 的一个引用。(这就是浅复制)   \n这并不是我们所期待的结果.我们想要的是,copy对象与object之间再没有任何关系,无论我们怎么修改object。\n所以,这就产生了深复制的需求(复制品 与 被复制品的数据完全独立,修改其中一个对象不会改变另外一个对象)。\n\n## 实现\n\n前面,介绍浅复制和深复制。JS原生没有实现深复制的api,所以只能我们自己造轮子。（万恶的javascript,为什么就没有深复制api呢... 可能是为了省点内存吧?）\n```\nfunction deepClone(obj) {\n    if (typeof obj !== 'object') {\n        return obj\n    }\n    var newObj = Array.isArray(obj) ? [] : {}\n\n    for (var key in obj) {\n        var val = obj[key]\n        if (typeof obj[key] === 'object') {\n            newObj[key] = deepClone(val)\n        } else {\n            newObj[key] = val\n        }\n    }\n    return newObj\n}\n\nvar src = { ss: { w: 1 }, j: [1, { s: 3, j: [2, 4] }] }\nvar copy = deepClone(src)\n\nsrc.ss.w = 444\ncopy.ss.w = '真的6'\nconsole.log(JSON.stringify(src))    // { ss: { w: 444 }, j: [1, { s: 3, j: [2, 4] }] }\nconsole.log(JSON.stringify(copy))   // { ss: { w: '真的6' }, j: [1, { s: 3, j: [2, 4] }] }\n```\n嗯. 以上可以看到复制品和被复制品之间,相互是独立的. 这样我们就可以放心操作他们修改他们,而不必担心任何副作用了(除了多占浏览器一丁点内存外).","slug":"JS深复制与浅复制","published":1,"updated":"2017-07-05T02:53:19.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4qesf890002c4v59sygijgi","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前段时间学习函数式编程,里面有一个重要的概念就是,函数永远不要对数据作修改。 不修改数据，意味着输入一个变量，经过计算后返回的永远都是一个新的变量。 这么做的好处是让数据可以进行所谓的时间旅行，在任何的时间可以回溯到系统的之前的任意状态，而不引起副作用。</p>\n<p>well！ 复制JS的基本数据类型，再简单不过了，直接创建一个新变量然后进行赋值，这么做就完成简单赋值. 如下:<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = <span class=\"string\">'go'</span>;</div><div class=\"line\">var <span class=\"keyword\">copy</span><span class=\"bash\"> = foo; </span></div><div class=\"line\">foo = <span class=\"string\">'gooooooo'</span>;</div><div class=\"line\">console.log(<span class=\"keyword\">copy</span><span class=\"bash\">)   // <span class=\"string\">'go'</span></span></div></pre></td></tr></table></figure></p>\n<p>但是,如果复制对象不是基本数据类型,那么就会就会出现以下状况:<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"class\"><span class=\"keyword\">object</span> </span>= &#123; obj: &#123; a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span> &#125; &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> copy = <span class=\"class\"><span class=\"keyword\">object</span></span>;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span>.<span class=\"title\">obj</span>.<span class=\"title\">a</span> </span>= <span class=\"number\">100</span></div><div class=\"line\">console.log(copy)   <span class=\"comment\">//  &#123; obj: &#123; a: 100, b: 2 &#125; &#125;</span></div></pre></td></tr></table></figure></p>\n<p>由此可见, copy.obj 只是对object.obj 的一个引用。(这就是浅复制)<br>这并不是我们所期待的结果.我们想要的是,copy对象与object之间再没有任何关系,无论我们怎么修改object。<br>所以,这就产生了深复制的需求(复制品 与 被复制品的数据完全独立,修改其中一个对象不会改变另外一个对象)。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>前面,介绍浅复制和深复制。JS原生没有实现深复制的api,所以只能我们自己造轮子。（万恶的javascript,为什么就没有深复制api呢… 可能是为了省点内存吧?）<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span></span>(obj) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (typeof obj !== <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> obj</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Obj</span> = <span class=\"keyword\">Array</span>.isArray(obj) ? [] : <span class=\"type\"></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> val = obj[key]</div><div class=\"line\">        <span class=\"keyword\">if</span> (typeof obj[key] === <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">new</span><span class=\"type\">Obj</span>[key] = deepClone(val)</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">new</span><span class=\"type\">Obj</span>[key] = val</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span><span class=\"type\">Obj</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> src = &#123; ss: <span class=\"type\"></span>&#123; w: <span class=\"type\">1 </span>&#125;, j: <span class=\"type\"></span>[<span class=\"number\">1</span>, &#123; s: <span class=\"type\">3</span>, j: <span class=\"type\"></span>[<span class=\"number\">2</span>, <span class=\"number\">4</span>] &#125;] &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> copy = deepClone(src)</div><div class=\"line\"></div><div class=\"line\">src.ss.w = <span class=\"number\">444</span></div><div class=\"line\">copy.ss.w = <span class=\"string\">'真的6'</span></div><div class=\"line\">console.log(JSON.stringify(src))    <span class=\"comment\">// &#123; ss: &#123; w: 444 &#125;, j: [1, &#123; s: 3, j: [2, 4] &#125;] &#125;</span></div><div class=\"line\">console.log(JSON.stringify(copy))   <span class=\"comment\">// &#123; ss: &#123; w: '真的6' &#125;, j: [1, &#123; s: 3, j: [2, 4] &#125;] &#125;</span></div></pre></td></tr></table></figure></p>\n<p>嗯. 以上可以看到复制品和被复制品之间,相互是独立的. 这样我们就可以放心操作他们修改他们,而不必担心任何副作用了(除了多占浏览器一丁点内存外).</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前段时间学习函数式编程,里面有一个重要的概念就是,函数永远不要对数据作修改。 不修改数据，意味着输入一个变量，经过计算后返回的永远都是一个新的变量。 这么做的好处是让数据可以进行所谓的时间旅行，在任何的时间可以回溯到系统的之前的任意状态，而不引起副作用。</p>\n<p>well！ 复制JS的基本数据类型，再简单不过了，直接创建一个新变量然后进行赋值，这么做就完成简单赋值. 如下:<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = <span class=\"string\">'go'</span>;</div><div class=\"line\">var <span class=\"keyword\">copy</span><span class=\"bash\"> = foo; </div><div class=\"line\"></span>foo = <span class=\"string\">'gooooooo'</span>;</div><div class=\"line\">console.log(<span class=\"keyword\">copy</span><span class=\"bash\">)   // <span class=\"string\">'go'</span></span></div></pre></td></tr></table></figure></p>\n<p>但是,如果复制对象不是基本数据类型,那么就会就会出现以下状况:<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"class\"><span class=\"keyword\">object</span> </span>= &#123; obj: &#123; a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span> &#125; &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> copy = <span class=\"class\"><span class=\"keyword\">object</span></span>;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span>.<span class=\"title\">obj</span>.<span class=\"title\">a</span> </span>= <span class=\"number\">100</span></div><div class=\"line\">console.log(copy)   <span class=\"comment\">//  &#123; obj: &#123; a: 100, b: 2 &#125; &#125;</span></div></pre></td></tr></table></figure></p>\n<p>由此可见, copy.obj 只是对object.obj 的一个引用。(这就是浅复制)<br>这并不是我们所期待的结果.我们想要的是,copy对象与object之间再没有任何关系,无论我们怎么修改object。<br>所以,这就产生了深复制的需求(复制品 与 被复制品的数据完全独立,修改其中一个对象不会改变另外一个对象)。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>前面,介绍浅复制和深复制。JS原生没有实现深复制的api,所以只能我们自己造轮子。（万恶的javascript,为什么就没有深复制api呢… 可能是为了省点内存吧?）<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span></span>(obj) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (typeof obj !== <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> obj</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Obj</span> = <span class=\"keyword\">Array</span>.isArray(obj) ? [] : <span class=\"type\"></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> val = obj[key]</div><div class=\"line\">        <span class=\"keyword\">if</span> (typeof obj[key] === <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">new</span><span class=\"type\">Obj</span>[key] = deepClone(val)</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">new</span><span class=\"type\">Obj</span>[key] = val</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span><span class=\"type\">Obj</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> src = &#123; ss: <span class=\"type\"></span>&#123; w: <span class=\"type\">1 </span>&#125;, j: <span class=\"type\"></span>[<span class=\"number\">1</span>, &#123; s: <span class=\"type\">3</span>, j: <span class=\"type\"></span>[<span class=\"number\">2</span>, <span class=\"number\">4</span>] &#125;] &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> copy = deepClone(src)</div><div class=\"line\"></div><div class=\"line\">src.ss.w = <span class=\"number\">444</span></div><div class=\"line\">copy.ss.w = <span class=\"string\">'真的6'</span></div><div class=\"line\">console.log(JSON.stringify(src))    <span class=\"comment\">// &#123; ss: &#123; w: 444 &#125;, j: [1, &#123; s: 3, j: [2, 4] &#125;] &#125;</span></div><div class=\"line\">console.log(JSON.stringify(copy))   <span class=\"comment\">// &#123; ss: &#123; w: '真的6' &#125;, j: [1, &#123; s: 3, j: [2, 4] &#125;] &#125;</span></div></pre></td></tr></table></figure></p>\n<p>嗯. 以上可以看到复制品和被复制品之间,相互是独立的. 这样我们就可以放心操作他们修改他们,而不必担心任何副作用了(除了多占浏览器一丁点内存外).</p>\n"},{"layout":"post","title":"About Javascript","date":"2017-03-22T16:00:00.000Z","author":"chaoming","header-img":"post-bg-js-version.jpg","_content":"\n\nJavaScript 有着很奇怪的命名史。\n\n1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript *（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）*\n\n![java-javascript](javascript-java.jpg)\n<small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small>\n\n> 译者注：[wikipedia 的 JavaScript 词条](https://en.wikipedia.org/wiki/JavaScript#History) 更详细的叙述了这段历史\n\n1996 年，网景将 JavaScript 提交给 [ECMA International（欧洲计算机制造商协会）](http://www.ecma-international.org/) 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。\n\n\n> 术语（译者注）：\n>\n> * *标准（Standard）*： 用于定义与其他事物区别的一套规则\n> * *实现（Implementation）*： 某个标准的具体实施/真实实践\n\n\n不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。\n\n> 译者注：[ECMAScript 第四版草案](https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29)由于太过激进而被抛弃，Adobe 的 [ActionScript 3.0](https://en.wikipedia.org/wiki/ActionScript) 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）\n\n到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）\n\n目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 [decorators（装饰者）](https://github.com/wycats/javascript-decorators)，[async-await（async-await 异步编程模型）](https://github.com/lukehoban/ecmascript-asyncawait) 和 [static class properties（静态类属性）](https://github.com/jeffmo/es-class-properties)。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 [Babel 的官网](https://babeljs.io/docs/usage/experimental/) 上查看各个提案目前都在哪个阶段了。\n\n所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：\n\n* **ECMAScript**：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。\n* **JavaScript**：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。\n* **ECMAScript 5 (ES5)**：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。\n* **ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)**：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅[这张兼容性表](http://kangax.github.io/compat-table/es6/)来查看不同浏览器和工具的实现情况。\n* **ECMAScript 2016**：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定\n* **ECMAScript Proposals**：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。\n\n在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。\n\n#### 一些资源\n\n\n\n* TC39 的 [Github 仓库](https://github.com/tc39/ecma262)上可以看到所有目前公开的提案\n* 如果你还不熟悉 ES6，Babel 有一个[很不错的特性概览](https://babeljs.io/docs/learn-es2015/)\n* 如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 [Exploring ES6](http://exploringjs.com/)和 Nicholas Zakas 的 [Understanding ECMAScript 6](https://leanpub.com/understandinges6)。Axel 的博客 [2ality](http://www.2ality.com/) 也是很不错的 ES6 资源\n\n<img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\" />\n<small class=\"img-hint\">来学 JavaScript 吧！</small>\n\n#### 著作权声明\n\n本文译自 [ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?](http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/)\n译者 [黄玄](http://weibo.com/huxpro)，转载请保留以上链接。\n学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。\n\n\n","source":"_posts/about-javascript.md","raw":"---\nlayout:     post\ntitle:      \"About Javascript\"\ndate:       2017-03-23\nauthor:     \"chaoming\"\nheader-img: \"post-bg-js-version.jpg\"\ntags:\n    - JavaScript\n    - 翻译\n---\n\n\nJavaScript 有着很奇怪的命名史。\n\n1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript *（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）*\n\n![java-javascript](javascript-java.jpg)\n<small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small>\n\n> 译者注：[wikipedia 的 JavaScript 词条](https://en.wikipedia.org/wiki/JavaScript#History) 更详细的叙述了这段历史\n\n1996 年，网景将 JavaScript 提交给 [ECMA International（欧洲计算机制造商协会）](http://www.ecma-international.org/) 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。\n\n\n> 术语（译者注）：\n>\n> * *标准（Standard）*： 用于定义与其他事物区别的一套规则\n> * *实现（Implementation）*： 某个标准的具体实施/真实实践\n\n\n不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。\n\n> 译者注：[ECMAScript 第四版草案](https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29)由于太过激进而被抛弃，Adobe 的 [ActionScript 3.0](https://en.wikipedia.org/wiki/ActionScript) 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）\n\n到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）\n\n目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 [decorators（装饰者）](https://github.com/wycats/javascript-decorators)，[async-await（async-await 异步编程模型）](https://github.com/lukehoban/ecmascript-asyncawait) 和 [static class properties（静态类属性）](https://github.com/jeffmo/es-class-properties)。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 [Babel 的官网](https://babeljs.io/docs/usage/experimental/) 上查看各个提案目前都在哪个阶段了。\n\n所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：\n\n* **ECMAScript**：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。\n* **JavaScript**：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。\n* **ECMAScript 5 (ES5)**：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。\n* **ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)**：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅[这张兼容性表](http://kangax.github.io/compat-table/es6/)来查看不同浏览器和工具的实现情况。\n* **ECMAScript 2016**：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定\n* **ECMAScript Proposals**：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。\n\n在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。\n\n#### 一些资源\n\n\n\n* TC39 的 [Github 仓库](https://github.com/tc39/ecma262)上可以看到所有目前公开的提案\n* 如果你还不熟悉 ES6，Babel 有一个[很不错的特性概览](https://babeljs.io/docs/learn-es2015/)\n* 如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 [Exploring ES6](http://exploringjs.com/)和 Nicholas Zakas 的 [Understanding ECMAScript 6](https://leanpub.com/understandinges6)。Axel 的博客 [2ality](http://www.2ality.com/) 也是很不错的 ES6 资源\n\n<img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\" />\n<small class=\"img-hint\">来学 JavaScript 吧！</small>\n\n#### 著作权声明\n\n本文译自 [ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?](http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/)\n译者 [黄玄](http://weibo.com/huxpro)，转载请保留以上链接。\n学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。\n\n\n","slug":"about-javascript","published":1,"updated":"2017-03-27T07:19:48.410Z","comments":1,"photos":[],"link":"","_id":"cj4qesf890004c4v5sca3snr1","content":"<p>JavaScript 有着很奇怪的命名史。</p>\n<p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p>\n<p><img src=\"javascript-java.jpg\" alt=\"java-javascript\"><br><small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small></p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/JavaScript#History\" target=\"_blank\" rel=\"external\">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p>\n</blockquote>\n<p>1996 年，网景将 JavaScript 提交给 <a href=\"http://www.ecma-international.org/\" target=\"_blank\" rel=\"external\">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p>\n<blockquote>\n<p>术语（译者注）：</p>\n<ul>\n<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>\n<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>\n</ul>\n</blockquote>\n<p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29\" target=\"_blank\" rel=\"external\">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href=\"https://en.wikipedia.org/wiki/ActionScript\" target=\"_blank\" rel=\"external\">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p>\n</blockquote>\n<p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p>\n<p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href=\"https://github.com/wycats/javascript-decorators\" target=\"_blank\" rel=\"external\">decorators（装饰者）</a>，<a href=\"https://github.com/lukehoban/ecmascript-asyncawait\" target=\"_blank\" rel=\"external\">async-await（async-await 异步编程模型）</a> 和 <a href=\"https://github.com/jeffmo/es-class-properties\" target=\"_blank\" rel=\"external\">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href=\"https://babeljs.io/docs/usage/experimental/\" target=\"_blank\" rel=\"external\">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p>\n<p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p>\n<ul>\n<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>\n<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>\n<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>\n<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"external\">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>\n<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>\n<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>\n</ul>\n<p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p>\n<h4 id=\"一些资源\"><a href=\"#一些资源\" class=\"headerlink\" title=\"一些资源\"></a>一些资源</h4><ul>\n<li>TC39 的 <a href=\"https://github.com/tc39/ecma262\" target=\"_blank\" rel=\"external\">Github 仓库</a>上可以看到所有目前公开的提案</li>\n<li>如果你还不熟悉 ES6，Babel 有一个<a href=\"https://babeljs.io/docs/learn-es2015/\" target=\"_blank\" rel=\"external\">很不错的特性概览</a></li>\n<li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href=\"http://exploringjs.com/\" target=\"_blank\" rel=\"external\">Exploring ES6</a>和 Nicholas Zakas 的 <a href=\"https://leanpub.com/understandinges6\" target=\"_blank\" rel=\"external\">Understanding ECMAScript 6</a>。Axel 的博客 <a href=\"http://www.2ality.com/\" target=\"_blank\" rel=\"external\">2ality</a> 也是很不错的 ES6 资源</li>\n</ul>\n<p><img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\"><br><small class=\"img-hint\">来学 JavaScript 吧！</small></p>\n<h4 id=\"著作权声明\"><a href=\"#著作权声明\" class=\"headerlink\" title=\"著作权声明\"></a>著作权声明</h4><p>本文译自 <a href=\"http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/\" target=\"_blank\" rel=\"external\">ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?</a><br>译者 <a href=\"http://weibo.com/huxpro\" target=\"_blank\" rel=\"external\">黄玄</a>，转载请保留以上链接。<br>学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。</p>\n","excerpt":"","more":"<p>JavaScript 有着很奇怪的命名史。</p>\n<p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p>\n<p><img src=\"javascript-java.jpg\" alt=\"java-javascript\"><br><small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small></p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/JavaScript#History\">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p>\n</blockquote>\n<p>1996 年，网景将 JavaScript 提交给 <a href=\"http://www.ecma-international.org/\">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p>\n<blockquote>\n<p>术语（译者注）：</p>\n<ul>\n<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>\n<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>\n</ul>\n</blockquote>\n<p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29\">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href=\"https://en.wikipedia.org/wiki/ActionScript\">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p>\n</blockquote>\n<p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p>\n<p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href=\"https://github.com/wycats/javascript-decorators\">decorators（装饰者）</a>，<a href=\"https://github.com/lukehoban/ecmascript-asyncawait\">async-await（async-await 异步编程模型）</a> 和 <a href=\"https://github.com/jeffmo/es-class-properties\">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href=\"https://babeljs.io/docs/usage/experimental/\">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p>\n<p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p>\n<ul>\n<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>\n<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>\n<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>\n<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href=\"http://kangax.github.io/compat-table/es6/\">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>\n<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>\n<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>\n</ul>\n<p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p>\n<h4 id=\"一些资源\"><a href=\"#一些资源\" class=\"headerlink\" title=\"一些资源\"></a>一些资源</h4><ul>\n<li>TC39 的 <a href=\"https://github.com/tc39/ecma262\">Github 仓库</a>上可以看到所有目前公开的提案</li>\n<li>如果你还不熟悉 ES6，Babel 有一个<a href=\"https://babeljs.io/docs/learn-es2015/\">很不错的特性概览</a></li>\n<li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href=\"http://exploringjs.com/\">Exploring ES6</a>和 Nicholas Zakas 的 <a href=\"https://leanpub.com/understandinges6\">Understanding ECMAScript 6</a>。Axel 的博客 <a href=\"http://www.2ality.com/\">2ality</a> 也是很不错的 ES6 资源</li>\n</ul>\n<p><img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\" /><br><small class=\"img-hint\">来学 JavaScript 吧！</small></p>\n<h4 id=\"著作权声明\"><a href=\"#著作权声明\" class=\"headerlink\" title=\"著作权声明\"></a>著作权声明</h4><p>本文译自 <a href=\"http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/\">ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?</a><br>译者 <a href=\"http://weibo.com/huxpro\">黄玄</a>，转载请保留以上链接。<br>学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。</p>\n"},{"layout":"post","title":"Welcome to Chaoming Blog","subtitle":" \"Hello World, Hello Blog\"","date":"2017-03-18T03:23:26.000Z","author":"Damon","header-img":"post-bg-unix-linux.jpg","_content":"\n> “Yeah It's on. ”\n\n\n## 前言\n\nChaoming 的 Blog 就这么开通了。\n\n[跳过废话，直接看技术实现 ](#build)\n\n\n\n2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。\n\n\n作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。\n\n这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!\n<p id = \"build\"></p>\n---\n\n## 正文\n\n接下来说说搭建这个博客的技术细节。  \n\nHexo其优点非常明显：\n\n* **Markdown** 带来的优雅写作体验\n* 非常熟悉的 Git workflow ，**Git Commit 即 Blog Post**\n* 利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机\n    * 如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了\n\n\n本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个[镜像](http://huxpro.gitcafe.io)出来，结果还是巨慢。\n\n哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 **pending 在了 Google Fonts** 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。  \n忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!\n\n---\n\n配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。\n\nTheme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接**hexo d**提交到自己github上。这真的超级方便！瞬间爱上Hexo！\n\n不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用**hexo d**提交代码的时候就出事了,直接报错&%$*&^*%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。\n\n最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。\n\n以后，好好说话呗。。。\n\n\n\n","source":"_posts/hello-blog.md","raw":"---\nlayout:     post\ntitle:      \"Welcome to Chaoming Blog\"\nsubtitle:   \" \\\"Hello World, Hello Blog\\\"\"\ndate:       2017-03-18 11:23:26\nauthor:     \"Damon\"\nheader-img: \"post-bg-unix-linux.jpg\"\ntags:\n    - 生活\n---\n\n> “Yeah It's on. ”\n\n\n## 前言\n\nChaoming 的 Blog 就这么开通了。\n\n[跳过废话，直接看技术实现 ](#build)\n\n\n\n2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。\n\n\n作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。\n\n这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!\n<p id = \"build\"></p>\n---\n\n## 正文\n\n接下来说说搭建这个博客的技术细节。  \n\nHexo其优点非常明显：\n\n* **Markdown** 带来的优雅写作体验\n* 非常熟悉的 Git workflow ，**Git Commit 即 Blog Post**\n* 利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机\n    * 如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了\n\n\n本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个[镜像](http://huxpro.gitcafe.io)出来，结果还是巨慢。\n\n哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 **pending 在了 Google Fonts** 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。  \n忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!\n\n---\n\n配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。\n\nTheme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接**hexo d**提交到自己github上。这真的超级方便！瞬间爱上Hexo！\n\n不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用**hexo d**提交代码的时候就出事了,直接报错&%$*&^*%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。\n\n最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。\n\n以后，好好说话呗。。。\n\n\n\n","slug":"hello-blog","published":1,"updated":"2017-03-18T06:23:59.277Z","comments":1,"photos":[],"link":"","_id":"cj4qesf8o0005c4v5jedxxvfo","content":"<blockquote>\n<p>“Yeah It’s on. ”</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Chaoming 的 Blog 就这么开通了。</p>\n<p><a href=\"#build\">跳过废话，直接看技术实现 </a></p>\n<p>2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。</p>\n<p>作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。</p>\n<p>这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p id=\"build\"></p></h2><h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p>\n<p>Hexo其优点非常明显：</p>\n<ul>\n<li><strong>Markdown</strong> 带来的优雅写作体验</li>\n<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>\n<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机<ul>\n<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li>\n</ul>\n</li>\n</ul>\n<p>本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个<a href=\"http://huxpro.gitcafe.io\" target=\"_blank\" rel=\"external\">镜像</a>出来，结果还是巨慢。</p>\n<p>哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 <strong>pending 在了 Google Fonts</strong> 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。<br>忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!</p>\n<hr>\n<p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。</p>\n<p>Theme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接<strong>hexo d</strong>提交到自己github上。这真的超级方便！瞬间爱上Hexo！</p>\n<p>不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用<strong>hexo d</strong>提交代码的时候就出事了,直接报错&amp;%$<em>&amp;^</em>%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。</p>\n<p>最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。</p>\n<p>以后，好好说话呗。。。</p>\n","excerpt":"","more":"<blockquote>\n<p>“Yeah It’s on. ”</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Chaoming 的 Blog 就这么开通了。</p>\n<p><a href=\"#build\">跳过废话，直接看技术实现 </a></p>\n<p>2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。</p>\n<p>作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。</p>\n<p>这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p id = \"build\"></p></h2><h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p>\n<p>Hexo其优点非常明显：</p>\n<ul>\n<li><strong>Markdown</strong> 带来的优雅写作体验</li>\n<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>\n<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机<ul>\n<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li>\n</ul>\n</li>\n</ul>\n<p>本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个<a href=\"http://huxpro.gitcafe.io\">镜像</a>出来，结果还是巨慢。</p>\n<p>哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 <strong>pending 在了 Google Fonts</strong> 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。<br>忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!</p>\n<hr>\n<p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。</p>\n<p>Theme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接<strong>hexo d</strong>提交到自己github上。这真的超级方便！瞬间爱上Hexo！</p>\n<p>不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用<strong>hexo d</strong>提交代码的时候就出事了,直接报错&amp;%$<em>&amp;^</em>%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。</p>\n<p>最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。</p>\n<p>以后，好好说话呗。。。</p>\n"},{"layout":"post","title":"JS模块加载","subtitle":"CommonJS，RequireJS，SeaJS 归纳笔记","date":"2017-03-23T14:45:58.000Z","author":"Damon","catalog":true,"header-img":"post-bg-js-module.jpg","_content":"\n\n\n## Foreword\n\n> Here comes Module!\n\n随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。\n\n于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。\n\n\n---\n\n## Catalog\n\n\n1.  [CommonJS & Node](#commonjs--node)\n3.  [History](#history)\n4.  [RequireJS & AMD](#requirejs--amd)\n5.  [SeaJS & CMD](#seajs--cmd)\n6.  [AMD vs CMD](#amd-vs-cmd)\n7.  [WebPack](#webpack)\n\n\n\n```\nfunction autoDetect(){\n    console.log('ye, it is written in JavaScript!')\n}\n```\n\n## CommonJS & Node\n\n> Javascript: not just for browsers any more! —— CommonJS Slogen\n\n前端模块化的事实标准之一，2009 年 8 月，[CommonJS](http://wiki.commonjs.org/wiki/CommonJS) 诞生。\n\nCommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。\n\n\n让我们看看 Node 中的实现：\n{% codeblock lang:js %}\n// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper\n// \"as though the module was wrapped in a function\"\n\nvar a = require('./a')  // 加载模块（同步加载）\na.doSomething()         // 等上一句执行完才会执行\n\nexports.b = function(){ // 暴露 b 函数接口\n  // do something\n}\n{% endcodeblock %}\n\n\n`exports`是一个内置对象，就像`require`是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写`module.exports`就可以了。\n\nCommonJS 前身叫 ServerJS ，**后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS** 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。\n\n\n因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：\n\n* 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）\n* 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。\n* 都在向着 **COMMON** 的方向进化：**兼容不同风格，兼容浏览器和服务器两种环境**\n\n本文接下来要讨论的典例是：\n\n* RequireJS & AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）\n* SeaJS & CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）\n\n\n\n\n\n## History\n\n<!--<h2 id=\"history\"> History </h2>-->\n\n> 此段落参考自玉伯的 [前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588)\n\n09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 [Modules/1.0](http://wiki.commonjs.org/wiki/Modules) 规范，并且在 Node.js 等环境下取得了很不错的实践。\n\n09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：\n\n\n1. **Modules/1.x** 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 [Modules/Transport](http://wiki.commonjs.org/wiki/Modules/Transport) 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。\n2. **Modules/Async** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 [AMD](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 规范及其实现 [RequireJS](http://requirejs.org/)。这个稍后再细说。\n3. **Modules/2.0** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了\n\n\n补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 `add`和`use` 两个源自于 YUI Modules 的函数名替换了 `define` 和 `require` ，但其原理更接近 RequireJS ，与 YUI Modules 的 `Y` 沙箱 Attach 机制并不相同\n\n\n## RequireJS & AMD\n\n[AMD (Async Module Definition)](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\n> RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments\n\nRequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：\n\n{% gist 65481dbbf6d16e831a6cc89c3e37e6e5 display-emails-from-database.php %}\n\n\n> As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?\n\n所以我们需要 **Function Wrapping** 来获取依赖并且提前通过 script tag 提前加载进来\n\n\n{% jsfiddle shorttag [tabs] [skin] [width] [height] %}\n\n\n当依赖模块非常多时，这种**依赖前置**的写法会显得有点奇怪，所以 AMD 给了一个语法糖， **simplified CommonJS wrapping**，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：\n\n```js\ndefine(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\nThe AMD loader will parse out the `require('')` calls by using `Function.prototype.toString()`, then internally convert the above define call into this:\n\n```js\ndefine(['require', 'dependency1', 'dependency2'], function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\n\n出于`Function.prototype.toString()`兼容性和性能的考虑，最好的做法还是做一次 **optimized build**\n\n\n\nAMD 和 CommonJS 的核心争议如下：\n\n### 1. **执行时机**\n\nModules/1.0:\n\n```js\nvar a = require(\"./a\") // 执行到此时，a.js 才同步下载并执行\n```\n\nAMD: （使用 require 的语法糖时）\n\n```js\ndefine([\"require\"],function(require)){\n    // 在这里，a.js 已经下载并且执行好了\n    // 使用 require() 并不是 AMD 的推荐写法\n    var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n})\n```\n\nAMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）\n\n但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。\n\n### 2. **书写风格**\n\nAMD 推荐的风格并不使用`require`，而是通过参数传入，破坏了**依赖就近**：\n\n```js\ndefine([\"a\", \"b\", \"c\"],function(a, b, c){\n    // 提前申明了并初始化了所有模块\n\n    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。\n})\n```\n\n不过，在笔者看来，风格喜好因人而异，主要还是**预执行**和**懒执行**的差异。\n\n另外，require 2.0 也开始思考异步处理**软依赖**（区别于一定需要的**硬依赖**）的问题，提出了这样的方案：\n\n```js\n// 函数体内：\nif(status){\n    async(['a'],function(a){\n        a.doSomething()\n    })\n}\n```\n\n## SeaJS & CMD\n\nCMD (Common Module Definition) 是 [SeaJS](http://seajs.org/docs/) 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。\n\n不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。\n\n* CMD Specification\n    * [English (CMDJS-repo)](https://github.com/cmdjs/specification/blob/master/draft/module.md)\n    * [Chinese (SeaJS-repo)](https://github.com/seajs/seajs/issues/242)\n\n\nCMD 主要有 define, factory, require, export 这么几个东西\n\n * define `define(id?, deps?, factory)`\n * factory `factory(require, exports, module)`\n * require `require(id)`\n * exports `Object`\n\n\nCMD 推荐的 Code Style 是使用 CommonJS 风格的 `require`：\n\n* 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已\n\n```js\ndefine(function(require, exports) {\n\n    // 获取模块 a 的接口\n    var a = require('./a');\n    // 调用模块 a 的方法\n    a.doSomething();\n\n    // 对外提供 foo 属性\n    exports.foo = 'bar';\n    // 对外提供 doSomething 方法\n    exports.doSomething = function() {};\n\n});\n```\n\n但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n    // 模块代码...\n\n    // 直接通过 return 暴露接口\n    return {\n        foo: 'bar',\n        doSomething: function() {}\n    };\n\n});\n```\n\n\n\nSea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。\n\n\n\n## AMD vs CMD\n\n**虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：**\n\n1. 对于依赖的模块，AMD 是**提前执行**，CMD 是**懒执行**。（都是先加载）\n*  CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。\n\n看代码：\n\n```js\n// AMD 默认推荐\n\ndefine(['./a', './b'], function(a, b) {  // 依赖前置，提前执行\n\n    a.doSomething()\n    b.doSomething()\n\n})\n\n```\n\n```js\n// CMD\n\ndefine(function(require, exports, module) {\n\n    var a = require('./a')\n    a.doSomething()\n\n    var b = require('./b') // 依赖就近，延迟执行\n    b.doSomething()\n})\n```\n\n\n\n\n\n\n## WebPack\n\n> 后续文章,展开补充...\n\n","source":"_posts/javascript-module-loader.md","raw":"---\nlayout:     post\ntitle:      \"JS模块加载\"\nsubtitle:   \"CommonJS，RequireJS，SeaJS 归纳笔记\"\ndate:       2017-03-23 22:45:58\nauthor:     \"Damon\"\ncatalog:    true\nheader-img: \"post-bg-js-module.jpg\"\ntags:\n    - 前端开发\n    - JavaScript\n---\n\n\n\n## Foreword\n\n> Here comes Module!\n\n随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。\n\n于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。\n\n\n---\n\n## Catalog\n\n\n1.  [CommonJS & Node](#commonjs--node)\n3.  [History](#history)\n4.  [RequireJS & AMD](#requirejs--amd)\n5.  [SeaJS & CMD](#seajs--cmd)\n6.  [AMD vs CMD](#amd-vs-cmd)\n7.  [WebPack](#webpack)\n\n\n\n```\nfunction autoDetect(){\n    console.log('ye, it is written in JavaScript!')\n}\n```\n\n## CommonJS & Node\n\n> Javascript: not just for browsers any more! —— CommonJS Slogen\n\n前端模块化的事实标准之一，2009 年 8 月，[CommonJS](http://wiki.commonjs.org/wiki/CommonJS) 诞生。\n\nCommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。\n\n\n让我们看看 Node 中的实现：\n{% codeblock lang:js %}\n// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper\n// \"as though the module was wrapped in a function\"\n\nvar a = require('./a')  // 加载模块（同步加载）\na.doSomething()         // 等上一句执行完才会执行\n\nexports.b = function(){ // 暴露 b 函数接口\n  // do something\n}\n{% endcodeblock %}\n\n\n`exports`是一个内置对象，就像`require`是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写`module.exports`就可以了。\n\nCommonJS 前身叫 ServerJS ，**后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS** 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。\n\n\n因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：\n\n* 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）\n* 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。\n* 都在向着 **COMMON** 的方向进化：**兼容不同风格，兼容浏览器和服务器两种环境**\n\n本文接下来要讨论的典例是：\n\n* RequireJS & AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）\n* SeaJS & CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）\n\n\n\n\n\n## History\n\n<!--<h2 id=\"history\"> History </h2>-->\n\n> 此段落参考自玉伯的 [前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588)\n\n09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 [Modules/1.0](http://wiki.commonjs.org/wiki/Modules) 规范，并且在 Node.js 等环境下取得了很不错的实践。\n\n09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：\n\n\n1. **Modules/1.x** 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 [Modules/Transport](http://wiki.commonjs.org/wiki/Modules/Transport) 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。\n2. **Modules/Async** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 [AMD](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 规范及其实现 [RequireJS](http://requirejs.org/)。这个稍后再细说。\n3. **Modules/2.0** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了\n\n\n补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 `add`和`use` 两个源自于 YUI Modules 的函数名替换了 `define` 和 `require` ，但其原理更接近 RequireJS ，与 YUI Modules 的 `Y` 沙箱 Attach 机制并不相同\n\n\n## RequireJS & AMD\n\n[AMD (Async Module Definition)](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\n> RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments\n\nRequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：\n\n{% gist 65481dbbf6d16e831a6cc89c3e37e6e5 display-emails-from-database.php %}\n\n\n> As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?\n\n所以我们需要 **Function Wrapping** 来获取依赖并且提前通过 script tag 提前加载进来\n\n\n{% jsfiddle shorttag [tabs] [skin] [width] [height] %}\n\n\n当依赖模块非常多时，这种**依赖前置**的写法会显得有点奇怪，所以 AMD 给了一个语法糖， **simplified CommonJS wrapping**，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：\n\n```js\ndefine(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\nThe AMD loader will parse out the `require('')` calls by using `Function.prototype.toString()`, then internally convert the above define call into this:\n\n```js\ndefine(['require', 'dependency1', 'dependency2'], function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\n\n出于`Function.prototype.toString()`兼容性和性能的考虑，最好的做法还是做一次 **optimized build**\n\n\n\nAMD 和 CommonJS 的核心争议如下：\n\n### 1. **执行时机**\n\nModules/1.0:\n\n```js\nvar a = require(\"./a\") // 执行到此时，a.js 才同步下载并执行\n```\n\nAMD: （使用 require 的语法糖时）\n\n```js\ndefine([\"require\"],function(require)){\n    // 在这里，a.js 已经下载并且执行好了\n    // 使用 require() 并不是 AMD 的推荐写法\n    var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n})\n```\n\nAMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）\n\n但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。\n\n### 2. **书写风格**\n\nAMD 推荐的风格并不使用`require`，而是通过参数传入，破坏了**依赖就近**：\n\n```js\ndefine([\"a\", \"b\", \"c\"],function(a, b, c){\n    // 提前申明了并初始化了所有模块\n\n    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。\n})\n```\n\n不过，在笔者看来，风格喜好因人而异，主要还是**预执行**和**懒执行**的差异。\n\n另外，require 2.0 也开始思考异步处理**软依赖**（区别于一定需要的**硬依赖**）的问题，提出了这样的方案：\n\n```js\n// 函数体内：\nif(status){\n    async(['a'],function(a){\n        a.doSomething()\n    })\n}\n```\n\n## SeaJS & CMD\n\nCMD (Common Module Definition) 是 [SeaJS](http://seajs.org/docs/) 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。\n\n不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。\n\n* CMD Specification\n    * [English (CMDJS-repo)](https://github.com/cmdjs/specification/blob/master/draft/module.md)\n    * [Chinese (SeaJS-repo)](https://github.com/seajs/seajs/issues/242)\n\n\nCMD 主要有 define, factory, require, export 这么几个东西\n\n * define `define(id?, deps?, factory)`\n * factory `factory(require, exports, module)`\n * require `require(id)`\n * exports `Object`\n\n\nCMD 推荐的 Code Style 是使用 CommonJS 风格的 `require`：\n\n* 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已\n\n```js\ndefine(function(require, exports) {\n\n    // 获取模块 a 的接口\n    var a = require('./a');\n    // 调用模块 a 的方法\n    a.doSomething();\n\n    // 对外提供 foo 属性\n    exports.foo = 'bar';\n    // 对外提供 doSomething 方法\n    exports.doSomething = function() {};\n\n});\n```\n\n但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n    // 模块代码...\n\n    // 直接通过 return 暴露接口\n    return {\n        foo: 'bar',\n        doSomething: function() {}\n    };\n\n});\n```\n\n\n\nSea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。\n\n\n\n## AMD vs CMD\n\n**虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：**\n\n1. 对于依赖的模块，AMD 是**提前执行**，CMD 是**懒执行**。（都是先加载）\n*  CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。\n\n看代码：\n\n```js\n// AMD 默认推荐\n\ndefine(['./a', './b'], function(a, b) {  // 依赖前置，提前执行\n\n    a.doSomething()\n    b.doSomething()\n\n})\n\n```\n\n```js\n// CMD\n\ndefine(function(require, exports, module) {\n\n    var a = require('./a')\n    a.doSomething()\n\n    var b = require('./b') // 依赖就近，延迟执行\n    b.doSomething()\n})\n```\n\n\n\n\n\n\n## WebPack\n\n> 后续文章,展开补充...\n\n","slug":"javascript-module-loader","published":1,"updated":"2017-03-27T07:20:24.735Z","comments":1,"photos":[],"link":"","_id":"cj4qesf8o0006c4v53lqtoy1i","content":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><blockquote>\n<p>Here comes Module!</p>\n</blockquote>\n<p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p>\n<p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p>\n<hr>\n<h2 id=\"Catalog\"><a href=\"#Catalog\" class=\"headerlink\" title=\"Catalog\"></a>Catalog</h2><ol>\n<li><a href=\"#commonjs--node\">CommonJS &amp; Node</a></li>\n<li><a href=\"#history\">History</a></li>\n<li><a href=\"#requirejs--amd\">RequireJS &amp; AMD</a></li>\n<li><a href=\"#seajs--cmd\">SeaJS &amp; CMD</a></li>\n<li><a href=\"#amd-vs-cmd\">AMD vs CMD</a></li>\n<li><a href=\"#webpack\">WebPack</a></li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">autoDetect</span>()&#123;</div><div class=\"line\">    console.log('ye, it <span class=\"keyword\">is</span> written <span class=\"keyword\">in</span> JavaScript!')</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"CommonJS-amp-Node\"><a href=\"#CommonJS-amp-Node\" class=\"headerlink\" title=\"CommonJS &amp; Node\"></a>CommonJS &amp; Node</h2><blockquote>\n<p>Javascript: not just for browsers any more! —— CommonJS Slogen</p>\n</blockquote>\n<p>前端模块化的事实标准之一，2009 年 8 月，<a href=\"http://wiki.commonjs.org/wiki/CommonJS\" target=\"_blank\" rel=\"external\">CommonJS</a> 诞生。</p>\n<p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p>\n<p>让我们看看 Node 中的实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></div><div class=\"line\"><span class=\"comment\">// \"as though the module was wrapped in a function\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)  <span class=\"comment\">// 加载模块（同步加载）</span></div><div class=\"line\">a.doSomething()         <span class=\"comment\">// 等上一句执行完才会执行</span></div><div class=\"line\"></div><div class=\"line\">exports.b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 暴露 b 函数接口</span></div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p>\n<p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>\n<p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p>\n<ul>\n<li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li>\n<li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li>\n<li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li>\n</ul>\n<p>本文接下来要讨论的典例是：</p>\n<ul>\n<li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li>\n<li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li>\n</ul>\n<h2 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h2><!--<h2 id=\"history\"> History </h2>-->\n<blockquote>\n<p>此段落参考自玉伯的 <a href=\"https://github.com/seajs/seajs/issues/588\" target=\"_blank\" rel=\"external\">前端模块化开发那点历史</a></p>\n</blockquote>\n<p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href=\"http://wiki.commonjs.org/wiki/Modules\" target=\"_blank\" rel=\"external\">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p>\n<p>09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>\n<ol>\n<li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\" target=\"_blank\" rel=\"external\">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li>\n<li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD</a> 规范及其实现 <a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"external\">RequireJS</a>。这个稍后再细说。</li>\n<li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li>\n</ol>\n<p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p>\n<h2 id=\"RequireJS-amp-AMD\"><a href=\"#RequireJS-amp-AMD\" class=\"headerlink\" title=\"RequireJS &amp; AMD\"></a>RequireJS &amp; AMD</h2><p><a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<blockquote>\n<p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p>\n</blockquote>\n<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p>\n<script src=\"//gist.github.com/65481dbbf6d16e831a6cc89c3e37e6e5.js?file=display-emails-from-database.php\"></script>\n<blockquote>\n<p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>\n</blockquote>\n<p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p>\n<iframe scrolling=\"no\" width=\"[width]\" height=\"[height]\" src=\"http://jsfiddle.net/shorttag/embedded/[tabs]/[skin]\" frameborder=\"0\" allowfullscreen></iframe>\n<p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>The AMD loader will parse out the <code>require(&#39;&#39;)</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">'require'</span>, <span class=\"string\">'dependency1'</span>, <span class=\"string\">'dependency2'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p>\n<p>AMD 和 CommonJS 的核心争议如下：</p>\n<h3 id=\"1-执行时机\"><a href=\"#1-执行时机\" class=\"headerlink\" title=\"1. 执行时机\"></a>1. <strong>执行时机</strong></h3><p>Modules/1.0:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 执行到此时，a.js 才同步下载并执行</span></div></pre></td></tr></table></figure>\n<p>AMD: （使用 require 的语法糖时）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"require\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>))</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在这里，a.js 已经下载并且执行好了</span></div><div class=\"line\">    <span class=\"comment\">// 使用 require() 并不是 AMD 的推荐写法</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 此处仅仅是取模块 a 的 exports</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>\n<p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>\n<h3 id=\"2-书写风格\"><a href=\"#2-书写风格\" class=\"headerlink\" title=\"2. 书写风格\"></a>2. <strong>书写风格</strong></h3><p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 提前申明了并初始化了所有模块</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"literal\">true</span> || b.foo(); <span class=\"comment\">//即便根本没用到模块 b，但 b 还是提前执行了。</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p>\n<p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数体内：</span></div><div class=\"line\"><span class=\"keyword\">if</span>(status)&#123;</div><div class=\"line\">    <span class=\"keyword\">async</span>([<span class=\"string\">'a'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">        a.doSomething()</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"SeaJS-amp-CMD\"><a href=\"#SeaJS-amp-CMD\" class=\"headerlink\" title=\"SeaJS &amp; CMD\"></a>SeaJS &amp; CMD</h2><p>CMD (Common Module Definition) 是 <a href=\"http://seajs.org/docs/\" target=\"_blank\" rel=\"external\">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>\n<p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p>\n<ul>\n<li>CMD Specification<ul>\n<li><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\" target=\"_blank\" rel=\"external\">English (CMDJS-repo)</a></li>\n<li><a href=\"https://github.com/seajs/seajs/issues/242\" target=\"_blank\" rel=\"external\">Chinese (SeaJS-repo)</a></li>\n</ul>\n</li>\n</ul>\n<p>CMD 主要有 define, factory, require, export 这么几个东西</p>\n<ul>\n<li>define <code>define(id?, deps?, factory)</code></li>\n<li>factory <code>factory(require, exports, module)</code></li>\n<li>require <code>require(id)</code></li>\n<li>exports <code>Object</code></li>\n</ul>\n<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p>\n<ul>\n<li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 获取模块 a 的接口</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</div><div class=\"line\">    <span class=\"comment\">// 调用模块 a 的方法</span></div><div class=\"line\">    a.doSomething();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 对外提供 foo 属性</span></div><div class=\"line\">    exports.foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">    <span class=\"comment\">// 对外提供 doSomething 方法</span></div><div class=\"line\">    exports.doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"string\">'hello'</span>, [<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 模块代码...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 直接通过 return 暴露接口</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>,</div><div class=\"line\">        <span class=\"attr\">doSomething</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>\n<h2 id=\"AMD-vs-CMD\"><a href=\"#AMD-vs-CMD\" class=\"headerlink\" title=\"AMD vs CMD\"></a>AMD vs CMD</h2><p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p>\n<ol>\n<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li>\n</ol>\n<ul>\n<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</li>\n</ul>\n<p>看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></div><div class=\"line\"></div><div class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖前置，提前执行</span></div><div class=\"line\"></div><div class=\"line\">    a.doSomething()</div><div class=\"line\">    b.doSomething()</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CMD</span></div><div class=\"line\"></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</div><div class=\"line\">    a.doSomething()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖就近，延迟执行</span></div><div class=\"line\">    b.doSomething()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"WebPack\"><a href=\"#WebPack\" class=\"headerlink\" title=\"WebPack\"></a>WebPack</h2><blockquote>\n<p>后续文章,展开补充…</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><blockquote>\n<p>Here comes Module!</p>\n</blockquote>\n<p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p>\n<p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p>\n<hr>\n<h2 id=\"Catalog\"><a href=\"#Catalog\" class=\"headerlink\" title=\"Catalog\"></a>Catalog</h2><ol>\n<li><a href=\"#commonjs--node\">CommonJS &amp; Node</a></li>\n<li><a href=\"#history\">History</a></li>\n<li><a href=\"#requirejs--amd\">RequireJS &amp; AMD</a></li>\n<li><a href=\"#seajs--cmd\">SeaJS &amp; CMD</a></li>\n<li><a href=\"#amd-vs-cmd\">AMD vs CMD</a></li>\n<li><a href=\"#webpack\">WebPack</a></li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">autoDetect</span>()&#123;</div><div class=\"line\">    console.log('ye, it <span class=\"keyword\">is</span> written <span class=\"keyword\">in</span> JavaScript!')</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"CommonJS-amp-Node\"><a href=\"#CommonJS-amp-Node\" class=\"headerlink\" title=\"CommonJS &amp; Node\"></a>CommonJS &amp; Node</h2><blockquote>\n<p>Javascript: not just for browsers any more! —— CommonJS Slogen</p>\n</blockquote>\n<p>前端模块化的事实标准之一，2009 年 8 月，<a href=\"http://wiki.commonjs.org/wiki/CommonJS\">CommonJS</a> 诞生。</p>\n<p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p>\n<p>让我们看看 Node 中的实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></div><div class=\"line\"><span class=\"comment\">// \"as though the module was wrapped in a function\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)  <span class=\"comment\">// 加载模块（同步加载）</span></div><div class=\"line\">a.doSomething()         <span class=\"comment\">// 等上一句执行完才会执行</span></div><div class=\"line\"></div><div class=\"line\">exports.b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 暴露 b 函数接口</span></div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p>\n<p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>\n<p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p>\n<ul>\n<li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li>\n<li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li>\n<li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li>\n</ul>\n<p>本文接下来要讨论的典例是：</p>\n<ul>\n<li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li>\n<li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li>\n</ul>\n<h2 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h2><!--<h2 id=\"history\"> History </h2>-->\n<blockquote>\n<p>此段落参考自玉伯的 <a href=\"https://github.com/seajs/seajs/issues/588\">前端模块化开发那点历史</a></p>\n</blockquote>\n<p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href=\"http://wiki.commonjs.org/wiki/Modules\">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p>\n<p>09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>\n<ol>\n<li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li>\n<li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\">AMD</a> 规范及其实现 <a href=\"http://requirejs.org/\">RequireJS</a>。这个稍后再细说。</li>\n<li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li>\n</ol>\n<p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p>\n<h2 id=\"RequireJS-amp-AMD\"><a href=\"#RequireJS-amp-AMD\" class=\"headerlink\" title=\"RequireJS &amp; AMD\"></a>RequireJS &amp; AMD</h2><p><a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<blockquote>\n<p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p>\n</blockquote>\n<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p>\n<script src=\"//gist.github.com/65481dbbf6d16e831a6cc89c3e37e6e5.js?file=display-emails-from-database.php\"></script>\n<blockquote>\n<p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>\n</blockquote>\n<p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p>\n<iframe scrolling=\"no\" width=\"[width]\" height=\"[height]\" src=\"http://jsfiddle.net/shorttag/embedded/[tabs]/[skin]\" frameborder=\"0\" allowfullscreen></iframe>\n<p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>The AMD loader will parse out the <code>require(&#39;&#39;)</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">'require'</span>, <span class=\"string\">'dependency1'</span>, <span class=\"string\">'dependency2'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p>\n<p>AMD 和 CommonJS 的核心争议如下：</p>\n<h3 id=\"1-执行时机\"><a href=\"#1-执行时机\" class=\"headerlink\" title=\"1. 执行时机\"></a>1. <strong>执行时机</strong></h3><p>Modules/1.0:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 执行到此时，a.js 才同步下载并执行</span></div></pre></td></tr></table></figure>\n<p>AMD: （使用 require 的语法糖时）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"require\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>))</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在这里，a.js 已经下载并且执行好了</span></div><div class=\"line\">    <span class=\"comment\">// 使用 require() 并不是 AMD 的推荐写法</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 此处仅仅是取模块 a 的 exports</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>\n<p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>\n<h3 id=\"2-书写风格\"><a href=\"#2-书写风格\" class=\"headerlink\" title=\"2. 书写风格\"></a>2. <strong>书写风格</strong></h3><p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 提前申明了并初始化了所有模块</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"literal\">true</span> || b.foo(); <span class=\"comment\">//即便根本没用到模块 b，但 b 还是提前执行了。</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p>\n<p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数体内：</span></div><div class=\"line\"><span class=\"keyword\">if</span>(status)&#123;</div><div class=\"line\">    <span class=\"keyword\">async</span>([<span class=\"string\">'a'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">        a.doSomething()</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"SeaJS-amp-CMD\"><a href=\"#SeaJS-amp-CMD\" class=\"headerlink\" title=\"SeaJS &amp; CMD\"></a>SeaJS &amp; CMD</h2><p>CMD (Common Module Definition) 是 <a href=\"http://seajs.org/docs/\">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>\n<p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p>\n<ul>\n<li>CMD Specification<ul>\n<li><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\">English (CMDJS-repo)</a></li>\n<li><a href=\"https://github.com/seajs/seajs/issues/242\">Chinese (SeaJS-repo)</a></li>\n</ul>\n</li>\n</ul>\n<p>CMD 主要有 define, factory, require, export 这么几个东西</p>\n<ul>\n<li>define <code>define(id?, deps?, factory)</code></li>\n<li>factory <code>factory(require, exports, module)</code></li>\n<li>require <code>require(id)</code></li>\n<li>exports <code>Object</code></li>\n</ul>\n<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p>\n<ul>\n<li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 获取模块 a 的接口</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</div><div class=\"line\">    <span class=\"comment\">// 调用模块 a 的方法</span></div><div class=\"line\">    a.doSomething();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 对外提供 foo 属性</span></div><div class=\"line\">    exports.foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">    <span class=\"comment\">// 对外提供 doSomething 方法</span></div><div class=\"line\">    exports.doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"string\">'hello'</span>, [<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 模块代码...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 直接通过 return 暴露接口</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>,</div><div class=\"line\">        <span class=\"attr\">doSomething</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>\n<h2 id=\"AMD-vs-CMD\"><a href=\"#AMD-vs-CMD\" class=\"headerlink\" title=\"AMD vs CMD\"></a>AMD vs CMD</h2><p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p>\n<ol>\n<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li>\n</ol>\n<ul>\n<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</li>\n</ul>\n<p>看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></div><div class=\"line\"></div><div class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖前置，提前执行</span></div><div class=\"line\"></div><div class=\"line\">    a.doSomething()</div><div class=\"line\">    b.doSomething()</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CMD</span></div><div class=\"line\"></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</div><div class=\"line\">    a.doSomething()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖就近，延迟执行</span></div><div class=\"line\">    b.doSomething()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"WebPack\"><a href=\"#WebPack\" class=\"headerlink\" title=\"WebPack\"></a>WebPack</h2><blockquote>\n<p>后续文章,展开补充…</p>\n</blockquote>\n"},{"title":"实现链式调用LazyMan","subtitle":"原型链 链式调用实现","author":"Damon","header-img":"post-bg-js-version.jpg","date":"2017-04-09T01:43:13.000Z","_content":"\n## 前言\n\n昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。\n\n---\n\n## 题目\n\n实现下面的函数:\n\n```\nLazyMan(“Hank”)\n//Hi! This is Hank!\n\nLazyMan(“Hank”).sleep(10).eat(“dinner”)\n// Hi! This is Hank!\n// 等待10秒..\n// Wake up after 10\n// Eat dinner~\n\nLazyMan(“Hank”).eat(“dinner”).eat(“supper”)\n// Hi This is Hank!\n// Eat dinner~\n// Eat supper~\n\nLazyMan(“Hank”).sleepFirst(5).eat(“supper”)\n// 等待5秒\n// Wake up after 5\n// Hi This is Hank!\n// Eat supper\n\n```\n\n这道题看起来很简单,不就是jquery经常使用的链式调用吗?\n但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.\n\n## 代码实现\n\n废话不多说直接上代码:\n\n```\nfunction _LazyMan(man) {\n    var self = this;\n    // 任务队列\n    self.task = [];\n    var fn = function () {\n        console.log('I am ' + man);\n        self.next();\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n\n    // 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务\n    setTimeout(function () {\n        self.next();\n    }, 0)\n\n    return self;\n}\n\n_LazyMan.prototype.firstSleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾开头加入一个任务\n    self.task.unshift(fn);\n\n    return self;\n}\n\n_LazyMan.prototype.sleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n_LazyMan.prototype.eat = function (food) {\n    var self = this;\n\n    var fn = function () {\n        console.log('eat ' + food);\n\n        self.next();\n    }\n\n    // 向队列尾加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n// next实现\n_LazyMan.prototype.next = function () {\n    // 删除队列的第一位元素\n    var runFunc = this.task.shift();\n\n    // 如果renFunc 不是undefined,那么执行runFunc\n    runFunc && runFunc();\n\n}\n\nfunction LazyMan(man) {\n    return new _LazyMan(man);\n}\n\nLazyMan('Hank').firstSleep(1).sleep(2).eat('egg');\n\n/* 运行结果 */\n// Wake up after 1 s!\n//     I am Hank\n// Wake up after 2 s!\n//     eat egg\n\n```\n## 总结\n\n实现要点:\n1. 在实例上创建一个任务队列数组(先进先出).\n2. 实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.\n3. 在实例化LazyMan的时候,使用setTimeout执行第一次next方法.\n\n* 注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，\nsetTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/实现链式LazyMan.md","raw":"---\ntitle: 实现链式调用LazyMan\nsubtitle: \"原型链 链式调用实现\"\nauthor: \"Damon\"\nheader-img: \"post-bg-js-version.jpg\"\ndate: 2017-04-09 09:43:13\ntags:\n    - JS\n    - 前端面试\n---\n\n## 前言\n\n昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。\n\n---\n\n## 题目\n\n实现下面的函数:\n\n```\nLazyMan(“Hank”)\n//Hi! This is Hank!\n\nLazyMan(“Hank”).sleep(10).eat(“dinner”)\n// Hi! This is Hank!\n// 等待10秒..\n// Wake up after 10\n// Eat dinner~\n\nLazyMan(“Hank”).eat(“dinner”).eat(“supper”)\n// Hi This is Hank!\n// Eat dinner~\n// Eat supper~\n\nLazyMan(“Hank”).sleepFirst(5).eat(“supper”)\n// 等待5秒\n// Wake up after 5\n// Hi This is Hank!\n// Eat supper\n\n```\n\n这道题看起来很简单,不就是jquery经常使用的链式调用吗?\n但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.\n\n## 代码实现\n\n废话不多说直接上代码:\n\n```\nfunction _LazyMan(man) {\n    var self = this;\n    // 任务队列\n    self.task = [];\n    var fn = function () {\n        console.log('I am ' + man);\n        self.next();\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n\n    // 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务\n    setTimeout(function () {\n        self.next();\n    }, 0)\n\n    return self;\n}\n\n_LazyMan.prototype.firstSleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾开头加入一个任务\n    self.task.unshift(fn);\n\n    return self;\n}\n\n_LazyMan.prototype.sleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n_LazyMan.prototype.eat = function (food) {\n    var self = this;\n\n    var fn = function () {\n        console.log('eat ' + food);\n\n        self.next();\n    }\n\n    // 向队列尾加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n// next实现\n_LazyMan.prototype.next = function () {\n    // 删除队列的第一位元素\n    var runFunc = this.task.shift();\n\n    // 如果renFunc 不是undefined,那么执行runFunc\n    runFunc && runFunc();\n\n}\n\nfunction LazyMan(man) {\n    return new _LazyMan(man);\n}\n\nLazyMan('Hank').firstSleep(1).sleep(2).eat('egg');\n\n/* 运行结果 */\n// Wake up after 1 s!\n//     I am Hank\n// Wake up after 2 s!\n//     eat egg\n\n```\n## 总结\n\n实现要点:\n1. 在实例上创建一个任务队列数组(先进先出).\n2. 实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.\n3. 在实例化LazyMan的时候,使用setTimeout执行第一次next方法.\n\n* 注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，\nsetTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"实现链式LazyMan","published":1,"updated":"2017-06-16T05:37:16.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4qesf8o0008c4v5fsxgaf5o","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。</p>\n<hr>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>实现下面的函数:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span></div><div class=\"line\"><span class=\"comment\">//Hi! This is Hank!</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleep(<span class=\"number\">10</span>).eat(“dinner”)</div><div class=\"line\"><span class=\"comment\">// Hi! This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// 等待10秒..</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 10</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.eat(“dinner”).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"><span class=\"comment\">// Eat supper~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleepFirst(<span class=\"number\">5</span>).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// 等待5秒</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 5</span></div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat supper</span></div></pre></td></tr></table></figure>\n<p>这道题看起来很简单,不就是jquery经常使用的链式调用吗?<br>但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>废话不多说直接上代码:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\">    <span class=\"comment\">// 任务队列</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task = [];</div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'I am '</span> + man);</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务</span></div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;, <span class=\"number\">0</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.firstSleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾开头加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.unshift(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.sleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(food)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'eat '</span> + food);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// next实现</span></div><div class=\"line\">_LazyMan.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 删除队列的第一位元素</span></div><div class=\"line\">    <span class=\"keyword\">var</span> runFunc = this.task.shift();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果renFunc 不是undefined,那么执行runFunc</span></div><div class=\"line\">    runFunc &amp;&amp; runFunc();</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(man);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">LazyMan(<span class=\"string\">'Hank'</span>).firstSleep(<span class=\"number\">1</span>).sleep(<span class=\"number\">2</span>).eat(<span class=\"string\">'egg'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 运行结果 */</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 1 s!</span></div><div class=\"line\"><span class=\"comment\">//     I am Hank</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 2 s!</span></div><div class=\"line\"><span class=\"comment\">//     eat egg</span></div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实现要点:</p>\n<ol>\n<li>在实例上创建一个任务队列数组(先进先出).</li>\n<li>实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.</li>\n<li>在实例化LazyMan的时候,使用setTimeout执行第一次next方法.</li>\n</ol>\n<ul>\n<li>注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，<br>setTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。</p>\n<hr>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>实现下面的函数:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span></div><div class=\"line\"><span class=\"comment\">//Hi! This is Hank!</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleep(<span class=\"number\">10</span>).eat(“dinner”)</div><div class=\"line\"><span class=\"comment\">// Hi! This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// 等待10秒..</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 10</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.eat(“dinner”).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"><span class=\"comment\">// Eat supper~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleepFirst(<span class=\"number\">5</span>).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// 等待5秒</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 5</span></div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat supper</span></div></pre></td></tr></table></figure>\n<p>这道题看起来很简单,不就是jquery经常使用的链式调用吗?<br>但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>废话不多说直接上代码:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\">    <span class=\"comment\">// 任务队列</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task = [];</div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'I am '</span> + man);</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务</span></div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;, <span class=\"number\">0</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.firstSleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾开头加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.unshift(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.sleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(food)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'eat '</span> + food);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// next实现</span></div><div class=\"line\">_LazyMan.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 删除队列的第一位元素</span></div><div class=\"line\">    <span class=\"keyword\">var</span> runFunc = this.task.shift();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果renFunc 不是undefined,那么执行runFunc</span></div><div class=\"line\">    runFunc &amp;&amp; runFunc();</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(man);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">LazyMan(<span class=\"string\">'Hank'</span>).firstSleep(<span class=\"number\">1</span>).sleep(<span class=\"number\">2</span>).eat(<span class=\"string\">'egg'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 运行结果 */</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 1 s!</span></div><div class=\"line\"><span class=\"comment\">//     I am Hank</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 2 s!</span></div><div class=\"line\"><span class=\"comment\">//     eat egg</span></div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实现要点:</p>\n<ol>\n<li>在实例上创建一个任务队列数组(先进先出).</li>\n<li>实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.</li>\n<li>在实例化LazyMan的时候,使用setTimeout执行第一次next方法.</li>\n</ol>\n<ul>\n<li>注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，<br>setTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。</li>\n</ul>\n"},{"title":"徒手解析URL参数","subtitle":"手写代码","date":"2017-06-19T06:19:00.000Z","author":"Damon","header-img":"/img/about-bg.jpg","_content":"\n\n## 题目\n\n不借助第三方库的条件下，用 JS 编写函数从下面的 URL 串中解析出所有的参数：\n\n```\nhttp://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&d&enabled\n```\n期望的返回结果格式如下：\n```\n{\n  user: 'anonymous',\n  id: [123, 456],     // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型\n  city: '北京',        // 中文\n  enabled: true,      // 未指定值的 key 约定值为 true\n}\n```\n## 代码实现\n\n```\nvar URL = 'http://www.domain.com/?user=anonymous&id=0&id=456&city=%E5%8C%97%E4%BA%AC&d&enabled'\n\nfunction getURLParams (url) {\n  if (url && typeof url !== 'string') {\n    return {}\n  }\n\n  // 如果没传URL,默认解析浏览器当前URL\n  let URL = url || window.location.href\n  let searchOfURL = URL.split('?')[1] || null\n\n  //如果没有查询参数,那么直接返回\n  if (!searchOfURL) {\n    return {}\n  }\n\n  // 处理查询参数\n  let params = decodeURIComponent(searchOfURL).split('&').map(item => {\n    let param = item.split('='),\n        key   = param[0],\n        value = param[1] || true;\n\n    if (typeof value === 'string' && !isNaN(Number(value))) {\n      value = Number(value)\n    }\n\n    return { key, value }\n\n  }).reduce((params, item) => {\n    const { key, value } = item\n\n    // 判断key是否存在, 注意:不能使用 if (!params[key]) ,因为可能出现值为 0 的情况\n    if ( typeof params[key] === 'undefined') {\n      params[key] = value\n    } else {\n      // 存在key,那么把相同value放数组内\n      params[key] = Array.isArray(params[key]) ? params[key].concat(value) : [].concat(params[key], value)\n    }\n\n    return params\n  }, {})\n\n  return params\n}\n\nconsole.log(getURLParams(URL))\n\n// 运行结果\n// { user: 'anonymous',\n//   id: [ 0, 456 ],\n//   city: '北京',\n//   d: true,\n//   enabled: true }\n```","source":"_posts/徒手解析URL参数.md","raw":"---\ntitle: 徒手解析URL参数\nsubtitle: \"手写代码\"\ndate: 2017-06-19 14:19:00\nauthor: \"Damon\"\nheader-img: \"/img/about-bg.jpg\"\ntags:\n    - JS\n    - 前端面试\n---\n\n\n## 题目\n\n不借助第三方库的条件下，用 JS 编写函数从下面的 URL 串中解析出所有的参数：\n\n```\nhttp://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&d&enabled\n```\n期望的返回结果格式如下：\n```\n{\n  user: 'anonymous',\n  id: [123, 456],     // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型\n  city: '北京',        // 中文\n  enabled: true,      // 未指定值的 key 约定值为 true\n}\n```\n## 代码实现\n\n```\nvar URL = 'http://www.domain.com/?user=anonymous&id=0&id=456&city=%E5%8C%97%E4%BA%AC&d&enabled'\n\nfunction getURLParams (url) {\n  if (url && typeof url !== 'string') {\n    return {}\n  }\n\n  // 如果没传URL,默认解析浏览器当前URL\n  let URL = url || window.location.href\n  let searchOfURL = URL.split('?')[1] || null\n\n  //如果没有查询参数,那么直接返回\n  if (!searchOfURL) {\n    return {}\n  }\n\n  // 处理查询参数\n  let params = decodeURIComponent(searchOfURL).split('&').map(item => {\n    let param = item.split('='),\n        key   = param[0],\n        value = param[1] || true;\n\n    if (typeof value === 'string' && !isNaN(Number(value))) {\n      value = Number(value)\n    }\n\n    return { key, value }\n\n  }).reduce((params, item) => {\n    const { key, value } = item\n\n    // 判断key是否存在, 注意:不能使用 if (!params[key]) ,因为可能出现值为 0 的情况\n    if ( typeof params[key] === 'undefined') {\n      params[key] = value\n    } else {\n      // 存在key,那么把相同value放数组内\n      params[key] = Array.isArray(params[key]) ? params[key].concat(value) : [].concat(params[key], value)\n    }\n\n    return params\n  }, {})\n\n  return params\n}\n\nconsole.log(getURLParams(URL))\n\n// 运行结果\n// { user: 'anonymous',\n//   id: [ 0, 456 ],\n//   city: '北京',\n//   d: true,\n//   enabled: true }\n```","slug":"徒手解析URL参数","published":1,"updated":"2017-06-22T06:22:24.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4qesf8o0009c4v5n4i1ytcd","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>不借助第三方库的条件下，用 JS 编写函数从下面的 URL 串中解析出所有的参数：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://www.domain.com/?user=anonymous&amp;id=<span class=\"number\">123</span>&amp;id=<span class=\"number\">456</span>&amp;city=<span class=\"symbol\">%E5</span><span class=\"symbol\">%8</span>C<span class=\"symbol\">%97</span><span class=\"symbol\">%E4</span><span class=\"symbol\">%BA</span><span class=\"symbol\">%AC</span>&amp;d&amp;enabled</div></pre></td></tr></table></figure>\n<p>期望的返回结果格式如下：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attribute\">user</span>: <span class=\"string\">'anonymous'</span>,</div><div class=\"line\">  <span class=\"attribute\">id</span>: [<span class=\"number\">123</span>, <span class=\"number\">456</span>],     <span class=\"comment\">// 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></div><div class=\"line\">  <span class=\"attribute\">city</span>: <span class=\"string\">'北京'</span>,        <span class=\"comment\">// 中文</span></div><div class=\"line\">  <span class=\"attribute\">enabled</span>: true,      <span class=\"comment\">// 未指定值的 key 约定值为 true</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> URL = <span class=\"string\">'http://www.domain.com/?user=anonymous&amp;id=0&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">function <span class=\"title\">getURLParams</span> (<span class=\"params\">url</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (url &amp;&amp; <span class=\"keyword\">typeof</span> url !== <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 如果没传URL,默认解析浏览器当前URL</span></div><div class=\"line\">  <span class=\"keyword\">let</span> URL = url || window.location.href</div><div class=\"line\">  <span class=\"keyword\">let</span> searchOfURL = URL.split(<span class=\"string\">'?'</span>)[<span class=\"number\">1</span>] || <span class=\"literal\">null</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//如果没有查询参数,那么直接返回</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!searchOfURL) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 处理查询参数</span></div><div class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">params</span> = decodeURIComponent(searchOfURL).split(<span class=\"string\">'&amp;'</span>).map(item =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> param = item.split(<span class=\"string\">'='</span>),</div><div class=\"line\">        key   = param[<span class=\"number\">0</span>],</div><div class=\"line\">        <span class=\"keyword\">value</span> = param[<span class=\"number\">1</span>] || <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">value</span> === <span class=\"string\">'string'</span> &amp;&amp; !isNaN(Number(<span class=\"keyword\">value</span>))) &#123;</div><div class=\"line\">      <span class=\"keyword\">value</span> = Number(<span class=\"keyword\">value</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123; key, <span class=\"keyword\">value</span> &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;).reduce((<span class=\"keyword\">params</span>, item) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> &#123; key, <span class=\"keyword\">value</span> &#125; = item</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 判断key是否存在, 注意:不能使用 if (!params[key]) ,因为可能出现值为 0 的情况</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> <span class=\"keyword\">params</span>[key] === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">params</span>[key] = <span class=\"keyword\">value</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 存在key,那么把相同value放数组内</span></div><div class=\"line\">      <span class=\"keyword\">params</span>[key] = Array.isArray(<span class=\"keyword\">params</span>[key]) ? <span class=\"keyword\">params</span>[key].concat(<span class=\"keyword\">value</span>) : [].concat(<span class=\"keyword\">params</span>[key], <span class=\"keyword\">value</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">params</span></div><div class=\"line\">  &#125;, &#123;&#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">params</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(getURLParams(URL))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 运行结果</span></div><div class=\"line\"><span class=\"comment\">// &#123; user: 'anonymous',</span></div><div class=\"line\"><span class=\"comment\">//   id: [ 0, 456 ],</span></div><div class=\"line\"><span class=\"comment\">//   city: '北京',</span></div><div class=\"line\"><span class=\"comment\">//   d: true,</span></div><div class=\"line\"><span class=\"comment\">//   enabled: true &#125;</span></div></pre></td></tr></table></figure>","excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>不借助第三方库的条件下，用 JS 编写函数从下面的 URL 串中解析出所有的参数：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://www.domain.com/?user=anonymous&amp;id=<span class=\"number\">123</span>&amp;id=<span class=\"number\">456</span>&amp;city=<span class=\"symbol\">%E5</span><span class=\"symbol\">%8</span>C<span class=\"symbol\">%97</span><span class=\"symbol\">%E4</span><span class=\"symbol\">%BA</span><span class=\"symbol\">%AC</span>&amp;d&amp;enabled</div></pre></td></tr></table></figure>\n<p>期望的返回结果格式如下：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attribute\">user</span>: <span class=\"string\">'anonymous'</span>,</div><div class=\"line\">  <span class=\"attribute\">id</span>: [<span class=\"number\">123</span>, <span class=\"number\">456</span>],     <span class=\"comment\">// 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></div><div class=\"line\">  <span class=\"attribute\">city</span>: <span class=\"string\">'北京'</span>,        <span class=\"comment\">// 中文</span></div><div class=\"line\">  <span class=\"attribute\">enabled</span>: true,      <span class=\"comment\">// 未指定值的 key 约定值为 true</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> URL = <span class=\"string\">'http://www.domain.com/?user=anonymous&amp;id=0&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">function <span class=\"title\">getURLParams</span> (<span class=\"params\">url</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (url &amp;&amp; <span class=\"keyword\">typeof</span> url !== <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 如果没传URL,默认解析浏览器当前URL</span></div><div class=\"line\">  <span class=\"keyword\">let</span> URL = url || window.location.href</div><div class=\"line\">  <span class=\"keyword\">let</span> searchOfURL = URL.split(<span class=\"string\">'?'</span>)[<span class=\"number\">1</span>] || <span class=\"literal\">null</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//如果没有查询参数,那么直接返回</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!searchOfURL) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 处理查询参数</span></div><div class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">params</span> = decodeURIComponent(searchOfURL).split(<span class=\"string\">'&amp;'</span>).map(item =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> param = item.split(<span class=\"string\">'='</span>),</div><div class=\"line\">        key   = param[<span class=\"number\">0</span>],</div><div class=\"line\">        <span class=\"keyword\">value</span> = param[<span class=\"number\">1</span>] || <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">value</span> === <span class=\"string\">'string'</span> &amp;&amp; !isNaN(Number(<span class=\"keyword\">value</span>))) &#123;</div><div class=\"line\">      <span class=\"keyword\">value</span> = Number(<span class=\"keyword\">value</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123; key, <span class=\"keyword\">value</span> &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;).reduce((<span class=\"keyword\">params</span>, item) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> &#123; key, <span class=\"keyword\">value</span> &#125; = item</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 判断key是否存在, 注意:不能使用 if (!params[key]) ,因为可能出现值为 0 的情况</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> <span class=\"keyword\">params</span>[key] === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">params</span>[key] = <span class=\"keyword\">value</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 存在key,那么把相同value放数组内</span></div><div class=\"line\">      <span class=\"keyword\">params</span>[key] = Array.isArray(<span class=\"keyword\">params</span>[key]) ? <span class=\"keyword\">params</span>[key].concat(<span class=\"keyword\">value</span>) : [].concat(<span class=\"keyword\">params</span>[key], <span class=\"keyword\">value</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">params</span></div><div class=\"line\">  &#125;, &#123;&#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">params</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(getURLParams(URL))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 运行结果</span></div><div class=\"line\"><span class=\"comment\">// &#123; user: 'anonymous',</span></div><div class=\"line\"><span class=\"comment\">//   id: [ 0, 456 ],</span></div><div class=\"line\"><span class=\"comment\">//   city: '北京',</span></div><div class=\"line\"><span class=\"comment\">//   d: true,</span></div><div class=\"line\"><span class=\"comment\">//   enabled: true &#125;</span></div></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/JS实现快速排序/post-bg-js-version.jpg","post":"cj4qesf890001c4v5un29tm6o","slug":"post-bg-js-version.jpg","modified":1,"renderable":1},{"_id":"source/_posts/hello-blog/post-bg-unix-linux.jpg","post":"cj4qesf8o0005c4v5jedxxvfo","slug":"post-bg-unix-linux.jpg","modified":1,"renderable":1},{"_id":"source/_posts/javascript-module-loader/post-bg-js-module.jpg","post":"cj4qesf8o0006c4v53lqtoy1i","slug":"post-bg-js-module.jpg","modified":1,"renderable":1},{"_id":"source/_posts/实现链式LazyMan/post-bg-js-version.jpg","post":"cj4qesf8o0008c4v5fsxgaf5o","slug":"post-bg-js-version.jpg","modified":1,"renderable":1},{"_id":"source/_posts/about-javascript/javascript-java.jpg","post":"cj4qesf890004c4v5sca3snr1","slug":"javascript-java.jpg","modified":1,"renderable":1},{"_id":"source/_posts/about-javascript/keep-calm-and-learn-javascript.png","post":"cj4qesf890004c4v5sca3snr1","slug":"keep-calm-and-learn-javascript.png","modified":1,"renderable":1},{"_id":"source/_posts/about-javascript/post-bg-js-version.jpg","post":"cj4qesf890004c4v5sca3snr1","slug":"post-bg-js-version.jpg","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cj4qesf8o0008c4v5fsxgaf5o","tag_id":"cj4qesf890003c4v5wn458q03","_id":"cj4qesf8o000bc4v5isoeypjg"},{"post_id":"cj4qesf8o0008c4v5fsxgaf5o","tag_id":"cj4qesf8o0007c4v5786h6tq4","_id":"cj4qesf8o000cc4v55buctt84"},{"post_id":"cj4qesf890001c4v5un29tm6o","tag_id":"cj4qesf890003c4v5wn458q03","_id":"cj4qesf8o000ec4v5sdlzp0jd"},{"post_id":"cj4qesf890001c4v5un29tm6o","tag_id":"cj4qesf8o0007c4v5786h6tq4","_id":"cj4qesf8o000fc4v50eyssppq"},{"post_id":"cj4qesf8o0009c4v5n4i1ytcd","tag_id":"cj4qesf890003c4v5wn458q03","_id":"cj4qesf8o000hc4v5hile40mm"},{"post_id":"cj4qesf8o0009c4v5n4i1ytcd","tag_id":"cj4qesf8o0007c4v5786h6tq4","_id":"cj4qesf8o000ic4v5zp898nd8"},{"post_id":"cj4qesf890002c4v59sygijgi","tag_id":"cj4qesf890003c4v5wn458q03","_id":"cj4qesf8o000kc4v5zi0wtzoi"},{"post_id":"cj4qesf890002c4v59sygijgi","tag_id":"cj4qesf8o0007c4v5786h6tq4","_id":"cj4qesf8o000lc4v5p408t2uq"},{"post_id":"cj4qesf890004c4v5sca3snr1","tag_id":"cj4qesf8o000gc4v55u32l0o0","_id":"cj4qesf8o000nc4v5ek36o0uu"},{"post_id":"cj4qesf890004c4v5sca3snr1","tag_id":"cj4qesf8o000jc4v5bezlxucb","_id":"cj4qesf8o000oc4v5hu0flk7a"},{"post_id":"cj4qesf8o0005c4v5jedxxvfo","tag_id":"cj4qesf8o000mc4v50mf06imd","_id":"cj4qesf8o000qc4v58qjace3a"},{"post_id":"cj4qesf8o0006c4v53lqtoy1i","tag_id":"cj4qesf8o000pc4v5gaqts615","_id":"cj4qesf8o000sc4v5p43h0jvo"},{"post_id":"cj4qesf8o0006c4v53lqtoy1i","tag_id":"cj4qesf8o000gc4v55u32l0o0","_id":"cj4qesf94000tc4v5mb0f76d1"}],"Tag":[{"name":"JS","_id":"cj4qesf890003c4v5wn458q03"},{"name":"前端面试","_id":"cj4qesf8o0007c4v5786h6tq4"},{"name":"JavaScript","_id":"cj4qesf8o000gc4v55u32l0o0"},{"name":"翻译","_id":"cj4qesf8o000jc4v5bezlxucb"},{"name":"生活","_id":"cj4qesf8o000mc4v50mf06imd"},{"name":"前端开发","_id":"cj4qesf8o000pc4v5gaqts615"}]}}
{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/tag-bg.jpg","path":"img/tag-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/home-bg-o.jpg","path":"img/home-bg-o.jpg","modified":0,"renderable":0},{"_id":"themes/huxblog/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.css","path":"css/hux-blog.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":0,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/huxblog/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505210766000},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1505210766000},{"_id":"source/CNAME","hash":"380684ab67adbffcd99a9d75ce51da32425c84b6","modified":1505210766000},{"_id":"themes/huxblog/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1505210766000},{"_id":"themes/huxblog/_config.yml","hash":"5d235aa7716657282795ee86d9c9db2374197a66","modified":1505210766000},{"_id":"source/_posts/ImagePreview组件.md","hash":"249fc5543988bf13030e204a47cb538925d8b8f9","modified":1508230402000},{"_id":"source/_posts/JS实现快速排序.md","hash":"d916c825649f54a315ff15ae4aa581d320dca85e","modified":1505210766000},{"_id":"source/_posts/JS深复制与浅复制.md","hash":"1f016557721d6599cc7e15d42cad291d001b3162","modified":1505210766000},{"_id":"source/_posts/about-javascript.md","hash":"e57831d48803b12c3a23dec87b315352c3663e2c","modified":1505210766000},{"_id":"source/_posts/hello-blog.md","hash":"279d03c3bf765aac1de8b252706c20bd65864ad2","modified":1505210766000},{"_id":"source/_posts/javascript-module-loader.md","hash":"742412a9343df685e8ca3e97b7f7009b1d09a650","modified":1505210766000},{"_id":"source/_posts/函数的节流和去抖.md","hash":"8117755393dc191097d6c80a66cff6c2b8aa9038","modified":1505210766000},{"_id":"source/_posts/实现链式LazyMan.md","hash":"5c5da7054d0e7712e7562a054e2cd7dcf5f95c59","modified":1505210766000},{"_id":"source/_posts/徒手解析URL参数.md","hash":"daadb171e58a1c20b94a858bb193a932f2ea967e","modified":1505210766000},{"_id":"source/_posts/时间格式化工具函数.md","hash":"63c9a6d69c0b8a553c02ee660d92355e9ac654c3","modified":1505210766000},{"_id":"source/_posts/缓存机制.md","hash":"840e82b48a13eb7a1a08a0ee3c9074bc23469dc0","modified":1505210766000},{"_id":"source/about/index.md","hash":"aa4733242a6e764df25149ea0b72ffbaad0be946","modified":1505210766000},{"_id":"source/archives/index.md","hash":"754d367e509ce8e550abab63b450302a78cce7ef","modified":1505210766000},{"_id":"source/img/avatar.jpg","hash":"49cfa597392c4a116584c07690efbbc06354acc7","modified":1505210766000},{"_id":"source/img/favicon.ico","hash":"a8ee7712f6560180efccb68546de6ea0d937fff3","modified":1505210766000},{"_id":"source/img/icon_wechat.png","hash":"7fdb00c9017236e05c1b3e6da38a2cc382fd69fa","modified":1505210766000},{"_id":"source/tags/index.md","hash":"0bc541f4c6a0f21bec67b6717ee86226f0eddf39","modified":1505210766000},{"_id":"themes/huxblog/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1505210766000},{"_id":"themes/huxblog/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1505210766000},{"_id":"themes/huxblog/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1505210766000},{"_id":"themes/huxblog/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1505210766000},{"_id":"themes/huxblog/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1505210766000},{"_id":"themes/huxblog/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1505210766000},{"_id":"themes/huxblog/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1505210766000},{"_id":"themes/huxblog/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1505210766000},{"_id":"themes/huxblog/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1505210766000},{"_id":"themes/huxblog/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1505210766000},{"_id":"themes/huxblog/layout/about.ejs","hash":"7f56c71383ef6c156b56d79b3984e07cc466606a","modified":1505210766000},{"_id":"themes/huxblog/layout/archive.ejs","hash":"6c3ed5d914379319efe835a4aa505abbc616c328","modified":1505210766000},{"_id":"themes/huxblog/layout/archives.ejs","hash":"f0046e58cc1dd876133be2bf927aed2b1821cb3e","modified":1505210766000},{"_id":"themes/huxblog/layout/index.ejs","hash":"70ac58c46625300a70791e210daf446afa6d1cd4","modified":1505210766000},{"_id":"themes/huxblog/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1505210766000},{"_id":"themes/huxblog/layout/layout.ejs","hash":"03e278a3b8bc4503183276b6130ac04a8d5b9865","modified":1505210766000},{"_id":"themes/huxblog/layout/page.ejs","hash":"3fde0787e883274563f9de5aaeb8130b667e132a","modified":1505210766000},{"_id":"themes/huxblog/layout/post.ejs","hash":"fd68124c3de2bbe7d870cecadcf684df7cf82519","modified":1505210766000},{"_id":"themes/huxblog/layout/tags.ejs","hash":"a51bf2828af20939d702de1fdae067439a1153c0","modified":1505210766000},{"_id":"source/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1505210766000},{"_id":"source/_posts/JS实现快速排序/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1505210766000},{"_id":"source/_posts/about-javascript/keep-calm-and-learn-javascript.png","hash":"49ea101b92ce5e136a19e6b11162f8f4126fe01f","modified":1505210766000},{"_id":"source/_posts/about-javascript/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1505210766000},{"_id":"source/_posts/实现链式LazyMan/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1505210766000},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1505210766000},{"_id":"source/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1505210766000},{"_id":"themes/huxblog/layout/_partial/footer.ejs","hash":"7becd47f8ad35569ce847286a527f88d2c95ef4a","modified":1511708708244},{"_id":"themes/huxblog/layout/_partial/head.ejs","hash":"7ae6c93a1a7ea3e3dbbf9f06793090b8a86c727b","modified":1511707567000},{"_id":"themes/huxblog/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1505210766000},{"_id":"themes/huxblog/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1505210766000},{"_id":"themes/huxblog/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1505210766000},{"_id":"themes/huxblog/source/css/hux-blog.css","hash":"c1b0a32ad8075ac09d99fb4d64a9fbc84163abf8","modified":1505210766000},{"_id":"themes/huxblog/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1505210766000},{"_id":"themes/huxblog/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1505210766000},{"_id":"themes/huxblog/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1505210766000},{"_id":"themes/huxblog/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1505210766000},{"_id":"themes/huxblog/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1505210766000},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1505210766000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1505210766000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1505210766000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1505210766000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1505210766000},{"_id":"source/_posts/about-javascript/javascript-java.jpg","hash":"881e35e241a8be40f3c4e3a6f57d5402247c1eb3","modified":1505210766000},{"_id":"source/_posts/hello-blog/post-bg-unix-linux.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1505210766000},{"_id":"source/_posts/javascript-module-loader/post-bg-js-module.jpg","hash":"4a43bfa6b69c79a6ef90bd852fe5756d241733cd","modified":1505210766000},{"_id":"source/img/home-bg.jpg","hash":"a191201c3a98728e6ea66d6827df827ecfcc9d33","modified":1505210766000},{"_id":"themes/huxblog/source/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1505210766000},{"_id":"themes/huxblog/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1505210766000},{"_id":"themes/huxblog/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1505210766000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1505210766000},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1505210766000},{"_id":"themes/huxblog/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1505210766000},{"_id":"themes/huxblog/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1505210766000},{"_id":"source/img/about-bg.jpg","hash":"b5814b2d10eb38dfda0072365567f3823bc34aba","modified":1505210766000},{"_id":"public/404.html","hash":"4c3c715f1452096a94891fde909a5d2ba4ae9d87","modified":1511708716221},{"_id":"public/i_dont_wanna_use_default_archives/index.html","hash":"e8df16701ade9471e2230b3b75ffab783df3f551","modified":1511708716221},{"_id":"public/i_dont_wanna_use_default_archives/page/2/index.html","hash":"ceb687691e38cbb72eae759960707151b8cdef98","modified":1511708716221},{"_id":"public/i_dont_wanna_use_default_archives/2017/index.html","hash":"c9224cf88cfb574f2868a3c1852ec03b158fe05b","modified":1511708716222},{"_id":"public/i_dont_wanna_use_default_archives/2017/page/2/index.html","hash":"bb83affd0387803749d8d5438ec9bb4e67c2a285","modified":1511708716222},{"_id":"public/i_dont_wanna_use_default_archives/2017/03/index.html","hash":"23b642c6f8a8b6cfaf434e4c96f927d50212889d","modified":1511708716222},{"_id":"public/i_dont_wanna_use_default_archives/2017/04/index.html","hash":"b99ff6fcbb66368b31bb7fa5ca315f8e78233b9b","modified":1511708716222},{"_id":"public/i_dont_wanna_use_default_archives/2017/06/index.html","hash":"88686d18c1a65acc688b97b7a69059245aa4cbd5","modified":1511708716222},{"_id":"public/i_dont_wanna_use_default_archives/2017/07/index.html","hash":"124594e04d1d2d6554911aea822fbf948289eb73","modified":1511708716222},{"_id":"public/i_dont_wanna_use_default_archives/2017/09/index.html","hash":"2308337521744b46ba5b96bce70f0620c078e15a","modified":1511708716222},{"_id":"public/i_dont_wanna_use_default_archives/2017/10/index.html","hash":"eb7f62d229f559f35ab0265cba73262f00be3fff","modified":1511708716223},{"_id":"public/tags/React/index.html","hash":"292f98b317a4d2965833a342e1cebf94e2af8064","modified":1511708716223},{"_id":"public/tags/JS/index.html","hash":"e416a8dfd1b125481d5b1d958fb531bccc783c0a","modified":1511708716223},{"_id":"public/tags/前端面试/index.html","hash":"e515b186eccd8e0ba6942007134b29723f53c677","modified":1511708716223},{"_id":"public/tags/JavaScript/index.html","hash":"bff795687ab25a88cd61863e6109fe71e47cd739","modified":1511708716223},{"_id":"public/tags/翻译/index.html","hash":"45fb546498850624a81dc164544e7d74d79dc599","modified":1511708716223},{"_id":"public/tags/生活/index.html","hash":"3243dd698623dad8f984775d353903987f48f1ca","modified":1511708716223},{"_id":"public/tags/前端开发/index.html","hash":"56e0a7f2f8b971a007a0e769d378534fad6f4354","modified":1511708716223},{"_id":"public/tags/前端基础/index.html","hash":"4c1c8d22936ec63631599ad3a746c4f1ebdcaa49","modified":1511708716223},{"_id":"public/archives/index.html","hash":"18a766637e959b17cef510c597b0e207d7fb9b6a","modified":1511708716223},{"_id":"public/tags/index.html","hash":"89508ed9a124bc786f8dfa93d5b47250959c2210","modified":1511708716223},{"_id":"public/2017/10/17/ImagePreview组件/index.html","hash":"30dc3ffc727e728cfa869a30cedc04825d07c157","modified":1511708716223},{"_id":"public/2017/09/04/缓存机制/index.html","hash":"f20634dedd342e86f9950584cb88469bb9cf9103","modified":1511708716223},{"_id":"public/2017/07/24/时间格式化工具函数/index.html","hash":"1fa6d843a488909f629f1a4c9b935c7503da80e3","modified":1511708716223},{"_id":"public/2017/07/24/函数的节流和去抖/index.html","hash":"ad9a55083fbebfc14d156b753e30bda55cc4bc9b","modified":1511708716223},{"_id":"public/2017/07/03/JS深复制与浅复制/index.html","hash":"94e272249978cd593defafa9a891a13547795458","modified":1511708716224},{"_id":"public/2017/06/19/徒手解析URL参数/index.html","hash":"10fb04c7dc16bb80e2c9660acbdabb1929488834","modified":1511708716224},{"_id":"public/2017/06/16/JS实现快速排序/index.html","hash":"25cc127cd7a55c2ce8c871dc83e585409943f5ab","modified":1511708716224},{"_id":"public/2017/04/09/实现链式LazyMan/index.html","hash":"e60c999fde8e996d4590714af1c0c24c805b82e8","modified":1511708716224},{"_id":"public/2017/03/23/javascript-module-loader/index.html","hash":"5a41110d431eda5874e0777db1f1c11a43d4fca0","modified":1511708716224},{"_id":"public/2017/03/23/about-javascript/index.html","hash":"3d4668b3e96bd2581146bd0d2be943194cf1dc41","modified":1511708716224},{"_id":"public/2017/03/18/hello-blog/index.html","hash":"e31d1c100ab97024239a6ecac146badc006e2ec9","modified":1511708716224},{"_id":"public/about/index.html","hash":"70ca2c2b976f5dc1b2b6e8460af3e78f0195ad3e","modified":1511708716224},{"_id":"public/index.html","hash":"26f811f04a081774cc266f0f320d62fdfac34f81","modified":1511708716224},{"_id":"public/page/2/index.html","hash":"fcd1fe3cd98da525e7f093516478f87d2b2d9333","modified":1511708716224},{"_id":"public/CNAME","hash":"380684ab67adbffcd99a9d75ce51da32425c84b6","modified":1511708716229},{"_id":"public/img/avatar.jpg","hash":"49cfa597392c4a116584c07690efbbc06354acc7","modified":1511708716229},{"_id":"public/img/favicon.ico","hash":"a8ee7712f6560180efccb68546de6ea0d937fff3","modified":1511708716229},{"_id":"public/img/icon_wechat.png","hash":"7fdb00c9017236e05c1b3e6da38a2cc382fd69fa","modified":1511708716229},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1511708716229},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1511708716229},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1511708716229},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1511708716229},{"_id":"public/2017/06/16/JS实现快速排序/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1511708716229},{"_id":"public/2017/04/09/实现链式LazyMan/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1511708716229},{"_id":"public/2017/03/23/about-javascript/keep-calm-and-learn-javascript.png","hash":"49ea101b92ce5e136a19e6b11162f8f4126fe01f","modified":1511708716229},{"_id":"public/2017/03/23/about-javascript/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1511708716229},{"_id":"public/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1511708716341},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1511708716341},{"_id":"public/2017/03/18/hello-blog/post-bg-unix-linux.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1511708716343},{"_id":"public/2017/03/23/javascript-module-loader/post-bg-js-module.jpg","hash":"4a43bfa6b69c79a6ef90bd852fe5756d241733cd","modified":1511708716343},{"_id":"public/2017/03/23/about-javascript/javascript-java.jpg","hash":"881e35e241a8be40f3c4e3a6f57d5402247c1eb3","modified":1511708716343},{"_id":"public/css/highlight.css","hash":"8bc5e670b028eda8097f58bdc85269c5124c2951","modified":1511708716346},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1511708716346},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1511708716347},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1511708716347},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1511708716347},{"_id":"public/css/hux-blog.css","hash":"c1b0a32ad8075ac09d99fb4d64a9fbc84163abf8","modified":1511708716347},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1511708716347},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1511708716347},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1511708716347},{"_id":"public/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1511708716347},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1511708716347},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1511708716347},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1511708716347},{"_id":"public/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1511708716348},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1511708716348},{"_id":"public/img/home-bg.jpg","hash":"a191201c3a98728e6ea66d6827df827ecfcc9d33","modified":1511708716353},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1511708716359},{"_id":"public/img/about-bg.jpg","hash":"b5814b2d10eb38dfda0072365567f3823bc34aba","modified":1511708716374}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2017-09-12T16:31:23.000Z","updated":"2017-09-12T10:06:06.000Z","path":"404.html","title":"","comments":1,"_id":"cjagvsnis00004ouv6o6zirtr","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About Me","date":"2016-07-20T16:00:00.000Z","description":"我的职业生涯","header-img":"img/home-bg-o.jpg","comments":1,"_content":"\n\n>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。--Breaking Bad.\n>写写代码，过好生活，思考人生.\n\n\n### 自我描述\n\n1. 两年多前端开发经验，热爱编码, 对于创新以及解决具有挑战性问题充满激情。\n2. 深入了解ES5/6/7、CSS、HTML，掌握一种前端开发框架如React+Redux等，并有一手开发经验。\n3. 项目实战经验丰富，代码风骚又不失优雅，开发迅捷又不失逻辑严谨，轻度代码洁癖。\n4. 对代码封装比较感兴趣，热爱优秀的编码，关注前端技术的发展趋势，致力于运用流行技术构建awesome 应用。\n\n***\n\n\n### 工作经历\n\n\n***\n#### 齐牛金融\n\n* 公司前端主程之一，参与公司前端技术选型，解决前端工程化,以及代码规范制定。\n* 负责公司[分级基金](https://jinsuibao.guosen.com.cn:8001/)的**移动端H5**开发，使用各种技术手段解决了页面复杂的交互，细心的软件测试和严谨的代码逻辑确保产品上线稳定并且容易维护。\n* [公司官网](https://www.yiqiniu.com)开发负责人，能独立运用Node.js做网站SEO优化和页面开发。\n* [公司企业宝](https://www.91qiyebao.com)主要开发者之一。\n***\n\n\n***\n#### 深圳柚子街科技有限公司\n\n* 负责网吧运营后台前端界面开发以及维护，确保系统界面稳定运 行，参与需求研讨,方案制定。\n* 移动端方面，负责柚子生活产品H5开发，运用react，webpack快 速开发微信端业务，与产品经理，UI合作，不断创造新的Web产品 和优化现有的产品和服务。\n\n* 负责公司微信营销页面开发，熟悉微信端H5页面的开发,能独立高效 完成微信页面。\n***\n\n### 项目经历\n\n[齐牛官网](https://www.yiqiniu.com)\n*项目主程，负责页面开发与维护，以及SEO优化。*\n\n2016.09 - 至今\n* 公司官网主要业务目的是做SEO导流，所以在技术选型上使用当下流行的Node,js，后端渲染解决网页加载和爬虫索引问题，主要技术如下:\n技术栈：express, jquery, grunt, jade模版引擎\n\n* 此项目是我在公司自己长期开发与维护的项目，利用node.js做服务器渲染,获得秒开加载速度\n\n* 网站已被百度收录的链接近26万，配合上良好的SEO优化（如做好sitemap, 语义化使用标签, 为每个页面定制meta等）,SEO成效还是挺可观的。\n***\n\n[一起牛企业宝](https://www.91qiyebao.com)\n*负责网站需求开发和日常维护*\n\n2016.10 - 2017.07\n* 公司主要金融产品之一，网站服务于企业客户，稳定性高，性能优秀，支持高并发。   主要技术如下:\n技术栈：express, jquery, grunt, bootstrap。\n* 主要职责： 负责此网站整体框架的搭建，技术栈的选定，致力于令代码松散耦合，易于拓展，组件可复用。\n* 解决技术难题： 在node服务端，由于JS的单线程运行，代码容错性不高的话，极容易引起程序线程堵塞。 所以制定一系列代码准则，加强防御性编程，极大提升程序容错率。\n***\n\n国信证券[分级基金h5](https://jinsuibao.guosen.com.cn:8001/)\n*主程之一，项目技术栈的调研和搭建，基础组件和页面开发。*\n\n2016.09 - 2016.12\n* 前端交互逻辑比较复杂，在技术选型阶段，我们团队3人经过大量调研和讨论，最终确定以下技术栈，和选型理由如下：\n项目前端技术栈: React + Redux + less + ES6/7 + webpack + fetch + react-router按需加载 \n\n* 此项目算是中大型开发项目，React的模块化开发方，很好解决团队合作开发问题，做到了组件复用上最大化，开发体验十分友好。\n\n* 整个webapp组件交流特别频繁，逻辑也很复杂，使用redux的优势就特别明显了。想要redux发挥最大效用,数据结构更清晰,那对state树的设计要求特别高。\n\n* 由于项目代码比较多，如果一次打包全部加载，首屏空白时间会很长，无疑十分影响用户体验。所以使用react-router按需加载尤为重要。\n***","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About Me\"\ndate: 2016-07-21 \ndescription: \"我的职业生涯\"\nheader-img: \"img/home-bg-o.jpg\"\ncomments: true\n---\n\n\n>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。--Breaking Bad.\n>写写代码，过好生活，思考人生.\n\n\n### 自我描述\n\n1. 两年多前端开发经验，热爱编码, 对于创新以及解决具有挑战性问题充满激情。\n2. 深入了解ES5/6/7、CSS、HTML，掌握一种前端开发框架如React+Redux等，并有一手开发经验。\n3. 项目实战经验丰富，代码风骚又不失优雅，开发迅捷又不失逻辑严谨，轻度代码洁癖。\n4. 对代码封装比较感兴趣，热爱优秀的编码，关注前端技术的发展趋势，致力于运用流行技术构建awesome 应用。\n\n***\n\n\n### 工作经历\n\n\n***\n#### 齐牛金融\n\n* 公司前端主程之一，参与公司前端技术选型，解决前端工程化,以及代码规范制定。\n* 负责公司[分级基金](https://jinsuibao.guosen.com.cn:8001/)的**移动端H5**开发，使用各种技术手段解决了页面复杂的交互，细心的软件测试和严谨的代码逻辑确保产品上线稳定并且容易维护。\n* [公司官网](https://www.yiqiniu.com)开发负责人，能独立运用Node.js做网站SEO优化和页面开发。\n* [公司企业宝](https://www.91qiyebao.com)主要开发者之一。\n***\n\n\n***\n#### 深圳柚子街科技有限公司\n\n* 负责网吧运营后台前端界面开发以及维护，确保系统界面稳定运 行，参与需求研讨,方案制定。\n* 移动端方面，负责柚子生活产品H5开发，运用react，webpack快 速开发微信端业务，与产品经理，UI合作，不断创造新的Web产品 和优化现有的产品和服务。\n\n* 负责公司微信营销页面开发，熟悉微信端H5页面的开发,能独立高效 完成微信页面。\n***\n\n### 项目经历\n\n[齐牛官网](https://www.yiqiniu.com)\n*项目主程，负责页面开发与维护，以及SEO优化。*\n\n2016.09 - 至今\n* 公司官网主要业务目的是做SEO导流，所以在技术选型上使用当下流行的Node,js，后端渲染解决网页加载和爬虫索引问题，主要技术如下:\n技术栈：express, jquery, grunt, jade模版引擎\n\n* 此项目是我在公司自己长期开发与维护的项目，利用node.js做服务器渲染,获得秒开加载速度\n\n* 网站已被百度收录的链接近26万，配合上良好的SEO优化（如做好sitemap, 语义化使用标签, 为每个页面定制meta等）,SEO成效还是挺可观的。\n***\n\n[一起牛企业宝](https://www.91qiyebao.com)\n*负责网站需求开发和日常维护*\n\n2016.10 - 2017.07\n* 公司主要金融产品之一，网站服务于企业客户，稳定性高，性能优秀，支持高并发。   主要技术如下:\n技术栈：express, jquery, grunt, bootstrap。\n* 主要职责： 负责此网站整体框架的搭建，技术栈的选定，致力于令代码松散耦合，易于拓展，组件可复用。\n* 解决技术难题： 在node服务端，由于JS的单线程运行，代码容错性不高的话，极容易引起程序线程堵塞。 所以制定一系列代码准则，加强防御性编程，极大提升程序容错率。\n***\n\n国信证券[分级基金h5](https://jinsuibao.guosen.com.cn:8001/)\n*主程之一，项目技术栈的调研和搭建，基础组件和页面开发。*\n\n2016.09 - 2016.12\n* 前端交互逻辑比较复杂，在技术选型阶段，我们团队3人经过大量调研和讨论，最终确定以下技术栈，和选型理由如下：\n项目前端技术栈: React + Redux + less + ES6/7 + webpack + fetch + react-router按需加载 \n\n* 此项目算是中大型开发项目，React的模块化开发方，很好解决团队合作开发问题，做到了组件复用上最大化，开发体验十分友好。\n\n* 整个webapp组件交流特别频繁，逻辑也很复杂，使用redux的优势就特别明显了。想要redux发挥最大效用,数据结构更清晰,那对state树的设计要求特别高。\n\n* 由于项目代码比较多，如果一次打包全部加载，首屏空白时间会很长，无疑十分影响用户体验。所以使用react-router按需加载尤为重要。\n***","updated":"2017-09-12T10:06:06.000Z","path":"about/index.html","_id":"cjagvsnjj00024ouvq2a2k1o8","content":"<blockquote>\n<p>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。–Breaking Bad.<br>写写代码，过好生活，思考人生.</p>\n</blockquote>\n<h3 id=\"自我描述\"><a href=\"#自我描述\" class=\"headerlink\" title=\"自我描述\"></a>自我描述</h3><ol>\n<li>两年多前端开发经验，热爱编码, 对于创新以及解决具有挑战性问题充满激情。</li>\n<li>深入了解ES5/6/7、CSS、HTML，掌握一种前端开发框架如React+Redux等，并有一手开发经验。</li>\n<li>项目实战经验丰富，代码风骚又不失优雅，开发迅捷又不失逻辑严谨，轻度代码洁癖。</li>\n<li>对代码封装比较感兴趣，热爱优秀的编码，关注前端技术的发展趋势，致力于运用流行技术构建awesome 应用。</li>\n</ol>\n<hr>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><hr>\n<h4 id=\"齐牛金融\"><a href=\"#齐牛金融\" class=\"headerlink\" title=\"齐牛金融\"></a>齐牛金融</h4><ul>\n<li>公司前端主程之一，参与公司前端技术选型，解决前端工程化,以及代码规范制定。</li>\n<li>负责公司<a href=\"https://jinsuibao.guosen.com.cn:8001/\" target=\"_blank\" rel=\"external\">分级基金</a>的<strong>移动端H5</strong>开发，使用各种技术手段解决了页面复杂的交互，细心的软件测试和严谨的代码逻辑确保产品上线稳定并且容易维护。</li>\n<li><a href=\"https://www.yiqiniu.com\" target=\"_blank\" rel=\"external\">公司官网</a>开发负责人，能独立运用Node.js做网站SEO优化和页面开发。</li>\n<li><a href=\"https://www.91qiyebao.com\" target=\"_blank\" rel=\"external\">公司企业宝</a>主要开发者之一。</li>\n</ul>\n<hr>\n<hr>\n<h4 id=\"深圳柚子街科技有限公司\"><a href=\"#深圳柚子街科技有限公司\" class=\"headerlink\" title=\"深圳柚子街科技有限公司\"></a>深圳柚子街科技有限公司</h4><ul>\n<li>负责网吧运营后台前端界面开发以及维护，确保系统界面稳定运 行，参与需求研讨,方案制定。</li>\n<li><p>移动端方面，负责柚子生活产品H5开发，运用react，webpack快 速开发微信端业务，与产品经理，UI合作，不断创造新的Web产品 和优化现有的产品和服务。</p>\n</li>\n<li><p>负责公司微信营销页面开发，熟悉微信端H5页面的开发,能独立高效 完成微信页面。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h3><p><a href=\"https://www.yiqiniu.com\" target=\"_blank\" rel=\"external\">齐牛官网</a><br><em>项目主程，负责页面开发与维护，以及SEO优化。</em></p>\n<p>2016.09 - 至今</p>\n<ul>\n<li><p>公司官网主要业务目的是做SEO导流，所以在技术选型上使用当下流行的Node,js，后端渲染解决网页加载和爬虫索引问题，主要技术如下:<br>技术栈：express, jquery, grunt, jade模版引擎</p>\n</li>\n<li><p>此项目是我在公司自己长期开发与维护的项目，利用node.js做服务器渲染,获得秒开加载速度</p>\n</li>\n<li><p>网站已被百度收录的链接近26万，配合上良好的SEO优化（如做好sitemap, 语义化使用标签, 为每个页面定制meta等）,SEO成效还是挺可观的。</p>\n</li>\n</ul>\n<hr>\n<p><a href=\"https://www.91qiyebao.com\" target=\"_blank\" rel=\"external\">一起牛企业宝</a><br><em>负责网站需求开发和日常维护</em></p>\n<p>2016.10 - 2017.07</p>\n<ul>\n<li>公司主要金融产品之一，网站服务于企业客户，稳定性高，性能优秀，支持高并发。   主要技术如下:<br>技术栈：express, jquery, grunt, bootstrap。</li>\n<li>主要职责： 负责此网站整体框架的搭建，技术栈的选定，致力于令代码松散耦合，易于拓展，组件可复用。</li>\n<li>解决技术难题： 在node服务端，由于JS的单线程运行，代码容错性不高的话，极容易引起程序线程堵塞。 所以制定一系列代码准则，加强防御性编程，极大提升程序容错率。</li>\n</ul>\n<hr>\n<p>国信证券<a href=\"https://jinsuibao.guosen.com.cn:8001/\" target=\"_blank\" rel=\"external\">分级基金h5</a><br><em>主程之一，项目技术栈的调研和搭建，基础组件和页面开发。</em></p>\n<p>2016.09 - 2016.12</p>\n<ul>\n<li><p>前端交互逻辑比较复杂，在技术选型阶段，我们团队3人经过大量调研和讨论，最终确定以下技术栈，和选型理由如下：<br>项目前端技术栈: React + Redux + less + ES6/7 + webpack + fetch + react-router按需加载 </p>\n</li>\n<li><p>此项目算是中大型开发项目，React的模块化开发方，很好解决团队合作开发问题，做到了组件复用上最大化，开发体验十分友好。</p>\n</li>\n<li><p>整个webapp组件交流特别频繁，逻辑也很复杂，使用redux的优势就特别明显了。想要redux发挥最大效用,数据结构更清晰,那对state树的设计要求特别高。</p>\n</li>\n<li><p>由于项目代码比较多，如果一次打包全部加载，首屏空白时间会很长，无疑十分影响用户体验。所以使用react-router按需加载尤为重要。</p>\n</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。–Breaking Bad.<br>写写代码，过好生活，思考人生.</p>\n</blockquote>\n<h3 id=\"自我描述\"><a href=\"#自我描述\" class=\"headerlink\" title=\"自我描述\"></a>自我描述</h3><ol>\n<li>两年多前端开发经验，热爱编码, 对于创新以及解决具有挑战性问题充满激情。</li>\n<li>深入了解ES5/6/7、CSS、HTML，掌握一种前端开发框架如React+Redux等，并有一手开发经验。</li>\n<li>项目实战经验丰富，代码风骚又不失优雅，开发迅捷又不失逻辑严谨，轻度代码洁癖。</li>\n<li>对代码封装比较感兴趣，热爱优秀的编码，关注前端技术的发展趋势，致力于运用流行技术构建awesome 应用。</li>\n</ol>\n<hr>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><hr>\n<h4 id=\"齐牛金融\"><a href=\"#齐牛金融\" class=\"headerlink\" title=\"齐牛金融\"></a>齐牛金融</h4><ul>\n<li>公司前端主程之一，参与公司前端技术选型，解决前端工程化,以及代码规范制定。</li>\n<li>负责公司<a href=\"https://jinsuibao.guosen.com.cn:8001/\" target=\"_blank\" rel=\"external\">分级基金</a>的<strong>移动端H5</strong>开发，使用各种技术手段解决了页面复杂的交互，细心的软件测试和严谨的代码逻辑确保产品上线稳定并且容易维护。</li>\n<li><a href=\"https://www.yiqiniu.com\" target=\"_blank\" rel=\"external\">公司官网</a>开发负责人，能独立运用Node.js做网站SEO优化和页面开发。</li>\n<li><a href=\"https://www.91qiyebao.com\" target=\"_blank\" rel=\"external\">公司企业宝</a>主要开发者之一。</li>\n</ul>\n<hr>\n<hr>\n<h4 id=\"深圳柚子街科技有限公司\"><a href=\"#深圳柚子街科技有限公司\" class=\"headerlink\" title=\"深圳柚子街科技有限公司\"></a>深圳柚子街科技有限公司</h4><ul>\n<li>负责网吧运营后台前端界面开发以及维护，确保系统界面稳定运 行，参与需求研讨,方案制定。</li>\n<li><p>移动端方面，负责柚子生活产品H5开发，运用react，webpack快 速开发微信端业务，与产品经理，UI合作，不断创造新的Web产品 和优化现有的产品和服务。</p>\n</li>\n<li><p>负责公司微信营销页面开发，熟悉微信端H5页面的开发,能独立高效 完成微信页面。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h3><p><a href=\"https://www.yiqiniu.com\" target=\"_blank\" rel=\"external\">齐牛官网</a><br><em>项目主程，负责页面开发与维护，以及SEO优化。</em></p>\n<p>2016.09 - 至今</p>\n<ul>\n<li><p>公司官网主要业务目的是做SEO导流，所以在技术选型上使用当下流行的Node,js，后端渲染解决网页加载和爬虫索引问题，主要技术如下:<br>技术栈：express, jquery, grunt, jade模版引擎</p>\n</li>\n<li><p>此项目是我在公司自己长期开发与维护的项目，利用node.js做服务器渲染,获得秒开加载速度</p>\n</li>\n<li><p>网站已被百度收录的链接近26万，配合上良好的SEO优化（如做好sitemap, 语义化使用标签, 为每个页面定制meta等）,SEO成效还是挺可观的。</p>\n</li>\n</ul>\n<hr>\n<p><a href=\"https://www.91qiyebao.com\" target=\"_blank\" rel=\"external\">一起牛企业宝</a><br><em>负责网站需求开发和日常维护</em></p>\n<p>2016.10 - 2017.07</p>\n<ul>\n<li>公司主要金融产品之一，网站服务于企业客户，稳定性高，性能优秀，支持高并发。   主要技术如下:<br>技术栈：express, jquery, grunt, bootstrap。</li>\n<li>主要职责： 负责此网站整体框架的搭建，技术栈的选定，致力于令代码松散耦合，易于拓展，组件可复用。</li>\n<li>解决技术难题： 在node服务端，由于JS的单线程运行，代码容错性不高的话，极容易引起程序线程堵塞。 所以制定一系列代码准则，加强防御性编程，极大提升程序容错率。</li>\n</ul>\n<hr>\n<p>国信证券<a href=\"https://jinsuibao.guosen.com.cn:8001/\" target=\"_blank\" rel=\"external\">分级基金h5</a><br><em>主程之一，项目技术栈的调研和搭建，基础组件和页面开发。</em></p>\n<p>2016.09 - 2016.12</p>\n<ul>\n<li><p>前端交互逻辑比较复杂，在技术选型阶段，我们团队3人经过大量调研和讨论，最终确定以下技术栈，和选型理由如下：<br>项目前端技术栈: React + Redux + less + ES6/7 + webpack + fetch + react-router按需加载 </p>\n</li>\n<li><p>此项目算是中大型开发项目，React的模块化开发方，很好解决团队合作开发问题，做到了组件复用上最大化，开发体验十分友好。</p>\n</li>\n<li><p>整个webapp组件交流特别频繁，逻辑也很复杂，使用redux的优势就特别明显了。想要redux发挥最大效用,数据结构更清晰,那对state树的设计要求特别高。</p>\n</li>\n<li><p>由于项目代码比较多，如果一次打包全部加载，首屏空白时间会很长，无疑十分影响用户体验。所以使用react-router按需加载尤为重要。</p>\n</li>\n</ul>\n<hr>\n"},{"layout":"archives","title":"Archives","description":"Yo~ Man. go go go!","header-img":"img/tag-bg.jpg","_content":"","source":"archives/index.md","raw":"---\nlayout: \"archives\"\ntitle: \"Archives\"\ndescription: \"Yo~ Man. go go go!\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2017-09-12T16:31:27.000Z","updated":"2017-09-12T10:06:06.000Z","path":"archives/index.html","comments":1,"_id":"cjagvsnjl00044ouv35puyjvc","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/tag-bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2017-09-12T16:31:27.000Z","updated":"2017-09-12T10:06:06.000Z","path":"tags/index.html","comments":1,"_id":"cjagvsnjo00074ouvbz5qzwnh","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"图片预览组件的一些事一些情","date":"2017-10-17T06:21:45.000Z","_content":"\n# React组件设计\ndemo: http://gmfe.github.io/react-gm/#/doc/ImagePreview\ngithub源码: https://github.com/gmfe/react-gm/tree/master/src/component/image_preview\n\n---\n## react组件设计\n按照组件的使用方式来划分,\b有两种方式:\n- `静态方法` \n>- 把组件的一系列逻辑封装成一个函数,使用时直接调用函数.\n\n\n- `react.Component` \n>- \b把组件\b封装成component形式,如: `<Component props />`\n\n---\n\n\n## imagePreivew组件设计思路\n以上两种设计模式,哪种适合imagePreview\b呢?  看以下分析\n\n* 封装成`Component形式`\n\n```jsx\n\nimport {ImagePreview} from 'react-gm';\n\n// 使用演示\nclass example extends React.Component {\n    // \b需要状态控制浮层的显示\n    state = {\n        showImagePreview: false\n    };\n    \n    hanleOpen() {\n       this.setState({showImagePreview: true});\n    }\n    \n    \bhandleClose() {\n       this.setState({showImagePreview: true});\n    }\n\n    render() {\n        return (\n            <div>\n                <img src=\"1\" onClick={this.handleOpen.bind(this)} />\n                {/* 浮层需要埋点,使用很繁琐 */}\n                {this.state.showImagePreview && \n                 <ImagePreview  \bhandleClose={this.\bhandleClose.bind(this/>\n                }\n            </div>\n        )\n    }\n}\n\n```\n\n* \b封装成`静态方法`\n\n```jsx\n\nimport {ImagePreview} from 'react-gm';\n\n// 使用演示\nclass example extends React.Component {\n    render() {\n        return (\n            <div>\n                <img src=\"1\" onClick={() => ImagePreview()} />\n            </div>\n        )\n    }\n}\n\n```\n对比可以看出来,组件封装成静态方法的形式,特别适用浮层类组件.   \n* 使得组件自己管理自己的显示状态\n* 无需埋点\n\n\n---\n\n## \b预览大图的实现\n\b\b实现大图居中显示有N种方法,ImagePreview实现居中使用了`object-fit`\n\n\b* 定义: `object-fit` 只能用于『可替换元素』(replaced element) 。所谓可替换元素，是指元素的内容和表现不是由CSS控制的，独立渲染的外部元素，比如： `img`、 `object`、 `video` 和 `表单元素`，如`textarea`、 `input`，`audio` 和 `canvas`在一些特殊情况下，也可以作为可替换元素。\n\n*注意: *使用`object-fit`的使用一定要设置`size`*\n\n`object-fit` 有五个可选值，分别是：\n\n* `fill` 默认值。填充，可替换元素填满整个内容区域，可能会改变长宽比。\n* `contain` 包含，保持长宽比，保证可替换元素完整显示，长宽比和内容区域的长宽比不一致时，内容区域会出现空白。\n* `cover` 覆盖，保持长宽比，保证内容区域被填满，所以可替换元素可能会被切掉一部分，从而不能完整展示。\n* `none` 顾名思义，就是什么都没有啦，当然不是什么都没有啦，而且千万不要以为和`fill`是一样的！实际效果是，保持可替换元素原尺寸和比例。\n* `scale-down` 等比缩小。效果类似 `contain` 或 `none`\n\n直观一点可以看图: https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\n\n### \bone more thing\n当元素被 `object-fit` 裁切的时候，你一定想知道如何控制裁切的位置。 所以, `object-position` 就是为了解决这个问题的。\n\n`object-position` 不难理解，类似 background-position，不多说。\n\n### 浏览器兼容\n* IE全部不支持\n* Chrome 31+\n* Safari 7.1+ \n* Firefox 36+\n\n---\n## scrollIntoViewIfNeeded\n缩略图滚动上使用`scrollIntoViewIfNeeded`,使当前图片保持在视图范围内(\b改变元素的scrollLeft)\n\n---","source":"_posts/ImagePreview组件.md","raw":"---\ntitle: 图片预览组件的一些事一些情\ndate: 2017-10-17 14:21:45\ntags: \n    - React\n---\n\n# React组件设计\ndemo: http://gmfe.github.io/react-gm/#/doc/ImagePreview\ngithub源码: https://github.com/gmfe/react-gm/tree/master/src/component/image_preview\n\n---\n## react组件设计\n按照组件的使用方式来划分,\b有两种方式:\n- `静态方法` \n>- 把组件的一系列逻辑封装成一个函数,使用时直接调用函数.\n\n\n- `react.Component` \n>- \b把组件\b封装成component形式,如: `<Component props />`\n\n---\n\n\n## imagePreivew组件设计思路\n以上两种设计模式,哪种适合imagePreview\b呢?  看以下分析\n\n* 封装成`Component形式`\n\n```jsx\n\nimport {ImagePreview} from 'react-gm';\n\n// 使用演示\nclass example extends React.Component {\n    // \b需要状态控制浮层的显示\n    state = {\n        showImagePreview: false\n    };\n    \n    hanleOpen() {\n       this.setState({showImagePreview: true});\n    }\n    \n    \bhandleClose() {\n       this.setState({showImagePreview: true});\n    }\n\n    render() {\n        return (\n            <div>\n                <img src=\"1\" onClick={this.handleOpen.bind(this)} />\n                {/* 浮层需要埋点,使用很繁琐 */}\n                {this.state.showImagePreview && \n                 <ImagePreview  \bhandleClose={this.\bhandleClose.bind(this/>\n                }\n            </div>\n        )\n    }\n}\n\n```\n\n* \b封装成`静态方法`\n\n```jsx\n\nimport {ImagePreview} from 'react-gm';\n\n// 使用演示\nclass example extends React.Component {\n    render() {\n        return (\n            <div>\n                <img src=\"1\" onClick={() => ImagePreview()} />\n            </div>\n        )\n    }\n}\n\n```\n对比可以看出来,组件封装成静态方法的形式,特别适用浮层类组件.   \n* 使得组件自己管理自己的显示状态\n* 无需埋点\n\n\n---\n\n## \b预览大图的实现\n\b\b实现大图居中显示有N种方法,ImagePreview实现居中使用了`object-fit`\n\n\b* 定义: `object-fit` 只能用于『可替换元素』(replaced element) 。所谓可替换元素，是指元素的内容和表现不是由CSS控制的，独立渲染的外部元素，比如： `img`、 `object`、 `video` 和 `表单元素`，如`textarea`、 `input`，`audio` 和 `canvas`在一些特殊情况下，也可以作为可替换元素。\n\n*注意: *使用`object-fit`的使用一定要设置`size`*\n\n`object-fit` 有五个可选值，分别是：\n\n* `fill` 默认值。填充，可替换元素填满整个内容区域，可能会改变长宽比。\n* `contain` 包含，保持长宽比，保证可替换元素完整显示，长宽比和内容区域的长宽比不一致时，内容区域会出现空白。\n* `cover` 覆盖，保持长宽比，保证内容区域被填满，所以可替换元素可能会被切掉一部分，从而不能完整展示。\n* `none` 顾名思义，就是什么都没有啦，当然不是什么都没有啦，而且千万不要以为和`fill`是一样的！实际效果是，保持可替换元素原尺寸和比例。\n* `scale-down` 等比缩小。效果类似 `contain` 或 `none`\n\n直观一点可以看图: https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\n\n### \bone more thing\n当元素被 `object-fit` 裁切的时候，你一定想知道如何控制裁切的位置。 所以, `object-position` 就是为了解决这个问题的。\n\n`object-position` 不难理解，类似 background-position，不多说。\n\n### 浏览器兼容\n* IE全部不支持\n* Chrome 31+\n* Safari 7.1+ \n* Firefox 36+\n\n---\n## scrollIntoViewIfNeeded\n缩略图滚动上使用`scrollIntoViewIfNeeded`,使当前图片保持在视图范围内(\b改变元素的scrollLeft)\n\n---","slug":"ImagePreview组件","published":1,"updated":"2017-10-17T08:53:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjagvsnjg00014ouvielm5q3h","content":"<h1 id=\"React组件设计\"><a href=\"#React组件设计\" class=\"headerlink\" title=\"React组件设计\"></a>React组件设计</h1><p>demo: <a href=\"http://gmfe.github.io/react-gm/#/doc/ImagePreview\" target=\"_blank\" rel=\"external\">http://gmfe.github.io/react-gm/#/doc/ImagePreview</a><br>github源码: <a href=\"https://github.com/gmfe/react-gm/tree/master/src/component/image_preview\" target=\"_blank\" rel=\"external\">https://github.com/gmfe/react-gm/tree/master/src/component/image_preview</a></p>\n<hr>\n<h2 id=\"react组件设计\"><a href=\"#react组件设计\" class=\"headerlink\" title=\"react组件设计\"></a>react组件设计</h2><p>按照组件的使用方式来划分,\b有两种方式:</p>\n<ul>\n<li><code>静态方法</code> <blockquote>\n<ul>\n<li>把组件的一系列逻辑封装成一个函数,使用时直接调用函数.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><code>react.Component</code> <blockquote>\n<ul>\n<li>\b把组件\b封装成component形式,如: <code>&lt;Component props /&gt;</code></li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"imagePreivew组件设计思路\"><a href=\"#imagePreivew组件设计思路\" class=\"headerlink\" title=\"imagePreivew组件设计思路\"></a>imagePreivew组件设计思路</h2><p>以上两种设计模式,哪种适合imagePreview\b呢?  看以下分析</p>\n<ul>\n<li>封装成<code>Component形式</code></li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;ImagePreview&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-gm'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用演示</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// \b需要状态控制浮层的显示</span></div><div class=\"line\">    state = &#123;</div><div class=\"line\">        showImagePreview: <span class=\"literal\">false</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    hanleOpen() &#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">showImagePreview</span>: <span class=\"literal\">true</span>&#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    \bhandleClose() &#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">showImagePreview</span>: <span class=\"literal\">true</span>&#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &lt;img src=<span class=\"string\">\"1\"</span> onClick=&#123;<span class=\"keyword\">this</span>.handleOpen.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</div><div class=\"line\">                &#123;<span class=\"comment\">/* 浮层需要埋点,使用很繁琐 */</span>&#125;</div><div class=\"line\">                &#123;<span class=\"keyword\">this</span>.state.showImagePreview &amp;&amp; </div><div class=\"line\">                 &lt;ImagePreview  \bhandleClose=&#123;<span class=\"keyword\">this</span>.\bhandleClose.bind(<span class=\"keyword\">this</span>/&gt;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">        )</span></div><div class=\"line\"><span class=\"regexp\">    &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div></pre></td></tr></table></figure>\n<ul>\n<li>\b封装成<code>静态方法</code></li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;ImagePreview&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-gm'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用演示</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &lt;img src=<span class=\"string\">\"1\"</span> onClick=&#123;() =&gt; ImagePreview()&#125; /&gt;</div><div class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">        )</span></div><div class=\"line\"><span class=\"regexp\">    &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div></pre></td></tr></table></figure>\n<p>对比可以看出来,组件封装成静态方法的形式,特别适用浮层类组件.   </p>\n<ul>\n<li>使得组件自己管理自己的显示状态</li>\n<li>无需埋点</li>\n</ul>\n<hr>\n<h2 id=\"预览大图的实现\"><a href=\"#预览大图的实现\" class=\"headerlink\" title=\"\b预览大图的实现\"></a>\b预览大图的实现</h2><p>\b\b实现大图居中显示有N种方法,ImagePreview实现居中使用了<code>object-fit</code></p>\n<p>\b* 定义: <code>object-fit</code> 只能用于『可替换元素』(replaced element) 。所谓可替换元素，是指元素的内容和表现不是由CSS控制的，独立渲染的外部元素，比如： <code>img</code>、 <code>object</code>、 <code>video</code> 和 <code>表单元素</code>，如<code>textarea</code>、 <code>input</code>，<code>audio</code> 和 <code>canvas</code>在一些特殊情况下，也可以作为可替换元素。</p>\n<p><em>注意: </em>使用<code>object-fit</code>的使用一定要设置<code>size</code>*</p>\n<p><code>object-fit</code> 有五个可选值，分别是：</p>\n<ul>\n<li><code>fill</code> 默认值。填充，可替换元素填满整个内容区域，可能会改变长宽比。</li>\n<li><code>contain</code> 包含，保持长宽比，保证可替换元素完整显示，长宽比和内容区域的长宽比不一致时，内容区域会出现空白。</li>\n<li><code>cover</code> 覆盖，保持长宽比，保证内容区域被填满，所以可替换元素可能会被切掉一部分，从而不能完整展示。</li>\n<li><code>none</code> 顾名思义，就是什么都没有啦，当然不是什么都没有啦，而且千万不要以为和<code>fill</code>是一样的！实际效果是，保持可替换元素原尺寸和比例。</li>\n<li><code>scale-down</code> 等比缩小。效果类似 <code>contain</code> 或 <code>none</code></li>\n</ul>\n<p>直观一点可以看图: <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit</a></p>\n<h3 id=\"one-more-thing\"><a href=\"#one-more-thing\" class=\"headerlink\" title=\"\bone more thing\"></a>\bone more thing</h3><p>当元素被 <code>object-fit</code> 裁切的时候，你一定想知道如何控制裁切的位置。 所以, <code>object-position</code> 就是为了解决这个问题的。</p>\n<p><code>object-position</code> 不难理解，类似 background-position，不多说。</p>\n<h3 id=\"浏览器兼容\"><a href=\"#浏览器兼容\" class=\"headerlink\" title=\"浏览器兼容\"></a>浏览器兼容</h3><ul>\n<li>IE全部不支持</li>\n<li>Chrome 31+</li>\n<li>Safari 7.1+ </li>\n<li>Firefox 36+</li>\n</ul>\n<hr>\n<h2 id=\"scrollIntoViewIfNeeded\"><a href=\"#scrollIntoViewIfNeeded\" class=\"headerlink\" title=\"scrollIntoViewIfNeeded\"></a>scrollIntoViewIfNeeded</h2><p>缩略图滚动上使用<code>scrollIntoViewIfNeeded</code>,使当前图片保持在视图范围内(\b改变元素的scrollLeft)</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React组件设计\"><a href=\"#React组件设计\" class=\"headerlink\" title=\"React组件设计\"></a>React组件设计</h1><p>demo: <a href=\"http://gmfe.github.io/react-gm/#/doc/ImagePreview\" target=\"_blank\" rel=\"external\">http://gmfe.github.io/react-gm/#/doc/ImagePreview</a><br>github源码: <a href=\"https://github.com/gmfe/react-gm/tree/master/src/component/image_preview\" target=\"_blank\" rel=\"external\">https://github.com/gmfe/react-gm/tree/master/src/component/image_preview</a></p>\n<hr>\n<h2 id=\"react组件设计\"><a href=\"#react组件设计\" class=\"headerlink\" title=\"react组件设计\"></a>react组件设计</h2><p>按照组件的使用方式来划分,\b有两种方式:</p>\n<ul>\n<li><code>静态方法</code> <blockquote>\n<ul>\n<li>把组件的一系列逻辑封装成一个函数,使用时直接调用函数.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><code>react.Component</code> <blockquote>\n<ul>\n<li>\b把组件\b封装成component形式,如: <code>&lt;Component props /&gt;</code></li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"imagePreivew组件设计思路\"><a href=\"#imagePreivew组件设计思路\" class=\"headerlink\" title=\"imagePreivew组件设计思路\"></a>imagePreivew组件设计思路</h2><p>以上两种设计模式,哪种适合imagePreview\b呢?  看以下分析</p>\n<ul>\n<li>封装成<code>Component形式</code></li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;ImagePreview&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-gm'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用演示</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// \b需要状态控制浮层的显示</span></div><div class=\"line\">    state = &#123;</div><div class=\"line\">        showImagePreview: <span class=\"literal\">false</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    hanleOpen() &#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">showImagePreview</span>: <span class=\"literal\">true</span>&#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    \bhandleClose() &#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">showImagePreview</span>: <span class=\"literal\">true</span>&#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &lt;img src=<span class=\"string\">\"1\"</span> onClick=&#123;<span class=\"keyword\">this</span>.handleOpen.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</div><div class=\"line\">                &#123;<span class=\"comment\">/* 浮层需要埋点,使用很繁琐 */</span>&#125;</div><div class=\"line\">                &#123;<span class=\"keyword\">this</span>.state.showImagePreview &amp;&amp; </div><div class=\"line\">                 &lt;ImagePreview  \bhandleClose=&#123;<span class=\"keyword\">this</span>.\bhandleClose.bind(<span class=\"keyword\">this</span>/&gt;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">        )</span></div><div class=\"line\"><span class=\"regexp\">    &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div></pre></td></tr></table></figure>\n<ul>\n<li>\b封装成<code>静态方法</code></li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;ImagePreview&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-gm'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用演示</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;div&gt;</div><div class=\"line\">                &lt;img src=<span class=\"string\">\"1\"</span> onClick=&#123;() =&gt; ImagePreview()&#125; /&gt;</div><div class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">        )</span></div><div class=\"line\"><span class=\"regexp\">    &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div></pre></td></tr></table></figure>\n<p>对比可以看出来,组件封装成静态方法的形式,特别适用浮层类组件.   </p>\n<ul>\n<li>使得组件自己管理自己的显示状态</li>\n<li>无需埋点</li>\n</ul>\n<hr>\n<h2 id=\"预览大图的实现\"><a href=\"#预览大图的实现\" class=\"headerlink\" title=\"\b预览大图的实现\"></a>\b预览大图的实现</h2><p>\b\b实现大图居中显示有N种方法,ImagePreview实现居中使用了<code>object-fit</code></p>\n<p>\b* 定义: <code>object-fit</code> 只能用于『可替换元素』(replaced element) 。所谓可替换元素，是指元素的内容和表现不是由CSS控制的，独立渲染的外部元素，比如： <code>img</code>、 <code>object</code>、 <code>video</code> 和 <code>表单元素</code>，如<code>textarea</code>、 <code>input</code>，<code>audio</code> 和 <code>canvas</code>在一些特殊情况下，也可以作为可替换元素。</p>\n<p><em>注意: </em>使用<code>object-fit</code>的使用一定要设置<code>size</code>*</p>\n<p><code>object-fit</code> 有五个可选值，分别是：</p>\n<ul>\n<li><code>fill</code> 默认值。填充，可替换元素填满整个内容区域，可能会改变长宽比。</li>\n<li><code>contain</code> 包含，保持长宽比，保证可替换元素完整显示，长宽比和内容区域的长宽比不一致时，内容区域会出现空白。</li>\n<li><code>cover</code> 覆盖，保持长宽比，保证内容区域被填满，所以可替换元素可能会被切掉一部分，从而不能完整展示。</li>\n<li><code>none</code> 顾名思义，就是什么都没有啦，当然不是什么都没有啦，而且千万不要以为和<code>fill</code>是一样的！实际效果是，保持可替换元素原尺寸和比例。</li>\n<li><code>scale-down</code> 等比缩小。效果类似 <code>contain</code> 或 <code>none</code></li>\n</ul>\n<p>直观一点可以看图: <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit</a></p>\n<h3 id=\"one-more-thing\"><a href=\"#one-more-thing\" class=\"headerlink\" title=\"\bone more thing\"></a>\bone more thing</h3><p>当元素被 <code>object-fit</code> 裁切的时候，你一定想知道如何控制裁切的位置。 所以, <code>object-position</code> 就是为了解决这个问题的。</p>\n<p><code>object-position</code> 不难理解，类似 background-position，不多说。</p>\n<h3 id=\"浏览器兼容\"><a href=\"#浏览器兼容\" class=\"headerlink\" title=\"浏览器兼容\"></a>浏览器兼容</h3><ul>\n<li>IE全部不支持</li>\n<li>Chrome 31+</li>\n<li>Safari 7.1+ </li>\n<li>Firefox 36+</li>\n</ul>\n<hr>\n<h2 id=\"scrollIntoViewIfNeeded\"><a href=\"#scrollIntoViewIfNeeded\" class=\"headerlink\" title=\"scrollIntoViewIfNeeded\"></a>scrollIntoViewIfNeeded</h2><p>缩略图滚动上使用<code>scrollIntoViewIfNeeded</code>,使当前图片保持在视图范围内(\b改变元素的scrollLeft)</p>\n<hr>\n"},{"title":"JS排序算法","subtitle":"数组 排序","author":"Damon","header-img":"post-bg-js-version.jpg","date":"2017-06-16T05:41:37.000Z","_content":"\n## 前言\n\n这篇博文将会写一些自己日常用到的js排序算法.  排序算法一次性写完,个人感觉不太实际,所以会陆续更新比较好.\n\n---\n\n## 代码实现\n\n### 快速排序\n\n```\n/*  输入数组快速排序\n*   @params arr {Array}\n*   @return {Array}\n*/\nfunction quickSort(arr) {\n  while (arr.length <= 1) {\n    return arr\n  }\n\n  let midNumber = Math.floor(arr.length / 2),\n      // 从排序的数组中取出中位元素(splice会修改原来数组)\n      midValue = arr.splice(midNumber,1),\n      left = [],\n      right = []\n\n  for (var i = arr.length - 1; i >= 0; i--) {\n    // 所有元素跟中位元素比较大小, 小于中位数的放在左边数组\n    if (arr[i] < midValue[0]) {\n      left.push(arr[i])\n    } else {\n      right.push(arr[i])\n    }\n  }\n\n  return quickSort(left).concat(midValue,quickSort(right))\n}\n\nvar arr = [2,3,22,11,1]\n\nquickSort(arr)  // [1,2,3,11,22]\n\n```\n\n### Array.prototype.sort()\n\n\nsort() 方法在适当的位置对数组的元素进行排序，并返回数组。默认排序顺序是根据字符串Unicode码点。\nsort(compareFunction) 使用compareFunction进行进阶排序需求。\n\n排序怎么能忘记JS原生的排序方法sort呢?  come on!  二话不说,代码撸起来..\n\n```\nvar fruit = ['cherries', 'apples', 'bananas'];\nfruit.sort();\n// ['apples', 'bananas', 'cherries']\n\nvar scores = [1, 10, 21, 2];\nscores.sort();\n// [1, 10, 2, 21]\n// 注意10在2之前,\n// because '10' comes before '2' in Unicode code point order.\n\nvar things = ['word', 'Word', '1 Word', '2 Words'];\nthings.sort();\n// ['1 Word', '2 Words', 'Word', 'word']\n// 在Unicode中, 数字在大写字母之前,\n// 大写字母在小写字母之前.\n\n```\n\nsort 方法可以使用 函数表达式 方便地书写：\n\n```\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);\n\n// [1, 2, 3, 4, 5]\n\n```\n\n对象可以按照某个属性排序：\n\n```\nvar items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic' },\n  { name: 'Zeros', value: 37 }\n];\n\nitems.sort(function (a, b) {\n  if (a.value > b.value) {\n    return 1;\n  }\n  if (a.value < b.value) {\n    return -1;\n  }\n  // a 必须等于 b\n  return 0;\n});\n\n```\n\ncompareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。\n\n```\n// 需要被排序的数组\nvar list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];\n\n// 对需要排序的元素进行 位置临时存储 和 元素前处理\nvar mapped = list.map((item, i) => (\n { index: i, value: item.toLowerCase() }\n))\n\n// 对处理后的数据进行对个值的排序\nmapped.sort((a, b) => {\n    return +(a.value > b.value) || +(a.value === b.value) - 1\n})\n\n// 根据索引得到排序结果\nlist.map((item) => list[item.index] )\n\n```","source":"_posts/JS实现快速排序.md","raw":"---\ntitle: JS排序算法\nsubtitle: \"数组 排序\"\nauthor: \"Damon\"\nheader-img: \"post-bg-js-version.jpg\"\ndate: 2017-06-16 13:41:37\ntags:\n    - JS\n    - 前端面试\n---\n\n## 前言\n\n这篇博文将会写一些自己日常用到的js排序算法.  排序算法一次性写完,个人感觉不太实际,所以会陆续更新比较好.\n\n---\n\n## 代码实现\n\n### 快速排序\n\n```\n/*  输入数组快速排序\n*   @params arr {Array}\n*   @return {Array}\n*/\nfunction quickSort(arr) {\n  while (arr.length <= 1) {\n    return arr\n  }\n\n  let midNumber = Math.floor(arr.length / 2),\n      // 从排序的数组中取出中位元素(splice会修改原来数组)\n      midValue = arr.splice(midNumber,1),\n      left = [],\n      right = []\n\n  for (var i = arr.length - 1; i >= 0; i--) {\n    // 所有元素跟中位元素比较大小, 小于中位数的放在左边数组\n    if (arr[i] < midValue[0]) {\n      left.push(arr[i])\n    } else {\n      right.push(arr[i])\n    }\n  }\n\n  return quickSort(left).concat(midValue,quickSort(right))\n}\n\nvar arr = [2,3,22,11,1]\n\nquickSort(arr)  // [1,2,3,11,22]\n\n```\n\n### Array.prototype.sort()\n\n\nsort() 方法在适当的位置对数组的元素进行排序，并返回数组。默认排序顺序是根据字符串Unicode码点。\nsort(compareFunction) 使用compareFunction进行进阶排序需求。\n\n排序怎么能忘记JS原生的排序方法sort呢?  come on!  二话不说,代码撸起来..\n\n```\nvar fruit = ['cherries', 'apples', 'bananas'];\nfruit.sort();\n// ['apples', 'bananas', 'cherries']\n\nvar scores = [1, 10, 21, 2];\nscores.sort();\n// [1, 10, 2, 21]\n// 注意10在2之前,\n// because '10' comes before '2' in Unicode code point order.\n\nvar things = ['word', 'Word', '1 Word', '2 Words'];\nthings.sort();\n// ['1 Word', '2 Words', 'Word', 'word']\n// 在Unicode中, 数字在大写字母之前,\n// 大写字母在小写字母之前.\n\n```\n\nsort 方法可以使用 函数表达式 方便地书写：\n\n```\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);\n\n// [1, 2, 3, 4, 5]\n\n```\n\n对象可以按照某个属性排序：\n\n```\nvar items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic' },\n  { name: 'Zeros', value: 37 }\n];\n\nitems.sort(function (a, b) {\n  if (a.value > b.value) {\n    return 1;\n  }\n  if (a.value < b.value) {\n    return -1;\n  }\n  // a 必须等于 b\n  return 0;\n});\n\n```\n\ncompareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。\n\n```\n// 需要被排序的数组\nvar list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];\n\n// 对需要排序的元素进行 位置临时存储 和 元素前处理\nvar mapped = list.map((item, i) => (\n { index: i, value: item.toLowerCase() }\n))\n\n// 对处理后的数据进行对个值的排序\nmapped.sort((a, b) => {\n    return +(a.value > b.value) || +(a.value === b.value) - 1\n})\n\n// 根据索引得到排序结果\nlist.map((item) => list[item.index] )\n\n```","slug":"JS实现快速排序","published":1,"updated":"2017-09-12T10:06:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjagvsnjk00034ouv9ihqeuhc","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇博文将会写一些自己日常用到的js排序算法.  排序算法一次性写完,个人感觉不太实际,所以会陆续更新比较好.</p>\n<hr>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*  输入数组快速排序</span></div><div class=\"line\"><span class=\"comment\">*   @params arr &#123;Array&#125;</span></div><div class=\"line\"><span class=\"comment\">*   @return &#123;Array&#125;</span></div><div class=\"line\"><span class=\"comment\">*/</span></div><div class=\"line\">function <span class=\"built_in\">quickSort</span>(arr) &#123;</div><div class=\"line\">  <span class=\"keyword\">while</span> (arr.length &lt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> midNumber = <span class=\"type\">Math</span>.floor(arr.length / <span class=\"number\">2</span>),</div><div class=\"line\">      <span class=\"comment\">// 从排序的数组中取出中位元素(splice会修改原来数组)</span></div><div class=\"line\">      midValue = arr.splice(midNumber,<span class=\"number\">1</span>),</div><div class=\"line\">      <span class=\"keyword\">left</span> = [],</div><div class=\"line\">      <span class=\"keyword\">right</span> = []</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    <span class=\"comment\">// 所有元素跟中位元素比较大小, 小于中位数的放在左边数组</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &lt; midValue[<span class=\"number\">0</span>]) &#123;</div><div class=\"line\">      <span class=\"keyword\">left</span>.push(arr[i])</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">right</span>.push(arr[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">quickSort</span>(<span class=\"keyword\">left</span>).concat(midValue,<span class=\"built_in\">quickSort</span>(<span class=\"keyword\">right</span>))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">22</span>,<span class=\"number\">11</span>,<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">quickSort</span>(arr)  <span class=\"comment\">// [1,2,3,11,22]</span></div></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-sort\"><a href=\"#Array-prototype-sort\" class=\"headerlink\" title=\"Array.prototype.sort()\"></a>Array.prototype.sort()</h3><p>sort() 方法在适当的位置对数组的元素进行排序，并返回数组。默认排序顺序是根据字符串Unicode码点。<br>sort(compareFunction) 使用compareFunction进行进阶排序需求。</p>\n<p>排序怎么能忘记JS原生的排序方法sort呢?  come on!  二话不说,代码撸起来..</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fruit = [<span class=\"string\">'cherries'</span>, <span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>];</div><div class=\"line\">fruit.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>, <span class=\"string\">'cherries'</span>]</div><div class=\"line\"></div><div class=\"line\">var scores = [<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>];</div><div class=\"line\">scores.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">21</span>]</div><div class=\"line\"><span class=\"regexp\">//</span> 注意<span class=\"number\">10</span>在<span class=\"number\">2</span>之前,</div><div class=\"line\"><span class=\"regexp\">//</span> because <span class=\"string\">'10'</span> comes before <span class=\"string\">'2'</span> <span class=\"keyword\">in</span> Unicode code point order.</div><div class=\"line\"></div><div class=\"line\">var things = [<span class=\"string\">'word'</span>, <span class=\"string\">'Word'</span>, <span class=\"string\">'1 Word'</span>, <span class=\"string\">'2 Words'</span>];</div><div class=\"line\">things.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"string\">'1 Word'</span>, <span class=\"string\">'2 Words'</span>, <span class=\"string\">'Word'</span>, <span class=\"string\">'word'</span>]</div><div class=\"line\"><span class=\"regexp\">//</span> 在Unicode中, 数字在大写字母之前,</div><div class=\"line\"><span class=\"regexp\">//</span> 大写字母在小写字母之前.</div></pre></td></tr></table></figure>\n<p>sort 方法可以使用 函数表达式 方便地书写：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var numbers = [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>];</div><div class=\"line\">numbers.sort((a, b) =&gt; a - b);</div><div class=\"line\">console.log(numbers);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>\n<p>对象可以按照某个属性排序：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var items = [</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Edward'</span>, <span class=\"string\">value:</span> <span class=\"number\">21</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Sharpe'</span>, <span class=\"string\">value:</span> <span class=\"number\">37</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'And'</span>, <span class=\"string\">value:</span> <span class=\"number\">45</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'The'</span>, <span class=\"string\">value:</span> <span class=\"number\">-12</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Magnetic'</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Zeros'</span>, <span class=\"string\">value:</span> <span class=\"number\">37</span> &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">items.sort(function (a, b) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (a.value &gt; b.value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (a.value &lt; b.value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// a 必须等于 b</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>compareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 需要被排序的数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">list</span> = [<span class=\"string\">'Delta'</span>, <span class=\"string\">'alpha'</span>, <span class=\"string\">'CHARLIE'</span>, <span class=\"string\">'bravo'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对需要排序的元素进行 位置临时存储 和 元素前处理</span></div><div class=\"line\"><span class=\"keyword\">var</span> mapped = <span class=\"keyword\">list</span>.map((item, i) =&gt; (</div><div class=\"line\"> &#123; index: i, value: item.toLowerCase() &#125;</div><div class=\"line\">))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对处理后的数据进行对个值的排序</span></div><div class=\"line\">mapped.sort((a, b) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class=\"number\">1</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 根据索引得到排序结果</span></div><div class=\"line\"><span class=\"keyword\">list</span>.map((item) =&gt; <span class=\"keyword\">list</span>[item.index] )</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇博文将会写一些自己日常用到的js排序算法.  排序算法一次性写完,个人感觉不太实际,所以会陆续更新比较好.</p>\n<hr>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*  输入数组快速排序</span></div><div class=\"line\"><span class=\"comment\">*   @params arr &#123;Array&#125;</span></div><div class=\"line\"><span class=\"comment\">*   @return &#123;Array&#125;</span></div><div class=\"line\"><span class=\"comment\">*/</span></div><div class=\"line\">function <span class=\"built_in\">quickSort</span>(arr) &#123;</div><div class=\"line\">  <span class=\"keyword\">while</span> (arr.length &lt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> midNumber = <span class=\"type\">Math</span>.floor(arr.length / <span class=\"number\">2</span>),</div><div class=\"line\">      <span class=\"comment\">// 从排序的数组中取出中位元素(splice会修改原来数组)</span></div><div class=\"line\">      midValue = arr.splice(midNumber,<span class=\"number\">1</span>),</div><div class=\"line\">      <span class=\"keyword\">left</span> = [],</div><div class=\"line\">      <span class=\"keyword\">right</span> = []</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">    <span class=\"comment\">// 所有元素跟中位元素比较大小, 小于中位数的放在左边数组</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &lt; midValue[<span class=\"number\">0</span>]) &#123;</div><div class=\"line\">      <span class=\"keyword\">left</span>.push(arr[i])</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">right</span>.push(arr[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">quickSort</span>(<span class=\"keyword\">left</span>).concat(midValue,<span class=\"built_in\">quickSort</span>(<span class=\"keyword\">right</span>))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">22</span>,<span class=\"number\">11</span>,<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">quickSort</span>(arr)  <span class=\"comment\">// [1,2,3,11,22]</span></div></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-sort\"><a href=\"#Array-prototype-sort\" class=\"headerlink\" title=\"Array.prototype.sort()\"></a>Array.prototype.sort()</h3><p>sort() 方法在适当的位置对数组的元素进行排序，并返回数组。默认排序顺序是根据字符串Unicode码点。<br>sort(compareFunction) 使用compareFunction进行进阶排序需求。</p>\n<p>排序怎么能忘记JS原生的排序方法sort呢?  come on!  二话不说,代码撸起来..</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fruit = [<span class=\"string\">'cherries'</span>, <span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>];</div><div class=\"line\">fruit.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>, <span class=\"string\">'cherries'</span>]</div><div class=\"line\"></div><div class=\"line\">var scores = [<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>];</div><div class=\"line\">scores.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">21</span>]</div><div class=\"line\"><span class=\"regexp\">//</span> 注意<span class=\"number\">10</span>在<span class=\"number\">2</span>之前,</div><div class=\"line\"><span class=\"regexp\">//</span> because <span class=\"string\">'10'</span> comes before <span class=\"string\">'2'</span> <span class=\"keyword\">in</span> Unicode code point order.</div><div class=\"line\"></div><div class=\"line\">var things = [<span class=\"string\">'word'</span>, <span class=\"string\">'Word'</span>, <span class=\"string\">'1 Word'</span>, <span class=\"string\">'2 Words'</span>];</div><div class=\"line\">things.sort();</div><div class=\"line\"><span class=\"regexp\">//</span> [<span class=\"string\">'1 Word'</span>, <span class=\"string\">'2 Words'</span>, <span class=\"string\">'Word'</span>, <span class=\"string\">'word'</span>]</div><div class=\"line\"><span class=\"regexp\">//</span> 在Unicode中, 数字在大写字母之前,</div><div class=\"line\"><span class=\"regexp\">//</span> 大写字母在小写字母之前.</div></pre></td></tr></table></figure>\n<p>sort 方法可以使用 函数表达式 方便地书写：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var numbers = [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>];</div><div class=\"line\">numbers.sort((a, b) =&gt; a - b);</div><div class=\"line\">console.log(numbers);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>\n<p>对象可以按照某个属性排序：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var items = [</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Edward'</span>, <span class=\"string\">value:</span> <span class=\"number\">21</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Sharpe'</span>, <span class=\"string\">value:</span> <span class=\"number\">37</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'And'</span>, <span class=\"string\">value:</span> <span class=\"number\">45</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'The'</span>, <span class=\"string\">value:</span> <span class=\"number\">-12</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Magnetic'</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"string\">name:</span> <span class=\"string\">'Zeros'</span>, <span class=\"string\">value:</span> <span class=\"number\">37</span> &#125;</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\">items.sort(function (a, b) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (a.value &gt; b.value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (a.value &lt; b.value) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// a 必须等于 b</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>compareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 需要被排序的数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">list</span> = [<span class=\"string\">'Delta'</span>, <span class=\"string\">'alpha'</span>, <span class=\"string\">'CHARLIE'</span>, <span class=\"string\">'bravo'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对需要排序的元素进行 位置临时存储 和 元素前处理</span></div><div class=\"line\"><span class=\"keyword\">var</span> mapped = <span class=\"keyword\">list</span>.map((item, i) =&gt; (</div><div class=\"line\"> &#123; index: i, value: item.toLowerCase() &#125;</div><div class=\"line\">))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对处理后的数据进行对个值的排序</span></div><div class=\"line\">mapped.sort((a, b) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class=\"number\">1</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 根据索引得到排序结果</span></div><div class=\"line\"><span class=\"keyword\">list</span>.map((item) =&gt; <span class=\"keyword\">list</span>[item.index] )</div></pre></td></tr></table></figure>"},{"title":"JS深复制与浅复制","subtitle":"深复制函数实现","date":"2017-07-03T02:00:53.000Z","author":"Damon","header-img":"/img/about-bg.jpg","_content":"\n## 前言\n\n前段时间学习函数式编程,里面有一个重要的概念就是,函数永远不要对数据作修改。 不修改数据，意味着输入一个变量，经过计算后返回的永远都是一个新的变量。 这么做的好处是让数据可以进行所谓的时间旅行，在任何的时间可以回溯到系统的之前的任意状态，而不引起副作用。\n\nwell！ 复制JS的基本数据类型，再简单不过了，直接创建一个新变量然后进行赋值，这么做就完成简单赋值. 如下:\n```\nvar foo = 'go';\nvar copy = foo; \nfoo = 'gooooooo';\nconsole.log(copy)   // 'go'\n```\n但是,如果复制对象不是基本数据类型,那么就会就会出现以下状况:\n```\nvar object = { obj: { a: 1, b: 2 } };\nvar copy = object;\nobject.obj.a = 100\nconsole.log(copy)   //  { obj: { a: 100, b: 2 } }\n```\n由此可见, copy.obj 只是对object.obj 的一个引用。(这就是浅复制)   \n这并不是我们所期待的结果.我们想要的是,copy对象与object之间再没有任何关系,无论我们怎么修改object。\n所以,这就产生了深复制的需求(复制品 与 被复制品的数据完全独立,修改其中一个对象不会改变另外一个对象)。\n\n## 实现\n\n前面,介绍浅复制和深复制。JS原生没有实现深复制的api,所以只能我们自己造轮子。（万恶的javascript,为什么就没有深复制api呢... 可能是为了省点内存吧?）\n```\nfunction deepClone(obj) {\n    if (typeof obj !== 'object') {\n        return obj\n    }\n    var newObj = Array.isArray(obj) ? [] : {}\n\n    for (var key in obj) {\n        var val = obj[key]\n        if (typeof obj[key] === 'object') {\n            newObj[key] = deepClone(val)\n        } else {\n            newObj[key] = val\n        }\n    }\n    return newObj\n}\n\nvar src = { ss: { w: 1 }, j: [1, { s: 3, j: [2, 4] }] }\nvar copy = deepClone(src)\n\nsrc.ss.w = 444\ncopy.ss.w = '真的6'\nconsole.log(JSON.stringify(src))    // { ss: { w: 444 }, j: [1, { s: 3, j: [2, 4] }] }\nconsole.log(JSON.stringify(copy))   // { ss: { w: '真的6' }, j: [1, { s: 3, j: [2, 4] }] }\n```\n嗯. 以上可以看到复制品和被复制品之间,相互是独立的. 这样我们就可以放心操作他们修改他们,而不必担心任何副作用了(除了多占浏览器一丁点内存外).","source":"_posts/JS深复制与浅复制.md","raw":"---\ntitle: JS深复制与浅复制\nsubtitle: 深复制函数实现\ndate: 2017-07-03 10:00:53\nauthor: \"Damon\"\nheader-img: \"/img/about-bg.jpg\"\ntags:\n    - JS\n    - 前端面试\n---\n\n## 前言\n\n前段时间学习函数式编程,里面有一个重要的概念就是,函数永远不要对数据作修改。 不修改数据，意味着输入一个变量，经过计算后返回的永远都是一个新的变量。 这么做的好处是让数据可以进行所谓的时间旅行，在任何的时间可以回溯到系统的之前的任意状态，而不引起副作用。\n\nwell！ 复制JS的基本数据类型，再简单不过了，直接创建一个新变量然后进行赋值，这么做就完成简单赋值. 如下:\n```\nvar foo = 'go';\nvar copy = foo; \nfoo = 'gooooooo';\nconsole.log(copy)   // 'go'\n```\n但是,如果复制对象不是基本数据类型,那么就会就会出现以下状况:\n```\nvar object = { obj: { a: 1, b: 2 } };\nvar copy = object;\nobject.obj.a = 100\nconsole.log(copy)   //  { obj: { a: 100, b: 2 } }\n```\n由此可见, copy.obj 只是对object.obj 的一个引用。(这就是浅复制)   \n这并不是我们所期待的结果.我们想要的是,copy对象与object之间再没有任何关系,无论我们怎么修改object。\n所以,这就产生了深复制的需求(复制品 与 被复制品的数据完全独立,修改其中一个对象不会改变另外一个对象)。\n\n## 实现\n\n前面,介绍浅复制和深复制。JS原生没有实现深复制的api,所以只能我们自己造轮子。（万恶的javascript,为什么就没有深复制api呢... 可能是为了省点内存吧?）\n```\nfunction deepClone(obj) {\n    if (typeof obj !== 'object') {\n        return obj\n    }\n    var newObj = Array.isArray(obj) ? [] : {}\n\n    for (var key in obj) {\n        var val = obj[key]\n        if (typeof obj[key] === 'object') {\n            newObj[key] = deepClone(val)\n        } else {\n            newObj[key] = val\n        }\n    }\n    return newObj\n}\n\nvar src = { ss: { w: 1 }, j: [1, { s: 3, j: [2, 4] }] }\nvar copy = deepClone(src)\n\nsrc.ss.w = 444\ncopy.ss.w = '真的6'\nconsole.log(JSON.stringify(src))    // { ss: { w: 444 }, j: [1, { s: 3, j: [2, 4] }] }\nconsole.log(JSON.stringify(copy))   // { ss: { w: '真的6' }, j: [1, { s: 3, j: [2, 4] }] }\n```\n嗯. 以上可以看到复制品和被复制品之间,相互是独立的. 这样我们就可以放心操作他们修改他们,而不必担心任何副作用了(除了多占浏览器一丁点内存外).","slug":"JS深复制与浅复制","published":1,"updated":"2017-09-12T10:06:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjagvsnjn00064ouvrnyqpbph","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前段时间学习函数式编程,里面有一个重要的概念就是,函数永远不要对数据作修改。 不修改数据，意味着输入一个变量，经过计算后返回的永远都是一个新的变量。 这么做的好处是让数据可以进行所谓的时间旅行，在任何的时间可以回溯到系统的之前的任意状态，而不引起副作用。</p>\n<p>well！ 复制JS的基本数据类型，再简单不过了，直接创建一个新变量然后进行赋值，这么做就完成简单赋值. 如下:<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = <span class=\"string\">'go'</span>;</div><div class=\"line\">var <span class=\"keyword\">copy</span><span class=\"bash\"> = foo; </span></div><div class=\"line\"><span class=\"bash\">foo = <span class=\"string\">'gooooooo'</span>;</span></div><div class=\"line\"><span class=\"bash\">console.log(copy)   // <span class=\"string\">'go'</span></span></div></pre></td></tr></table></figure></p>\n<p>但是,如果复制对象不是基本数据类型,那么就会就会出现以下状况:<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"class\"><span class=\"keyword\">object</span> </span>= &#123; obj: &#123; a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span> &#125; &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> copy = <span class=\"class\"><span class=\"keyword\">object</span></span>;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span>.<span class=\"title\">obj</span>.<span class=\"title\">a</span> </span>= <span class=\"number\">100</span></div><div class=\"line\">console.log(copy)   <span class=\"comment\">//  &#123; obj: &#123; a: 100, b: 2 &#125; &#125;</span></div></pre></td></tr></table></figure></p>\n<p>由此可见, copy.obj 只是对object.obj 的一个引用。(这就是浅复制)<br>这并不是我们所期待的结果.我们想要的是,copy对象与object之间再没有任何关系,无论我们怎么修改object。<br>所以,这就产生了深复制的需求(复制品 与 被复制品的数据完全独立,修改其中一个对象不会改变另外一个对象)。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>前面,介绍浅复制和深复制。JS原生没有实现深复制的api,所以只能我们自己造轮子。（万恶的javascript,为什么就没有深复制api呢… 可能是为了省点内存吧?）<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span></span>(obj) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (typeof obj !== <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> obj</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Obj</span> = <span class=\"keyword\">Array</span>.isArray(obj) ? [] : <span class=\"type\"></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> val = obj[key]</div><div class=\"line\">        <span class=\"keyword\">if</span> (typeof obj[key] === <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">new</span><span class=\"type\">Obj</span>[key] = deepClone(val)</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">new</span><span class=\"type\">Obj</span>[key] = val</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span><span class=\"type\">Obj</span></div><div class=\"line\"><span class=\"type\"></span>&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> src = &#123; ss: <span class=\"type\"></span>&#123; w: <span class=\"type\">1 </span>&#125;, j: <span class=\"type\"></span>[<span class=\"number\">1</span>, &#123; s: <span class=\"type\">3</span>, j: <span class=\"type\"></span>[<span class=\"number\">2</span>, <span class=\"number\">4</span>] &#125;] &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> copy = deepClone(src)</div><div class=\"line\"></div><div class=\"line\">src.ss.w = <span class=\"number\">444</span></div><div class=\"line\">copy.ss.w = <span class=\"string\">'真的6'</span></div><div class=\"line\">console.log(JSON.stringify(src))    <span class=\"comment\">// &#123; ss: &#123; w: 444 &#125;, j: [1, &#123; s: 3, j: [2, 4] &#125;] &#125;</span></div><div class=\"line\">console.log(JSON.stringify(copy))   <span class=\"comment\">// &#123; ss: &#123; w: '真的6' &#125;, j: [1, &#123; s: 3, j: [2, 4] &#125;] &#125;</span></div></pre></td></tr></table></figure></p>\n<p>嗯. 以上可以看到复制品和被复制品之间,相互是独立的. 这样我们就可以放心操作他们修改他们,而不必担心任何副作用了(除了多占浏览器一丁点内存外).</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前段时间学习函数式编程,里面有一个重要的概念就是,函数永远不要对数据作修改。 不修改数据，意味着输入一个变量，经过计算后返回的永远都是一个新的变量。 这么做的好处是让数据可以进行所谓的时间旅行，在任何的时间可以回溯到系统的之前的任意状态，而不引起副作用。</p>\n<p>well！ 复制JS的基本数据类型，再简单不过了，直接创建一个新变量然后进行赋值，这么做就完成简单赋值. 如下:<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = <span class=\"string\">'go'</span>;</div><div class=\"line\">var <span class=\"keyword\">copy</span><span class=\"bash\"> = foo; </span></div><div class=\"line\"><span class=\"bash\">foo = <span class=\"string\">'gooooooo'</span>;</span></div><div class=\"line\"><span class=\"bash\">console.log(copy)   // <span class=\"string\">'go'</span></span></div></pre></td></tr></table></figure></p>\n<p>但是,如果复制对象不是基本数据类型,那么就会就会出现以下状况:<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"class\"><span class=\"keyword\">object</span> </span>= &#123; obj: &#123; a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span> &#125; &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> copy = <span class=\"class\"><span class=\"keyword\">object</span></span>;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span>.<span class=\"title\">obj</span>.<span class=\"title\">a</span> </span>= <span class=\"number\">100</span></div><div class=\"line\">console.log(copy)   <span class=\"comment\">//  &#123; obj: &#123; a: 100, b: 2 &#125; &#125;</span></div></pre></td></tr></table></figure></p>\n<p>由此可见, copy.obj 只是对object.obj 的一个引用。(这就是浅复制)<br>这并不是我们所期待的结果.我们想要的是,copy对象与object之间再没有任何关系,无论我们怎么修改object。<br>所以,这就产生了深复制的需求(复制品 与 被复制品的数据完全独立,修改其中一个对象不会改变另外一个对象)。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>前面,介绍浅复制和深复制。JS原生没有实现深复制的api,所以只能我们自己造轮子。（万恶的javascript,为什么就没有深复制api呢… 可能是为了省点内存吧?）<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span></span>(obj) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (typeof obj !== <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> obj</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Obj</span> = <span class=\"keyword\">Array</span>.isArray(obj) ? [] : <span class=\"type\"></span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> val = obj[key]</div><div class=\"line\">        <span class=\"keyword\">if</span> (typeof obj[key] === <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">new</span><span class=\"type\">Obj</span>[key] = deepClone(val)</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">new</span><span class=\"type\">Obj</span>[key] = val</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span><span class=\"type\">Obj</span></div><div class=\"line\"><span class=\"type\"></span>&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> src = &#123; ss: <span class=\"type\"></span>&#123; w: <span class=\"type\">1 </span>&#125;, j: <span class=\"type\"></span>[<span class=\"number\">1</span>, &#123; s: <span class=\"type\">3</span>, j: <span class=\"type\"></span>[<span class=\"number\">2</span>, <span class=\"number\">4</span>] &#125;] &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> copy = deepClone(src)</div><div class=\"line\"></div><div class=\"line\">src.ss.w = <span class=\"number\">444</span></div><div class=\"line\">copy.ss.w = <span class=\"string\">'真的6'</span></div><div class=\"line\">console.log(JSON.stringify(src))    <span class=\"comment\">// &#123; ss: &#123; w: 444 &#125;, j: [1, &#123; s: 3, j: [2, 4] &#125;] &#125;</span></div><div class=\"line\">console.log(JSON.stringify(copy))   <span class=\"comment\">// &#123; ss: &#123; w: '真的6' &#125;, j: [1, &#123; s: 3, j: [2, 4] &#125;] &#125;</span></div></pre></td></tr></table></figure></p>\n<p>嗯. 以上可以看到复制品和被复制品之间,相互是独立的. 这样我们就可以放心操作他们修改他们,而不必担心任何副作用了(除了多占浏览器一丁点内存外).</p>\n"},{"layout":"post","title":"About Javascript","date":"2017-03-22T16:00:00.000Z","author":"chaoming","header-img":"post-bg-js-version.jpg","_content":"\n\nJavaScript 有着很奇怪的命名史。\n\n1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript *（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）*\n\n![java-javascript](javascript-java.jpg)\n<small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small>\n\n> 译者注：[wikipedia 的 JavaScript 词条](https://en.wikipedia.org/wiki/JavaScript#History) 更详细的叙述了这段历史\n\n1996 年，网景将 JavaScript 提交给 [ECMA International（欧洲计算机制造商协会）](http://www.ecma-international.org/) 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。\n\n\n> 术语（译者注）：\n>\n> * *标准（Standard）*： 用于定义与其他事物区别的一套规则\n> * *实现（Implementation）*： 某个标准的具体实施/真实实践\n\n\n不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。\n\n> 译者注：[ECMAScript 第四版草案](https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29)由于太过激进而被抛弃，Adobe 的 [ActionScript 3.0](https://en.wikipedia.org/wiki/ActionScript) 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）\n\n到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）\n\n目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 [decorators（装饰者）](https://github.com/wycats/javascript-decorators)，[async-await（async-await 异步编程模型）](https://github.com/lukehoban/ecmascript-asyncawait) 和 [static class properties（静态类属性）](https://github.com/jeffmo/es-class-properties)。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 [Babel 的官网](https://babeljs.io/docs/usage/experimental/) 上查看各个提案目前都在哪个阶段了。\n\n所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：\n\n* **ECMAScript**：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。\n* **JavaScript**：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。\n* **ECMAScript 5 (ES5)**：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。\n* **ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)**：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅[这张兼容性表](http://kangax.github.io/compat-table/es6/)来查看不同浏览器和工具的实现情况。\n* **ECMAScript 2016**：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定\n* **ECMAScript Proposals**：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。\n\n在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。\n\n#### 一些资源\n\n\n\n* TC39 的 [Github 仓库](https://github.com/tc39/ecma262)上可以看到所有目前公开的提案\n* 如果你还不熟悉 ES6，Babel 有一个[很不错的特性概览](https://babeljs.io/docs/learn-es2015/)\n* 如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 [Exploring ES6](http://exploringjs.com/)和 Nicholas Zakas 的 [Understanding ECMAScript 6](https://leanpub.com/understandinges6)。Axel 的博客 [2ality](http://www.2ality.com/) 也是很不错的 ES6 资源\n\n<img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\" />\n<small class=\"img-hint\">来学 JavaScript 吧！</small>\n\n#### 著作权声明\n\n本文译自 [ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?](http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/)\n译者 [黄玄](http://weibo.com/huxpro)，转载请保留以上链接。\n学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。\n\n\n","source":"_posts/about-javascript.md","raw":"---\nlayout:     post\ntitle:      \"About Javascript\"\ndate:       2017-03-23\nauthor:     \"chaoming\"\nheader-img: \"post-bg-js-version.jpg\"\ntags:\n    - JavaScript\n    - 翻译\n---\n\n\nJavaScript 有着很奇怪的命名史。\n\n1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript *（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）*\n\n![java-javascript](javascript-java.jpg)\n<small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small>\n\n> 译者注：[wikipedia 的 JavaScript 词条](https://en.wikipedia.org/wiki/JavaScript#History) 更详细的叙述了这段历史\n\n1996 年，网景将 JavaScript 提交给 [ECMA International（欧洲计算机制造商协会）](http://www.ecma-international.org/) 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。\n\n\n> 术语（译者注）：\n>\n> * *标准（Standard）*： 用于定义与其他事物区别的一套规则\n> * *实现（Implementation）*： 某个标准的具体实施/真实实践\n\n\n不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。\n\n> 译者注：[ECMAScript 第四版草案](https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29)由于太过激进而被抛弃，Adobe 的 [ActionScript 3.0](https://en.wikipedia.org/wiki/ActionScript) 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）\n\n到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）\n\n目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 [decorators（装饰者）](https://github.com/wycats/javascript-decorators)，[async-await（async-await 异步编程模型）](https://github.com/lukehoban/ecmascript-asyncawait) 和 [static class properties（静态类属性）](https://github.com/jeffmo/es-class-properties)。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 [Babel 的官网](https://babeljs.io/docs/usage/experimental/) 上查看各个提案目前都在哪个阶段了。\n\n所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：\n\n* **ECMAScript**：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。\n* **JavaScript**：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。\n* **ECMAScript 5 (ES5)**：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。\n* **ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)**：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅[这张兼容性表](http://kangax.github.io/compat-table/es6/)来查看不同浏览器和工具的实现情况。\n* **ECMAScript 2016**：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定\n* **ECMAScript Proposals**：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。\n\n在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。\n\n#### 一些资源\n\n\n\n* TC39 的 [Github 仓库](https://github.com/tc39/ecma262)上可以看到所有目前公开的提案\n* 如果你还不熟悉 ES6，Babel 有一个[很不错的特性概览](https://babeljs.io/docs/learn-es2015/)\n* 如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 [Exploring ES6](http://exploringjs.com/)和 Nicholas Zakas 的 [Understanding ECMAScript 6](https://leanpub.com/understandinges6)。Axel 的博客 [2ality](http://www.2ality.com/) 也是很不错的 ES6 资源\n\n<img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\" />\n<small class=\"img-hint\">来学 JavaScript 吧！</small>\n\n#### 著作权声明\n\n本文译自 [ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?](http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/)\n译者 [黄玄](http://weibo.com/huxpro)，转载请保留以上链接。\n学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。\n\n\n","slug":"about-javascript","published":1,"updated":"2017-09-12T10:06:06.000Z","comments":1,"photos":[],"link":"","_id":"cjagvsnjo00084ouvxa04z9tz","content":"<p>JavaScript 有着很奇怪的命名史。</p>\n<p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p>\n<p><img src=\"javascript-java.jpg\" alt=\"java-javascript\"><br><small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small></p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/JavaScript#History\" target=\"_blank\" rel=\"external\">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p>\n</blockquote>\n<p>1996 年，网景将 JavaScript 提交给 <a href=\"http://www.ecma-international.org/\" target=\"_blank\" rel=\"external\">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p>\n<blockquote>\n<p>术语（译者注）：</p>\n<ul>\n<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>\n<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>\n</ul>\n</blockquote>\n<p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29\" target=\"_blank\" rel=\"external\">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href=\"https://en.wikipedia.org/wiki/ActionScript\" target=\"_blank\" rel=\"external\">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p>\n</blockquote>\n<p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p>\n<p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href=\"https://github.com/wycats/javascript-decorators\" target=\"_blank\" rel=\"external\">decorators（装饰者）</a>，<a href=\"https://github.com/lukehoban/ecmascript-asyncawait\" target=\"_blank\" rel=\"external\">async-await（async-await 异步编程模型）</a> 和 <a href=\"https://github.com/jeffmo/es-class-properties\" target=\"_blank\" rel=\"external\">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href=\"https://babeljs.io/docs/usage/experimental/\" target=\"_blank\" rel=\"external\">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p>\n<p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p>\n<ul>\n<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>\n<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>\n<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>\n<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"external\">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>\n<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>\n<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>\n</ul>\n<p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p>\n<h4 id=\"一些资源\"><a href=\"#一些资源\" class=\"headerlink\" title=\"一些资源\"></a>一些资源</h4><ul>\n<li>TC39 的 <a href=\"https://github.com/tc39/ecma262\" target=\"_blank\" rel=\"external\">Github 仓库</a>上可以看到所有目前公开的提案</li>\n<li>如果你还不熟悉 ES6，Babel 有一个<a href=\"https://babeljs.io/docs/learn-es2015/\" target=\"_blank\" rel=\"external\">很不错的特性概览</a></li>\n<li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href=\"http://exploringjs.com/\" target=\"_blank\" rel=\"external\">Exploring ES6</a>和 Nicholas Zakas 的 <a href=\"https://leanpub.com/understandinges6\" target=\"_blank\" rel=\"external\">Understanding ECMAScript 6</a>。Axel 的博客 <a href=\"http://www.2ality.com/\" target=\"_blank\" rel=\"external\">2ality</a> 也是很不错的 ES6 资源</li>\n</ul>\n<p><img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\"><br><small class=\"img-hint\">来学 JavaScript 吧！</small></p>\n<h4 id=\"著作权声明\"><a href=\"#著作权声明\" class=\"headerlink\" title=\"著作权声明\"></a>著作权声明</h4><p>本文译自 <a href=\"http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/\" target=\"_blank\" rel=\"external\">ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?</a><br>译者 <a href=\"http://weibo.com/huxpro\" target=\"_blank\" rel=\"external\">黄玄</a>，转载请保留以上链接。<br>学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript 有着很奇怪的命名史。</p>\n<p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p>\n<p><img src=\"javascript-java.jpg\" alt=\"java-javascript\"><br><small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small></p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/JavaScript#History\" target=\"_blank\" rel=\"external\">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p>\n</blockquote>\n<p>1996 年，网景将 JavaScript 提交给 <a href=\"http://www.ecma-international.org/\" target=\"_blank\" rel=\"external\">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p>\n<blockquote>\n<p>术语（译者注）：</p>\n<ul>\n<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>\n<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>\n</ul>\n</blockquote>\n<p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29\" target=\"_blank\" rel=\"external\">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href=\"https://en.wikipedia.org/wiki/ActionScript\" target=\"_blank\" rel=\"external\">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p>\n</blockquote>\n<p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p>\n<p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href=\"https://github.com/wycats/javascript-decorators\" target=\"_blank\" rel=\"external\">decorators（装饰者）</a>，<a href=\"https://github.com/lukehoban/ecmascript-asyncawait\" target=\"_blank\" rel=\"external\">async-await（async-await 异步编程模型）</a> 和 <a href=\"https://github.com/jeffmo/es-class-properties\" target=\"_blank\" rel=\"external\">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href=\"https://babeljs.io/docs/usage/experimental/\" target=\"_blank\" rel=\"external\">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p>\n<p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p>\n<ul>\n<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>\n<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>\n<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>\n<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"external\">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>\n<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>\n<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>\n</ul>\n<p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p>\n<h4 id=\"一些资源\"><a href=\"#一些资源\" class=\"headerlink\" title=\"一些资源\"></a>一些资源</h4><ul>\n<li>TC39 的 <a href=\"https://github.com/tc39/ecma262\" target=\"_blank\" rel=\"external\">Github 仓库</a>上可以看到所有目前公开的提案</li>\n<li>如果你还不熟悉 ES6，Babel 有一个<a href=\"https://babeljs.io/docs/learn-es2015/\" target=\"_blank\" rel=\"external\">很不错的特性概览</a></li>\n<li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href=\"http://exploringjs.com/\" target=\"_blank\" rel=\"external\">Exploring ES6</a>和 Nicholas Zakas 的 <a href=\"https://leanpub.com/understandinges6\" target=\"_blank\" rel=\"external\">Understanding ECMAScript 6</a>。Axel 的博客 <a href=\"http://www.2ality.com/\" target=\"_blank\" rel=\"external\">2ality</a> 也是很不错的 ES6 资源</li>\n</ul>\n<p><img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\"><br><small class=\"img-hint\">来学 JavaScript 吧！</small></p>\n<h4 id=\"著作权声明\"><a href=\"#著作权声明\" class=\"headerlink\" title=\"著作权声明\"></a>著作权声明</h4><p>本文译自 <a href=\"http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/\" target=\"_blank\" rel=\"external\">ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?</a><br>译者 <a href=\"http://weibo.com/huxpro\" target=\"_blank\" rel=\"external\">黄玄</a>，转载请保留以上链接。<br>学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。</p>\n"},{"layout":"post","title":"Welcome to Chaoming Blog","subtitle":" \"Hello World, Hello Blog\"","date":"2017-03-18T03:23:26.000Z","author":"Damon","header-img":"post-bg-unix-linux.jpg","_content":"\n> “Yeah It's on. ”\n\n\n## 前言\n\nChaoming 的 Blog 就这么开通了。\n\n[跳过废话，直接看技术实现 ](#build)\n\n\n\n2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。\n\n\n作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。\n\n这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!\n<p id = \"build\"></p>\n---\n\n## 正文\n\n接下来说说搭建这个博客的技术细节。  \n\nHexo其优点非常明显：\n\n* **Markdown** 带来的优雅写作体验\n* 非常熟悉的 Git workflow ，**Git Commit 即 Blog Post**\n* 利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机\n    * 如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了\n\n\n本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个[镜像](http://huxpro.gitcafe.io)出来，结果还是巨慢。\n\n哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 **pending 在了 Google Fonts** 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。  \n忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!\n\n---\n\n配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。\n\nTheme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接**hexo d**提交到自己github上。这真的超级方便！瞬间爱上Hexo！\n\n不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用**hexo d**提交代码的时候就出事了,直接报错&%$*&^*%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。\n\n最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。\n\n以后，好好说话呗。。。\n\n\n\n","source":"_posts/hello-blog.md","raw":"---\nlayout:     post\ntitle:      \"Welcome to Chaoming Blog\"\nsubtitle:   \" \\\"Hello World, Hello Blog\\\"\"\ndate:       2017-03-18 11:23:26\nauthor:     \"Damon\"\nheader-img: \"post-bg-unix-linux.jpg\"\ntags:\n    - 生活\n---\n\n> “Yeah It's on. ”\n\n\n## 前言\n\nChaoming 的 Blog 就这么开通了。\n\n[跳过废话，直接看技术实现 ](#build)\n\n\n\n2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。\n\n\n作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。\n\n这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!\n<p id = \"build\"></p>\n---\n\n## 正文\n\n接下来说说搭建这个博客的技术细节。  \n\nHexo其优点非常明显：\n\n* **Markdown** 带来的优雅写作体验\n* 非常熟悉的 Git workflow ，**Git Commit 即 Blog Post**\n* 利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机\n    * 如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了\n\n\n本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个[镜像](http://huxpro.gitcafe.io)出来，结果还是巨慢。\n\n哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 **pending 在了 Google Fonts** 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。  \n忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!\n\n---\n\n配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。\n\nTheme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接**hexo d**提交到自己github上。这真的超级方便！瞬间爱上Hexo！\n\n不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用**hexo d**提交代码的时候就出事了,直接报错&%$*&^*%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。\n\n最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。\n\n以后，好好说话呗。。。\n\n\n\n","slug":"hello-blog","published":1,"updated":"2017-09-12T10:06:06.000Z","comments":1,"photos":[],"link":"","_id":"cjagvsnjp00094ouv4ki5t0nz","content":"<blockquote>\n<p>“Yeah It’s on. ”</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Chaoming 的 Blog 就这么开通了。</p>\n<p><a href=\"#build\">跳过废话，直接看技术实现 </a></p>\n<p>2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。</p>\n<p>作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。</p>\n<p>这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p id=\"build\"></p></h2><h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p>\n<p>Hexo其优点非常明显：</p>\n<ul>\n<li><strong>Markdown</strong> 带来的优雅写作体验</li>\n<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>\n<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机<ul>\n<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li>\n</ul>\n</li>\n</ul>\n<p>本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个<a href=\"http://huxpro.gitcafe.io\" target=\"_blank\" rel=\"external\">镜像</a>出来，结果还是巨慢。</p>\n<p>哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 <strong>pending 在了 Google Fonts</strong> 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。<br>忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!</p>\n<hr>\n<p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。</p>\n<p>Theme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接<strong>hexo d</strong>提交到自己github上。这真的超级方便！瞬间爱上Hexo！</p>\n<p>不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用<strong>hexo d</strong>提交代码的时候就出事了,直接报错&amp;%$<em>&amp;^</em>%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。</p>\n<p>最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。</p>\n<p>以后，好好说话呗。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>“Yeah It’s on. ”</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Chaoming 的 Blog 就这么开通了。</p>\n<p><a href=\"#build\">跳过废话，直接看技术实现 </a></p>\n<p>2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。</p>\n<p>作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。</p>\n<p>这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p id=\"build\"></p></h2><h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p>\n<p>Hexo其优点非常明显：</p>\n<ul>\n<li><strong>Markdown</strong> 带来的优雅写作体验</li>\n<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>\n<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机<ul>\n<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li>\n</ul>\n</li>\n</ul>\n<p>本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个<a href=\"http://huxpro.gitcafe.io\" target=\"_blank\" rel=\"external\">镜像</a>出来，结果还是巨慢。</p>\n<p>哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 <strong>pending 在了 Google Fonts</strong> 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。<br>忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!</p>\n<hr>\n<p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。</p>\n<p>Theme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接<strong>hexo d</strong>提交到自己github上。这真的超级方便！瞬间爱上Hexo！</p>\n<p>不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用<strong>hexo d</strong>提交代码的时候就出事了,直接报错&amp;%$<em>&amp;^</em>%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。</p>\n<p>最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。</p>\n<p>以后，好好说话呗。。。</p>\n"},{"layout":"post","title":"JS模块加载","subtitle":"CommonJS，RequireJS，SeaJS 归纳笔记","date":"2017-03-23T14:45:58.000Z","author":"Damon","catalog":true,"header-img":"post-bg-js-module.jpg","_content":"\n\n\n## Foreword\n\n> Here comes Module!\n\n随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。\n\n于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。\n\n\n---\n\n## Catalog\n\n\n1.  [CommonJS & Node](#commonjs--node)\n3.  [History](#history)\n4.  [RequireJS & AMD](#requirejs--amd)\n5.  [SeaJS & CMD](#seajs--cmd)\n6.  [AMD vs CMD](#amd-vs-cmd)\n7.  [WebPack](#webpack)\n\n\n\n```\nfunction autoDetect(){\n    console.log('ye, it is written in JavaScript!')\n}\n```\n\n## CommonJS & Node\n\n> Javascript: not just for browsers any more! —— CommonJS Slogen\n\n前端模块化的事实标准之一，2009 年 8 月，[CommonJS](http://wiki.commonjs.org/wiki/CommonJS) 诞生。\n\nCommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。\n\n\n让我们看看 Node 中的实现：\n{% codeblock lang:js %}\n// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper\n// \"as though the module was wrapped in a function\"\n\nvar a = require('./a')  // 加载模块（同步加载）\na.doSomething()         // 等上一句执行完才会执行\n\nexports.b = function(){ // 暴露 b 函数接口\n  // do something\n}\n{% endcodeblock %}\n\n\n`exports`是一个内置对象，就像`require`是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写`module.exports`就可以了。\n\nCommonJS 前身叫 ServerJS ，**后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS** 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。\n\n\n因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：\n\n* 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）\n* 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。\n* 都在向着 **COMMON** 的方向进化：**兼容不同风格，兼容浏览器和服务器两种环境**\n\n本文接下来要讨论的典例是：\n\n* RequireJS & AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）\n* SeaJS & CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）\n\n\n\n\n\n## History\n\n<!--<h2 id=\"history\"> History </h2>-->\n\n> 此段落参考自玉伯的 [前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588)\n\n09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 [Modules/1.0](http://wiki.commonjs.org/wiki/Modules) 规范，并且在 Node.js 等环境下取得了很不错的实践。\n\n09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：\n\n\n1. **Modules/1.x** 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 [Modules/Transport](http://wiki.commonjs.org/wiki/Modules/Transport) 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。\n2. **Modules/Async** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 [AMD](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 规范及其实现 [RequireJS](http://requirejs.org/)。这个稍后再细说。\n3. **Modules/2.0** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了\n\n\n补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 `add`和`use` 两个源自于 YUI Modules 的函数名替换了 `define` 和 `require` ，但其原理更接近 RequireJS ，与 YUI Modules 的 `Y` 沙箱 Attach 机制并不相同\n\n\n## RequireJS & AMD\n\n[AMD (Async Module Definition)](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\n> RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments\n\nRequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：\n\n{% gist 65481dbbf6d16e831a6cc89c3e37e6e5 display-emails-from-database.php %}\n\n\n> As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?\n\n所以我们需要 **Function Wrapping** 来获取依赖并且提前通过 script tag 提前加载进来\n\n\n{% jsfiddle shorttag [tabs] [skin] [width] [height] %}\n\n\n当依赖模块非常多时，这种**依赖前置**的写法会显得有点奇怪，所以 AMD 给了一个语法糖， **simplified CommonJS wrapping**，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：\n\n```js\ndefine(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\nThe AMD loader will parse out the `require('')` calls by using `Function.prototype.toString()`, then internally convert the above define call into this:\n\n```js\ndefine(['require', 'dependency1', 'dependency2'], function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\n\n出于`Function.prototype.toString()`兼容性和性能的考虑，最好的做法还是做一次 **optimized build**\n\n\n\nAMD 和 CommonJS 的核心争议如下：\n\n### 1. **执行时机**\n\nModules/1.0:\n\n```js\nvar a = require(\"./a\") // 执行到此时，a.js 才同步下载并执行\n```\n\nAMD: （使用 require 的语法糖时）\n\n```js\ndefine([\"require\"],function(require)){\n    // 在这里，a.js 已经下载并且执行好了\n    // 使用 require() 并不是 AMD 的推荐写法\n    var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n})\n```\n\nAMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）\n\n但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。\n\n### 2. **书写风格**\n\nAMD 推荐的风格并不使用`require`，而是通过参数传入，破坏了**依赖就近**：\n\n```js\ndefine([\"a\", \"b\", \"c\"],function(a, b, c){\n    // 提前申明了并初始化了所有模块\n\n    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。\n})\n```\n\n不过，在笔者看来，风格喜好因人而异，主要还是**预执行**和**懒执行**的差异。\n\n另外，require 2.0 也开始思考异步处理**软依赖**（区别于一定需要的**硬依赖**）的问题，提出了这样的方案：\n\n```js\n// 函数体内：\nif(status){\n    async(['a'],function(a){\n        a.doSomething()\n    })\n}\n```\n\n## SeaJS & CMD\n\nCMD (Common Module Definition) 是 [SeaJS](http://seajs.org/docs/) 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。\n\n不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。\n\n* CMD Specification\n    * [English (CMDJS-repo)](https://github.com/cmdjs/specification/blob/master/draft/module.md)\n    * [Chinese (SeaJS-repo)](https://github.com/seajs/seajs/issues/242)\n\n\nCMD 主要有 define, factory, require, export 这么几个东西\n\n * define `define(id?, deps?, factory)`\n * factory `factory(require, exports, module)`\n * require `require(id)`\n * exports `Object`\n\n\nCMD 推荐的 Code Style 是使用 CommonJS 风格的 `require`：\n\n* 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已\n\n```js\ndefine(function(require, exports) {\n\n    // 获取模块 a 的接口\n    var a = require('./a');\n    // 调用模块 a 的方法\n    a.doSomething();\n\n    // 对外提供 foo 属性\n    exports.foo = 'bar';\n    // 对外提供 doSomething 方法\n    exports.doSomething = function() {};\n\n});\n```\n\n但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n    // 模块代码...\n\n    // 直接通过 return 暴露接口\n    return {\n        foo: 'bar',\n        doSomething: function() {}\n    };\n\n});\n```\n\n\n\nSea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。\n\n\n\n## AMD vs CMD\n\n**虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：**\n\n1. 对于依赖的模块，AMD 是**提前执行**，CMD 是**懒执行**。（都是先加载）\n*  CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。\n\n看代码：\n\n```js\n// AMD 默认推荐\n\ndefine(['./a', './b'], function(a, b) {  // 依赖前置，提前执行\n\n    a.doSomething()\n    b.doSomething()\n\n})\n\n```\n\n```js\n// CMD\n\ndefine(function(require, exports, module) {\n\n    var a = require('./a')\n    a.doSomething()\n\n    var b = require('./b') // 依赖就近，延迟执行\n    b.doSomething()\n})\n```\n\n\n\n\n\n\n## WebPack\n\n> 后续文章,展开补充...\n\n","source":"_posts/javascript-module-loader.md","raw":"---\nlayout:     post\ntitle:      \"JS模块加载\"\nsubtitle:   \"CommonJS，RequireJS，SeaJS 归纳笔记\"\ndate:       2017-03-23 22:45:58\nauthor:     \"Damon\"\ncatalog:    true\nheader-img: \"post-bg-js-module.jpg\"\ntags:\n    - 前端开发\n    - JavaScript\n---\n\n\n\n## Foreword\n\n> Here comes Module!\n\n随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。\n\n于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。\n\n\n---\n\n## Catalog\n\n\n1.  [CommonJS & Node](#commonjs--node)\n3.  [History](#history)\n4.  [RequireJS & AMD](#requirejs--amd)\n5.  [SeaJS & CMD](#seajs--cmd)\n6.  [AMD vs CMD](#amd-vs-cmd)\n7.  [WebPack](#webpack)\n\n\n\n```\nfunction autoDetect(){\n    console.log('ye, it is written in JavaScript!')\n}\n```\n\n## CommonJS & Node\n\n> Javascript: not just for browsers any more! —— CommonJS Slogen\n\n前端模块化的事实标准之一，2009 年 8 月，[CommonJS](http://wiki.commonjs.org/wiki/CommonJS) 诞生。\n\nCommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。\n\n\n让我们看看 Node 中的实现：\n{% codeblock lang:js %}\n// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper\n// \"as though the module was wrapped in a function\"\n\nvar a = require('./a')  // 加载模块（同步加载）\na.doSomething()         // 等上一句执行完才会执行\n\nexports.b = function(){ // 暴露 b 函数接口\n  // do something\n}\n{% endcodeblock %}\n\n\n`exports`是一个内置对象，就像`require`是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写`module.exports`就可以了。\n\nCommonJS 前身叫 ServerJS ，**后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS** 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。\n\n\n因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：\n\n* 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）\n* 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。\n* 都在向着 **COMMON** 的方向进化：**兼容不同风格，兼容浏览器和服务器两种环境**\n\n本文接下来要讨论的典例是：\n\n* RequireJS & AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）\n* SeaJS & CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）\n\n\n\n\n\n## History\n\n<!--<h2 id=\"history\"> History </h2>-->\n\n> 此段落参考自玉伯的 [前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588)\n\n09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 [Modules/1.0](http://wiki.commonjs.org/wiki/Modules) 规范，并且在 Node.js 等环境下取得了很不错的实践。\n\n09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：\n\n\n1. **Modules/1.x** 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 [Modules/Transport](http://wiki.commonjs.org/wiki/Modules/Transport) 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。\n2. **Modules/Async** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 [AMD](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 规范及其实现 [RequireJS](http://requirejs.org/)。这个稍后再细说。\n3. **Modules/2.0** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了\n\n\n补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 `add`和`use` 两个源自于 YUI Modules 的函数名替换了 `define` 和 `require` ，但其原理更接近 RequireJS ，与 YUI Modules 的 `Y` 沙箱 Attach 机制并不相同\n\n\n## RequireJS & AMD\n\n[AMD (Async Module Definition)](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\n> RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments\n\nRequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：\n\n{% gist 65481dbbf6d16e831a6cc89c3e37e6e5 display-emails-from-database.php %}\n\n\n> As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?\n\n所以我们需要 **Function Wrapping** 来获取依赖并且提前通过 script tag 提前加载进来\n\n\n{% jsfiddle shorttag [tabs] [skin] [width] [height] %}\n\n\n当依赖模块非常多时，这种**依赖前置**的写法会显得有点奇怪，所以 AMD 给了一个语法糖， **simplified CommonJS wrapping**，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：\n\n```js\ndefine(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\nThe AMD loader will parse out the `require('')` calls by using `Function.prototype.toString()`, then internally convert the above define call into this:\n\n```js\ndefine(['require', 'dependency1', 'dependency2'], function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\n\n出于`Function.prototype.toString()`兼容性和性能的考虑，最好的做法还是做一次 **optimized build**\n\n\n\nAMD 和 CommonJS 的核心争议如下：\n\n### 1. **执行时机**\n\nModules/1.0:\n\n```js\nvar a = require(\"./a\") // 执行到此时，a.js 才同步下载并执行\n```\n\nAMD: （使用 require 的语法糖时）\n\n```js\ndefine([\"require\"],function(require)){\n    // 在这里，a.js 已经下载并且执行好了\n    // 使用 require() 并不是 AMD 的推荐写法\n    var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n})\n```\n\nAMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）\n\n但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。\n\n### 2. **书写风格**\n\nAMD 推荐的风格并不使用`require`，而是通过参数传入，破坏了**依赖就近**：\n\n```js\ndefine([\"a\", \"b\", \"c\"],function(a, b, c){\n    // 提前申明了并初始化了所有模块\n\n    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。\n})\n```\n\n不过，在笔者看来，风格喜好因人而异，主要还是**预执行**和**懒执行**的差异。\n\n另外，require 2.0 也开始思考异步处理**软依赖**（区别于一定需要的**硬依赖**）的问题，提出了这样的方案：\n\n```js\n// 函数体内：\nif(status){\n    async(['a'],function(a){\n        a.doSomething()\n    })\n}\n```\n\n## SeaJS & CMD\n\nCMD (Common Module Definition) 是 [SeaJS](http://seajs.org/docs/) 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。\n\n不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。\n\n* CMD Specification\n    * [English (CMDJS-repo)](https://github.com/cmdjs/specification/blob/master/draft/module.md)\n    * [Chinese (SeaJS-repo)](https://github.com/seajs/seajs/issues/242)\n\n\nCMD 主要有 define, factory, require, export 这么几个东西\n\n * define `define(id?, deps?, factory)`\n * factory `factory(require, exports, module)`\n * require `require(id)`\n * exports `Object`\n\n\nCMD 推荐的 Code Style 是使用 CommonJS 风格的 `require`：\n\n* 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已\n\n```js\ndefine(function(require, exports) {\n\n    // 获取模块 a 的接口\n    var a = require('./a');\n    // 调用模块 a 的方法\n    a.doSomething();\n\n    // 对外提供 foo 属性\n    exports.foo = 'bar';\n    // 对外提供 doSomething 方法\n    exports.doSomething = function() {};\n\n});\n```\n\n但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n    // 模块代码...\n\n    // 直接通过 return 暴露接口\n    return {\n        foo: 'bar',\n        doSomething: function() {}\n    };\n\n});\n```\n\n\n\nSea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。\n\n\n\n## AMD vs CMD\n\n**虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：**\n\n1. 对于依赖的模块，AMD 是**提前执行**，CMD 是**懒执行**。（都是先加载）\n*  CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。\n\n看代码：\n\n```js\n// AMD 默认推荐\n\ndefine(['./a', './b'], function(a, b) {  // 依赖前置，提前执行\n\n    a.doSomething()\n    b.doSomething()\n\n})\n\n```\n\n```js\n// CMD\n\ndefine(function(require, exports, module) {\n\n    var a = require('./a')\n    a.doSomething()\n\n    var b = require('./b') // 依赖就近，延迟执行\n    b.doSomething()\n})\n```\n\n\n\n\n\n\n## WebPack\n\n> 后续文章,展开补充...\n\n","slug":"javascript-module-loader","published":1,"updated":"2017-09-12T10:06:06.000Z","comments":1,"photos":[],"link":"","_id":"cjagvsnjr000c4ouve7tarv8r","content":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><blockquote>\n<p>Here comes Module!</p>\n</blockquote>\n<p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p>\n<p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p>\n<hr>\n<h2 id=\"Catalog\"><a href=\"#Catalog\" class=\"headerlink\" title=\"Catalog\"></a>Catalog</h2><ol>\n<li><a href=\"#commonjs--node\">CommonJS &amp; Node</a></li>\n<li><a href=\"#history\">History</a></li>\n<li><a href=\"#requirejs--amd\">RequireJS &amp; AMD</a></li>\n<li><a href=\"#seajs--cmd\">SeaJS &amp; CMD</a></li>\n<li><a href=\"#amd-vs-cmd\">AMD vs CMD</a></li>\n<li><a href=\"#webpack\">WebPack</a></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autoDetect</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'ye, it is written in JavaScript!'</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"CommonJS-amp-Node\"><a href=\"#CommonJS-amp-Node\" class=\"headerlink\" title=\"CommonJS &amp; Node\"></a>CommonJS &amp; Node</h2><blockquote>\n<p>Javascript: not just for browsers any more! —— CommonJS Slogen</p>\n</blockquote>\n<p>前端模块化的事实标准之一，2009 年 8 月，<a href=\"http://wiki.commonjs.org/wiki/CommonJS\" target=\"_blank\" rel=\"external\">CommonJS</a> 诞生。</p>\n<p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p>\n<p>让我们看看 Node 中的实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></div><div class=\"line\"><span class=\"comment\">// \"as though the module was wrapped in a function\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)  <span class=\"comment\">// 加载模块（同步加载）</span></div><div class=\"line\">a.doSomething()         <span class=\"comment\">// 等上一句执行完才会执行</span></div><div class=\"line\"></div><div class=\"line\">exports.b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 暴露 b 函数接口</span></div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p>\n<p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>\n<p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p>\n<ul>\n<li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li>\n<li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li>\n<li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li>\n</ul>\n<p>本文接下来要讨论的典例是：</p>\n<ul>\n<li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li>\n<li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li>\n</ul>\n<h2 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h2><!--<h2 id=\"history\"> History </h2>-->\n<blockquote>\n<p>此段落参考自玉伯的 <a href=\"https://github.com/seajs/seajs/issues/588\" target=\"_blank\" rel=\"external\">前端模块化开发那点历史</a></p>\n</blockquote>\n<p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href=\"http://wiki.commonjs.org/wiki/Modules\" target=\"_blank\" rel=\"external\">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p>\n<p>09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>\n<ol>\n<li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\" target=\"_blank\" rel=\"external\">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li>\n<li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD</a> 规范及其实现 <a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"external\">RequireJS</a>。这个稍后再细说。</li>\n<li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li>\n</ol>\n<p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p>\n<h2 id=\"RequireJS-amp-AMD\"><a href=\"#RequireJS-amp-AMD\" class=\"headerlink\" title=\"RequireJS &amp; AMD\"></a>RequireJS &amp; AMD</h2><p><a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<blockquote>\n<p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p>\n</blockquote>\n<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p>\n<script src=\"//gist.github.com/65481dbbf6d16e831a6cc89c3e37e6e5.js?file=display-emails-from-database.php\"></script>\n<blockquote>\n<p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>\n</blockquote>\n<p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p>\n<iframe scrolling=\"no\" width=\"[width]\" height=\"[height]\" src=\"//jsfiddle.net/shorttag/embedded/[tabs]/[skin]\" frameborder=\"0\" allowfullscreen></iframe>\n<p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>The AMD loader will parse out the <code>require(&#39;&#39;)</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">'require'</span>, <span class=\"string\">'dependency1'</span>, <span class=\"string\">'dependency2'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p>\n<p>AMD 和 CommonJS 的核心争议如下：</p>\n<h3 id=\"1-执行时机\"><a href=\"#1-执行时机\" class=\"headerlink\" title=\"1. 执行时机\"></a>1. <strong>执行时机</strong></h3><p>Modules/1.0:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 执行到此时，a.js 才同步下载并执行</span></div></pre></td></tr></table></figure>\n<p>AMD: （使用 require 的语法糖时）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"require\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>))</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在这里，a.js 已经下载并且执行好了</span></div><div class=\"line\">    <span class=\"comment\">// 使用 require() 并不是 AMD 的推荐写法</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 此处仅仅是取模块 a 的 exports</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>\n<p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>\n<h3 id=\"2-书写风格\"><a href=\"#2-书写风格\" class=\"headerlink\" title=\"2. 书写风格\"></a>2. <strong>书写风格</strong></h3><p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 提前申明了并初始化了所有模块</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"literal\">true</span> || b.foo(); <span class=\"comment\">//即便根本没用到模块 b，但 b 还是提前执行了。</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p>\n<p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数体内：</span></div><div class=\"line\"><span class=\"keyword\">if</span>(status)&#123;</div><div class=\"line\">    <span class=\"keyword\">async</span>([<span class=\"string\">'a'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">        a.doSomething()</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"SeaJS-amp-CMD\"><a href=\"#SeaJS-amp-CMD\" class=\"headerlink\" title=\"SeaJS &amp; CMD\"></a>SeaJS &amp; CMD</h2><p>CMD (Common Module Definition) 是 <a href=\"http://seajs.org/docs/\" target=\"_blank\" rel=\"external\">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>\n<p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p>\n<ul>\n<li>CMD Specification<ul>\n<li><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\" target=\"_blank\" rel=\"external\">English (CMDJS-repo)</a></li>\n<li><a href=\"https://github.com/seajs/seajs/issues/242\" target=\"_blank\" rel=\"external\">Chinese (SeaJS-repo)</a></li>\n</ul>\n</li>\n</ul>\n<p>CMD 主要有 define, factory, require, export 这么几个东西</p>\n<ul>\n<li>define <code>define(id?, deps?, factory)</code></li>\n<li>factory <code>factory(require, exports, module)</code></li>\n<li>require <code>require(id)</code></li>\n<li>exports <code>Object</code></li>\n</ul>\n<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p>\n<ul>\n<li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 获取模块 a 的接口</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</div><div class=\"line\">    <span class=\"comment\">// 调用模块 a 的方法</span></div><div class=\"line\">    a.doSomething();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 对外提供 foo 属性</span></div><div class=\"line\">    exports.foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">    <span class=\"comment\">// 对外提供 doSomething 方法</span></div><div class=\"line\">    exports.doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"string\">'hello'</span>, [<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 模块代码...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 直接通过 return 暴露接口</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        foo: <span class=\"string\">'bar'</span>,</div><div class=\"line\">        doSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>\n<h2 id=\"AMD-vs-CMD\"><a href=\"#AMD-vs-CMD\" class=\"headerlink\" title=\"AMD vs CMD\"></a>AMD vs CMD</h2><p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p>\n<ol>\n<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li>\n</ol>\n<ul>\n<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</li>\n</ul>\n<p>看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></div><div class=\"line\"></div><div class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖前置，提前执行</span></div><div class=\"line\"></div><div class=\"line\">    a.doSomething()</div><div class=\"line\">    b.doSomething()</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CMD</span></div><div class=\"line\"></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</div><div class=\"line\">    a.doSomething()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖就近，延迟执行</span></div><div class=\"line\">    b.doSomething()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"WebPack\"><a href=\"#WebPack\" class=\"headerlink\" title=\"WebPack\"></a>WebPack</h2><blockquote>\n<p>后续文章,展开补充…</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><blockquote>\n<p>Here comes Module!</p>\n</blockquote>\n<p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p>\n<p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p>\n<hr>\n<h2 id=\"Catalog\"><a href=\"#Catalog\" class=\"headerlink\" title=\"Catalog\"></a>Catalog</h2><ol>\n<li><a href=\"#commonjs--node\">CommonJS &amp; Node</a></li>\n<li><a href=\"#history\">History</a></li>\n<li><a href=\"#requirejs--amd\">RequireJS &amp; AMD</a></li>\n<li><a href=\"#seajs--cmd\">SeaJS &amp; CMD</a></li>\n<li><a href=\"#amd-vs-cmd\">AMD vs CMD</a></li>\n<li><a href=\"#webpack\">WebPack</a></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autoDetect</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'ye, it is written in JavaScript!'</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"CommonJS-amp-Node\"><a href=\"#CommonJS-amp-Node\" class=\"headerlink\" title=\"CommonJS &amp; Node\"></a>CommonJS &amp; Node</h2><blockquote>\n<p>Javascript: not just for browsers any more! —— CommonJS Slogen</p>\n</blockquote>\n<p>前端模块化的事实标准之一，2009 年 8 月，<a href=\"http://wiki.commonjs.org/wiki/CommonJS\" target=\"_blank\" rel=\"external\">CommonJS</a> 诞生。</p>\n<p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p>\n<p>让我们看看 Node 中的实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></div><div class=\"line\"><span class=\"comment\">// \"as though the module was wrapped in a function\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)  <span class=\"comment\">// 加载模块（同步加载）</span></div><div class=\"line\">a.doSomething()         <span class=\"comment\">// 等上一句执行完才会执行</span></div><div class=\"line\"></div><div class=\"line\">exports.b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 暴露 b 函数接口</span></div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p>\n<p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>\n<p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p>\n<ul>\n<li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li>\n<li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li>\n<li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li>\n</ul>\n<p>本文接下来要讨论的典例是：</p>\n<ul>\n<li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li>\n<li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li>\n</ul>\n<h2 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h2><!--<h2 id=\"history\"> History </h2>-->\n<blockquote>\n<p>此段落参考自玉伯的 <a href=\"https://github.com/seajs/seajs/issues/588\" target=\"_blank\" rel=\"external\">前端模块化开发那点历史</a></p>\n</blockquote>\n<p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href=\"http://wiki.commonjs.org/wiki/Modules\" target=\"_blank\" rel=\"external\">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p>\n<p>09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>\n<ol>\n<li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\" target=\"_blank\" rel=\"external\">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li>\n<li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD</a> 规范及其实现 <a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"external\">RequireJS</a>。这个稍后再细说。</li>\n<li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li>\n</ol>\n<p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p>\n<h2 id=\"RequireJS-amp-AMD\"><a href=\"#RequireJS-amp-AMD\" class=\"headerlink\" title=\"RequireJS &amp; AMD\"></a>RequireJS &amp; AMD</h2><p><a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<blockquote>\n<p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p>\n</blockquote>\n<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p>\n<script src=\"//gist.github.com/65481dbbf6d16e831a6cc89c3e37e6e5.js?file=display-emails-from-database.php\"></script>\n<blockquote>\n<p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>\n</blockquote>\n<p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p>\n<iframe scrolling=\"no\" width=\"[width]\" height=\"[height]\" src=\"//jsfiddle.net/shorttag/embedded/[tabs]/[skin]\" frameborder=\"0\" allowfullscreen></iframe>\n<p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>The AMD loader will parse out the <code>require(&#39;&#39;)</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">'require'</span>, <span class=\"string\">'dependency1'</span>, <span class=\"string\">'dependency2'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p>\n<p>AMD 和 CommonJS 的核心争议如下：</p>\n<h3 id=\"1-执行时机\"><a href=\"#1-执行时机\" class=\"headerlink\" title=\"1. 执行时机\"></a>1. <strong>执行时机</strong></h3><p>Modules/1.0:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 执行到此时，a.js 才同步下载并执行</span></div></pre></td></tr></table></figure>\n<p>AMD: （使用 require 的语法糖时）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"require\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>))</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在这里，a.js 已经下载并且执行好了</span></div><div class=\"line\">    <span class=\"comment\">// 使用 require() 并不是 AMD 的推荐写法</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 此处仅仅是取模块 a 的 exports</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>\n<p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>\n<h3 id=\"2-书写风格\"><a href=\"#2-书写风格\" class=\"headerlink\" title=\"2. 书写风格\"></a>2. <strong>书写风格</strong></h3><p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 提前申明了并初始化了所有模块</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"literal\">true</span> || b.foo(); <span class=\"comment\">//即便根本没用到模块 b，但 b 还是提前执行了。</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p>\n<p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数体内：</span></div><div class=\"line\"><span class=\"keyword\">if</span>(status)&#123;</div><div class=\"line\">    <span class=\"keyword\">async</span>([<span class=\"string\">'a'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">        a.doSomething()</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"SeaJS-amp-CMD\"><a href=\"#SeaJS-amp-CMD\" class=\"headerlink\" title=\"SeaJS &amp; CMD\"></a>SeaJS &amp; CMD</h2><p>CMD (Common Module Definition) 是 <a href=\"http://seajs.org/docs/\" target=\"_blank\" rel=\"external\">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>\n<p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p>\n<ul>\n<li>CMD Specification<ul>\n<li><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\" target=\"_blank\" rel=\"external\">English (CMDJS-repo)</a></li>\n<li><a href=\"https://github.com/seajs/seajs/issues/242\" target=\"_blank\" rel=\"external\">Chinese (SeaJS-repo)</a></li>\n</ul>\n</li>\n</ul>\n<p>CMD 主要有 define, factory, require, export 这么几个东西</p>\n<ul>\n<li>define <code>define(id?, deps?, factory)</code></li>\n<li>factory <code>factory(require, exports, module)</code></li>\n<li>require <code>require(id)</code></li>\n<li>exports <code>Object</code></li>\n</ul>\n<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p>\n<ul>\n<li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 获取模块 a 的接口</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</div><div class=\"line\">    <span class=\"comment\">// 调用模块 a 的方法</span></div><div class=\"line\">    a.doSomething();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 对外提供 foo 属性</span></div><div class=\"line\">    exports.foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">    <span class=\"comment\">// 对外提供 doSomething 方法</span></div><div class=\"line\">    exports.doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"string\">'hello'</span>, [<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 模块代码...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 直接通过 return 暴露接口</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        foo: <span class=\"string\">'bar'</span>,</div><div class=\"line\">        doSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>\n<h2 id=\"AMD-vs-CMD\"><a href=\"#AMD-vs-CMD\" class=\"headerlink\" title=\"AMD vs CMD\"></a>AMD vs CMD</h2><p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p>\n<ol>\n<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li>\n</ol>\n<ul>\n<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</li>\n</ul>\n<p>看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></div><div class=\"line\"></div><div class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖前置，提前执行</span></div><div class=\"line\"></div><div class=\"line\">    a.doSomething()</div><div class=\"line\">    b.doSomething()</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CMD</span></div><div class=\"line\"></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</div><div class=\"line\">    a.doSomething()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖就近，延迟执行</span></div><div class=\"line\">    b.doSomething()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"WebPack\"><a href=\"#WebPack\" class=\"headerlink\" title=\"WebPack\"></a>WebPack</h2><blockquote>\n<p>后续文章,展开补充…</p>\n</blockquote>\n"},{"title":"函数的节流和去抖","subtitle":"js性能优化","date":"2017-07-24T06:03:59.000Z","author":"Damon","header-img":"/img/about-bg.jpg","_content":"\n## 前言\n函数节流和去抖的出现场景，一般都伴随着客户端 DOM 的事件监听。例如:监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次 \n\n1.  谈到函数节流,举个例子，实现一个原生的拖拽功能（不能用 H5 Drag&Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。**如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的**，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。**我们需要做的是降低触发回调的频率**，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。**函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。**\n\n2.  说完函数节流，再看它的好基友函数去抖（debounce）。思考这样一个场景，对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。**简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。**\n\n\n\n## *throttle(函数节流)*\n\n### 应用场景\n函数节流有哪些应用场景？哪些时候我们需要间隔一定时间触发回调来控制函数调用频率？\n\n* DOM 元素的拖拽功能实现（mousemove）\n* 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）\n* 计算鼠标移动的距离（mousemove）\n* Canvas 模拟画板功能（mousemove）\n* 搜索联想（keyup）\n\n### 代码实现\n```\n/**\n * 函数节流（如果有连续事件响应，则每间隔一定时间段触发）\n * @param {function} func 需要节流的函数\n * @param {number} wait  触发间隔\n */\n\nfunction throttle(func, wait) {\n    let startTime;\n    return function () {\n        let context = this, arg = arguments, currentTime = +new Date();\n\n        if (!startTime) {\n            startTime = currentTime\n        }\n        // 大于间隔时间才马上执行函数, 然后更新函数执行时间\n        if (currentTime - startTime > wait) {\n            func.apply(context, arg)\n            startTime = currentTime\n        }\n    }\n}\n```\n\n\n## *debounce(函数去抖)*\n\n### 应用场景\n函数去抖有哪些应用场景？哪些时候对于连续的事件响应我们只需要执行一次回调？\n\n* 每次 resize/scroll 触发统计事件\n* 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）\n\n### 代码实现\n```\n/**\n * 函数去抖(如果有连续事件响应, 则在事件结束后的延迟一段时间触发)\n * @param {function}  function 需要去抖的函数\n * @param {number} delay 调用延迟时间\n */\nfunction debounce(func, delay) {\n    let timer;\n    return function () {\n        let context = this, arg = arguments;\n        // 由于事件持续相应,定时器会在每次相应中清除掉.\n        // 最终使得,事件停止相应之前的建立的最后一个定时器生效\n        clearTimeout(timer);\n \n        timer = setTimeout(function () {\n            func.apply(context, arg)\n        }, delay)\n\n    }\n}\n```","source":"_posts/函数的节流和去抖.md","raw":"---\ntitle: 函数的节流和去抖\nsubtitle: js性能优化\ndate: 2017-07-24 14:03:59\nauthor: \"Damon\"\nheader-img: \"/img/about-bg.jpg\"\ntags:\n    - JS\n    - 前端面试\n---\n\n## 前言\n函数节流和去抖的出现场景，一般都伴随着客户端 DOM 的事件监听。例如:监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次 \n\n1.  谈到函数节流,举个例子，实现一个原生的拖拽功能（不能用 H5 Drag&Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。**如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的**，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。**我们需要做的是降低触发回调的频率**，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。**函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。**\n\n2.  说完函数节流，再看它的好基友函数去抖（debounce）。思考这样一个场景，对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。**简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。**\n\n\n\n## *throttle(函数节流)*\n\n### 应用场景\n函数节流有哪些应用场景？哪些时候我们需要间隔一定时间触发回调来控制函数调用频率？\n\n* DOM 元素的拖拽功能实现（mousemove）\n* 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）\n* 计算鼠标移动的距离（mousemove）\n* Canvas 模拟画板功能（mousemove）\n* 搜索联想（keyup）\n\n### 代码实现\n```\n/**\n * 函数节流（如果有连续事件响应，则每间隔一定时间段触发）\n * @param {function} func 需要节流的函数\n * @param {number} wait  触发间隔\n */\n\nfunction throttle(func, wait) {\n    let startTime;\n    return function () {\n        let context = this, arg = arguments, currentTime = +new Date();\n\n        if (!startTime) {\n            startTime = currentTime\n        }\n        // 大于间隔时间才马上执行函数, 然后更新函数执行时间\n        if (currentTime - startTime > wait) {\n            func.apply(context, arg)\n            startTime = currentTime\n        }\n    }\n}\n```\n\n\n## *debounce(函数去抖)*\n\n### 应用场景\n函数去抖有哪些应用场景？哪些时候对于连续的事件响应我们只需要执行一次回调？\n\n* 每次 resize/scroll 触发统计事件\n* 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）\n\n### 代码实现\n```\n/**\n * 函数去抖(如果有连续事件响应, 则在事件结束后的延迟一段时间触发)\n * @param {function}  function 需要去抖的函数\n * @param {number} delay 调用延迟时间\n */\nfunction debounce(func, delay) {\n    let timer;\n    return function () {\n        let context = this, arg = arguments;\n        // 由于事件持续相应,定时器会在每次相应中清除掉.\n        // 最终使得,事件停止相应之前的建立的最后一个定时器生效\n        clearTimeout(timer);\n \n        timer = setTimeout(function () {\n            func.apply(context, arg)\n        }, delay)\n\n    }\n}\n```","slug":"函数的节流和去抖","published":1,"updated":"2017-09-12T10:06:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjagvsnjs000d4ouvmul8pc7p","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>函数节流和去抖的出现场景，一般都伴随着客户端 DOM 的事件监听。例如:监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次 </p>\n<ol>\n<li><p>谈到函数节流,举个例子，实现一个原生的拖拽功能（不能用 H5 Drag&amp;Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。<strong>如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的</strong>，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。<strong>我们需要做的是降低触发回调的频率</strong>，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。<strong>函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。</strong></p>\n</li>\n<li><p>说完函数节流，再看它的好基友函数去抖（debounce）。思考这样一个场景，对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。<strong>简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。</strong></p>\n</li>\n</ol>\n<h2 id=\"throttle-函数节流\"><a href=\"#throttle-函数节流\" class=\"headerlink\" title=\"throttle(函数节流)\"></a><em>throttle(函数节流)</em></h2><h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>函数节流有哪些应用场景？哪些时候我们需要间隔一定时间触发回调来控制函数调用频率？</p>\n<ul>\n<li>DOM 元素的拖拽功能实现（mousemove）</li>\n<li>射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）</li>\n<li>计算鼠标移动的距离（mousemove）</li>\n<li>Canvas 模拟画板功能（mousemove）</li>\n<li>搜索联想（keyup）</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 函数节流（如果有连续事件响应，则每间隔一定时间段触发）</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; func 需要节流的函数</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; wait  触发间隔</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> startTime;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>, arg = <span class=\"built_in\">arguments</span>, currentTime = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!startTime) &#123;</div><div class=\"line\">            startTime = currentTime</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 大于间隔时间才马上执行函数, 然后更新函数执行时间</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (currentTime - startTime &gt; wait) &#123;</div><div class=\"line\">            func.apply(context, arg)</div><div class=\"line\">            startTime = currentTime</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"debounce-函数去抖\"><a href=\"#debounce-函数去抖\" class=\"headerlink\" title=\"debounce(函数去抖)\"></a><em>debounce(函数去抖)</em></h2><h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>函数去抖有哪些应用场景？哪些时候对于连续的事件响应我们只需要执行一次回调？</p>\n<ul>\n<li>每次 resize/scroll 触发统计事件</li>\n<li>文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）</li>\n</ul>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 函数去抖(如果有连续事件响应, 则在事件结束后的延迟一段时间触发)</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123;function&#125;  function 需要去抖的函数</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; delay 调用延迟时间</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, delay</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> timer;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>, arg = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">        <span class=\"comment\">// 由于事件持续相应,定时器会在每次相应中清除掉.</span></div><div class=\"line\">        <span class=\"comment\">// 最终使得,事件停止相应之前的建立的最后一个定时器生效</span></div><div class=\"line\">        clearTimeout(timer);</div><div class=\"line\"> </div><div class=\"line\">        timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            func.apply(context, arg)</div><div class=\"line\">        &#125;, delay)</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>函数节流和去抖的出现场景，一般都伴随着客户端 DOM 的事件监听。例如:监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次 </p>\n<ol>\n<li><p>谈到函数节流,举个例子，实现一个原生的拖拽功能（不能用 H5 Drag&amp;Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。<strong>如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的</strong>，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。<strong>我们需要做的是降低触发回调的频率</strong>，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。<strong>函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。</strong></p>\n</li>\n<li><p>说完函数节流，再看它的好基友函数去抖（debounce）。思考这样一个场景，对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。<strong>简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。</strong></p>\n</li>\n</ol>\n<h2 id=\"throttle-函数节流\"><a href=\"#throttle-函数节流\" class=\"headerlink\" title=\"throttle(函数节流)\"></a><em>throttle(函数节流)</em></h2><h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>函数节流有哪些应用场景？哪些时候我们需要间隔一定时间触发回调来控制函数调用频率？</p>\n<ul>\n<li>DOM 元素的拖拽功能实现（mousemove）</li>\n<li>射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）</li>\n<li>计算鼠标移动的距离（mousemove）</li>\n<li>Canvas 模拟画板功能（mousemove）</li>\n<li>搜索联想（keyup）</li>\n</ul>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 函数节流（如果有连续事件响应，则每间隔一定时间段触发）</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; func 需要节流的函数</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; wait  触发间隔</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> startTime;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>, arg = <span class=\"built_in\">arguments</span>, currentTime = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (!startTime) &#123;</div><div class=\"line\">            startTime = currentTime</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 大于间隔时间才马上执行函数, 然后更新函数执行时间</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (currentTime - startTime &gt; wait) &#123;</div><div class=\"line\">            func.apply(context, arg)</div><div class=\"line\">            startTime = currentTime</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"debounce-函数去抖\"><a href=\"#debounce-函数去抖\" class=\"headerlink\" title=\"debounce(函数去抖)\"></a><em>debounce(函数去抖)</em></h2><h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>函数去抖有哪些应用场景？哪些时候对于连续的事件响应我们只需要执行一次回调？</p>\n<ul>\n<li>每次 resize/scroll 触发统计事件</li>\n<li>文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）</li>\n</ul>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 函数去抖(如果有连续事件响应, 则在事件结束后的延迟一段时间触发)</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123;function&#125;  function 需要去抖的函数</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; delay 调用延迟时间</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, delay</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> timer;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>, arg = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">        <span class=\"comment\">// 由于事件持续相应,定时器会在每次相应中清除掉.</span></div><div class=\"line\">        <span class=\"comment\">// 最终使得,事件停止相应之前的建立的最后一个定时器生效</span></div><div class=\"line\">        clearTimeout(timer);</div><div class=\"line\"> </div><div class=\"line\">        timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            func.apply(context, arg)</div><div class=\"line\">        &#125;, delay)</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"实现链式调用LazyMan","subtitle":"原型链 链式调用实现","author":"Damon","header-img":"post-bg-js-version.jpg","date":"2017-04-09T01:43:13.000Z","_content":"\n## 前言\n\n昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。\n\n---\n\n## 题目\n\n实现下面的函数:\n\n```\nLazyMan(“Hank”)\n//Hi! This is Hank!\n\nLazyMan(“Hank”).sleep(10).eat(“dinner”)\n// Hi! This is Hank!\n// 等待10秒..\n// Wake up after 10\n// Eat dinner~\n\nLazyMan(“Hank”).eat(“dinner”).eat(“supper”)\n// Hi This is Hank!\n// Eat dinner~\n// Eat supper~\n\nLazyMan(“Hank”).sleepFirst(5).eat(“supper”)\n// 等待5秒\n// Wake up after 5\n// Hi This is Hank!\n// Eat supper\n\n```\n\n这道题看起来很简单,不就是jquery经常使用的链式调用吗?\n但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.\n\n## 代码实现\n\n废话不多说直接上代码:\n\n```\nfunction _LazyMan(man) {\n    var self = this;\n    // 任务队列\n    self.task = [];\n    var fn = function () {\n        console.log('I am ' + man);\n        self.next();\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n\n    // 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务\n    setTimeout(function () {\n        self.next();\n    }, 0)\n\n    return self;\n}\n\n_LazyMan.prototype.firstSleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾开头加入一个任务\n    self.task.unshift(fn);\n\n    return self;\n}\n\n_LazyMan.prototype.sleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n_LazyMan.prototype.eat = function (food) {\n    var self = this;\n\n    var fn = function () {\n        console.log('eat ' + food);\n\n        self.next();\n    }\n\n    // 向队列尾加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n// next实现\n_LazyMan.prototype.next = function () {\n    // 删除队列的第一位元素\n    var runFunc = this.task.shift();\n\n    // 如果renFunc 不是undefined,那么执行runFunc\n    runFunc && runFunc();\n\n}\n\nfunction LazyMan(man) {\n    return new _LazyMan(man);\n}\n\nLazyMan('Hank').firstSleep(1).sleep(2).eat('egg');\n\n/* 运行结果 */\n// Wake up after 1 s!\n//     I am Hank\n// Wake up after 2 s!\n//     eat egg\n\n```\n## 总结\n\n实现要点:\n1. 在实例上创建一个任务队列数组(先进先出).\n2. 实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.\n3. 在实例化LazyMan的时候,使用setTimeout执行第一次next方法.\n\n* 注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，\nsetTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/实现链式LazyMan.md","raw":"---\ntitle: 实现链式调用LazyMan\nsubtitle: \"原型链 链式调用实现\"\nauthor: \"Damon\"\nheader-img: \"post-bg-js-version.jpg\"\ndate: 2017-04-09 09:43:13\ntags:\n    - JS\n    - 前端面试\n---\n\n## 前言\n\n昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。\n\n---\n\n## 题目\n\n实现下面的函数:\n\n```\nLazyMan(“Hank”)\n//Hi! This is Hank!\n\nLazyMan(“Hank”).sleep(10).eat(“dinner”)\n// Hi! This is Hank!\n// 等待10秒..\n// Wake up after 10\n// Eat dinner~\n\nLazyMan(“Hank”).eat(“dinner”).eat(“supper”)\n// Hi This is Hank!\n// Eat dinner~\n// Eat supper~\n\nLazyMan(“Hank”).sleepFirst(5).eat(“supper”)\n// 等待5秒\n// Wake up after 5\n// Hi This is Hank!\n// Eat supper\n\n```\n\n这道题看起来很简单,不就是jquery经常使用的链式调用吗?\n但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.\n\n## 代码实现\n\n废话不多说直接上代码:\n\n```\nfunction _LazyMan(man) {\n    var self = this;\n    // 任务队列\n    self.task = [];\n    var fn = function () {\n        console.log('I am ' + man);\n        self.next();\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n\n    // 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务\n    setTimeout(function () {\n        self.next();\n    }, 0)\n\n    return self;\n}\n\n_LazyMan.prototype.firstSleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾开头加入一个任务\n    self.task.unshift(fn);\n\n    return self;\n}\n\n_LazyMan.prototype.sleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n_LazyMan.prototype.eat = function (food) {\n    var self = this;\n\n    var fn = function () {\n        console.log('eat ' + food);\n\n        self.next();\n    }\n\n    // 向队列尾加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n// next实现\n_LazyMan.prototype.next = function () {\n    // 删除队列的第一位元素\n    var runFunc = this.task.shift();\n\n    // 如果renFunc 不是undefined,那么执行runFunc\n    runFunc && runFunc();\n\n}\n\nfunction LazyMan(man) {\n    return new _LazyMan(man);\n}\n\nLazyMan('Hank').firstSleep(1).sleep(2).eat('egg');\n\n/* 运行结果 */\n// Wake up after 1 s!\n//     I am Hank\n// Wake up after 2 s!\n//     eat egg\n\n```\n## 总结\n\n实现要点:\n1. 在实例上创建一个任务队列数组(先进先出).\n2. 实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.\n3. 在实例化LazyMan的时候,使用setTimeout执行第一次next方法.\n\n* 注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，\nsetTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"实现链式LazyMan","published":1,"updated":"2017-09-12T10:06:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjagvsnjt000f4ouvcayhe95t","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。</p>\n<hr>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>实现下面的函数:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span></div><div class=\"line\"><span class=\"comment\">//Hi! This is Hank!</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleep(<span class=\"number\">10</span>).eat(“dinner”)</div><div class=\"line\"><span class=\"comment\">// Hi! This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// 等待10秒..</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 10</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.eat(“dinner”).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"><span class=\"comment\">// Eat supper~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleepFirst(<span class=\"number\">5</span>).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// 等待5秒</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 5</span></div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat supper</span></div></pre></td></tr></table></figure>\n<p>这道题看起来很简单,不就是jquery经常使用的链式调用吗?<br>但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>废话不多说直接上代码:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\">    <span class=\"comment\">// 任务队列</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task = [];</div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'I am '</span> + man);</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务</span></div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;, <span class=\"number\">0</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.firstSleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾开头加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.unshift(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.sleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(food)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'eat '</span> + food);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// next实现</span></div><div class=\"line\">_LazyMan.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 删除队列的第一位元素</span></div><div class=\"line\">    <span class=\"keyword\">var</span> runFunc = this.task.shift();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果renFunc 不是undefined,那么执行runFunc</span></div><div class=\"line\">    runFunc &amp;&amp; runFunc();</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(man);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">LazyMan(<span class=\"string\">'Hank'</span>).firstSleep(<span class=\"number\">1</span>).sleep(<span class=\"number\">2</span>).eat(<span class=\"string\">'egg'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 运行结果 */</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 1 s!</span></div><div class=\"line\"><span class=\"comment\">//     I am Hank</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 2 s!</span></div><div class=\"line\"><span class=\"comment\">//     eat egg</span></div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实现要点:</p>\n<ol>\n<li>在实例上创建一个任务队列数组(先进先出).</li>\n<li>实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.</li>\n<li>在实例化LazyMan的时候,使用setTimeout执行第一次next方法.</li>\n</ol>\n<ul>\n<li>注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，<br>setTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。</p>\n<hr>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>实现下面的函数:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span></div><div class=\"line\"><span class=\"comment\">//Hi! This is Hank!</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleep(<span class=\"number\">10</span>).eat(“dinner”)</div><div class=\"line\"><span class=\"comment\">// Hi! This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// 等待10秒..</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 10</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.eat(“dinner”).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"><span class=\"comment\">// Eat supper~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleepFirst(<span class=\"number\">5</span>).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// 等待5秒</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 5</span></div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat supper</span></div></pre></td></tr></table></figure>\n<p>这道题看起来很简单,不就是jquery经常使用的链式调用吗?<br>但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>废话不多说直接上代码:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\">    <span class=\"comment\">// 任务队列</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task = [];</div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'I am '</span> + man);</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务</span></div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;, <span class=\"number\">0</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.firstSleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾开头加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.unshift(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.sleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(food)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'eat '</span> + food);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// next实现</span></div><div class=\"line\">_LazyMan.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 删除队列的第一位元素</span></div><div class=\"line\">    <span class=\"keyword\">var</span> runFunc = this.task.shift();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果renFunc 不是undefined,那么执行runFunc</span></div><div class=\"line\">    runFunc &amp;&amp; runFunc();</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(man);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">LazyMan(<span class=\"string\">'Hank'</span>).firstSleep(<span class=\"number\">1</span>).sleep(<span class=\"number\">2</span>).eat(<span class=\"string\">'egg'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 运行结果 */</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 1 s!</span></div><div class=\"line\"><span class=\"comment\">//     I am Hank</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 2 s!</span></div><div class=\"line\"><span class=\"comment\">//     eat egg</span></div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实现要点:</p>\n<ol>\n<li>在实例上创建一个任务队列数组(先进先出).</li>\n<li>实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.</li>\n<li>在实例化LazyMan的时候,使用setTimeout执行第一次next方法.</li>\n</ol>\n<ul>\n<li>注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，<br>setTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。</li>\n</ul>\n"},{"title":"徒手解析URL参数","date":"2017-06-19T06:19:00.000Z","author":"Damon","header-img":"/img/about-bg.jpg","_content":"\n\n## 题目\n\n不借助第三方库的条件下，用 JS 编写函数从下面的 URL 串中解析出所有的参数：\n\n```\nhttp://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&d&enabled\n```\n期望的返回结果格式如下：\n```\n{\n  user: 'anonymous',\n  id: [123, 456],     // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型\n  city: '北京',        // 中文\n  enabled: true,      // 未指定值的 key 约定值为 true\n}\n```\n## 代码实现\n\n```\nvar URL = 'http://www.domain.com/?user=anonymous&id=0&id=456&city=%E5%8C%97%E4%BA%AC&d&enabled'\n\nfunction getURLParams (url) {\n  if (url && typeof url !== 'string') {\n    return {}\n  }\n\n  // 如果没传URL,默认解析浏览器当前URL\n  let URL = url || window.location.href\n  let searchOfURL = URL.split('?')[1] || null\n\n  //如果没有查询参数,那么直接返回\n  if (!searchOfURL) {\n    return {}\n  }\n\n  // 处理查询参数\n  let params = decodeURIComponent(searchOfURL).split('&').map(item => {\n    let param = item.split('='),\n        key   = param[0],\n        value = param[1] || true;\n\n    if (typeof value === 'string' && !isNaN(Number(value))) {\n      value = Number(value)\n    }\n\n    return { key, value }\n\n  }).reduce((params, item) => {\n    const { key, value } = item\n\n    // 判断key是否存在, 注意:不能使用 if (!params[key]) ,因为可能出现值为 0 的情况\n    if ( typeof params[key] === 'undefined') {\n      params[key] = value\n    } else {\n      // 存在key,那么把相同value放数组内\n      params[key] = Array.isArray(params[key]) ? params[key].concat(value) : [].concat(params[key], value)\n    }\n\n    return params\n  }, {})\n\n  return params\n}\n\nconsole.log(getURLParams(URL))\n\n// 运行结果\n// { user: 'anonymous',\n//   id: [ 0, 456 ],\n//   city: '北京',\n//   d: true,\n//   enabled: true }\n```","source":"_posts/徒手解析URL参数.md","raw":"---\ntitle: 徒手解析URL参数\ndate: 2017-06-19 14:19:00\nauthor: \"Damon\"\nheader-img: \"/img/about-bg.jpg\"\ntags:\n    - JS\n    - 前端面试\n---\n\n\n## 题目\n\n不借助第三方库的条件下，用 JS 编写函数从下面的 URL 串中解析出所有的参数：\n\n```\nhttp://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&d&enabled\n```\n期望的返回结果格式如下：\n```\n{\n  user: 'anonymous',\n  id: [123, 456],     // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型\n  city: '北京',        // 中文\n  enabled: true,      // 未指定值的 key 约定值为 true\n}\n```\n## 代码实现\n\n```\nvar URL = 'http://www.domain.com/?user=anonymous&id=0&id=456&city=%E5%8C%97%E4%BA%AC&d&enabled'\n\nfunction getURLParams (url) {\n  if (url && typeof url !== 'string') {\n    return {}\n  }\n\n  // 如果没传URL,默认解析浏览器当前URL\n  let URL = url || window.location.href\n  let searchOfURL = URL.split('?')[1] || null\n\n  //如果没有查询参数,那么直接返回\n  if (!searchOfURL) {\n    return {}\n  }\n\n  // 处理查询参数\n  let params = decodeURIComponent(searchOfURL).split('&').map(item => {\n    let param = item.split('='),\n        key   = param[0],\n        value = param[1] || true;\n\n    if (typeof value === 'string' && !isNaN(Number(value))) {\n      value = Number(value)\n    }\n\n    return { key, value }\n\n  }).reduce((params, item) => {\n    const { key, value } = item\n\n    // 判断key是否存在, 注意:不能使用 if (!params[key]) ,因为可能出现值为 0 的情况\n    if ( typeof params[key] === 'undefined') {\n      params[key] = value\n    } else {\n      // 存在key,那么把相同value放数组内\n      params[key] = Array.isArray(params[key]) ? params[key].concat(value) : [].concat(params[key], value)\n    }\n\n    return params\n  }, {})\n\n  return params\n}\n\nconsole.log(getURLParams(URL))\n\n// 运行结果\n// { user: 'anonymous',\n//   id: [ 0, 456 ],\n//   city: '北京',\n//   d: true,\n//   enabled: true }\n```","slug":"徒手解析URL参数","published":1,"updated":"2017-09-12T10:06:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjagvsnju000g4ouvt68ewrp9","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>不借助第三方库的条件下，用 JS 编写函数从下面的 URL 串中解析出所有的参数：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://www.domain.com/?user=anonymous&amp;id=<span class=\"number\">123</span>&amp;id=<span class=\"number\">456</span>&amp;city=<span class=\"symbol\">%E5</span><span class=\"symbol\">%8</span>C<span class=\"symbol\">%97</span><span class=\"symbol\">%E4</span><span class=\"symbol\">%BA</span><span class=\"symbol\">%AC</span>&amp;d&amp;enabled</div></pre></td></tr></table></figure>\n<p>期望的返回结果格式如下：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attribute\">user</span>: <span class=\"string\">'anonymous'</span>,</div><div class=\"line\">  <span class=\"attribute\">id</span>: [<span class=\"number\">123</span>, <span class=\"number\">456</span>],     <span class=\"comment\">// 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></div><div class=\"line\">  <span class=\"attribute\">city</span>: <span class=\"string\">'北京'</span>,        <span class=\"comment\">// 中文</span></div><div class=\"line\">  <span class=\"attribute\">enabled</span>: true,      <span class=\"comment\">// 未指定值的 key 约定值为 true</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> URL = <span class=\"string\">'http://www.domain.com/?user=anonymous&amp;id=0&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">function <span class=\"title\">getURLParams</span> (<span class=\"params\">url</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (url &amp;&amp; <span class=\"keyword\">typeof</span> url !== <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 如果没传URL,默认解析浏览器当前URL</span></div><div class=\"line\">  <span class=\"keyword\">let</span> URL = url || window.location.href</div><div class=\"line\">  <span class=\"keyword\">let</span> searchOfURL = URL.split(<span class=\"string\">'?'</span>)[<span class=\"number\">1</span>] || <span class=\"literal\">null</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//如果没有查询参数,那么直接返回</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!searchOfURL) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 处理查询参数</span></div><div class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">params</span> = decodeURIComponent(searchOfURL).split(<span class=\"string\">'&amp;'</span>).map(item =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> param = item.split(<span class=\"string\">'='</span>),</div><div class=\"line\">        key   = param[<span class=\"number\">0</span>],</div><div class=\"line\">        <span class=\"keyword\">value</span> = param[<span class=\"number\">1</span>] || <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">value</span> === <span class=\"string\">'string'</span> &amp;&amp; !isNaN(Number(<span class=\"keyword\">value</span>))) &#123;</div><div class=\"line\">      <span class=\"keyword\">value</span> = Number(<span class=\"keyword\">value</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123; key, <span class=\"keyword\">value</span> &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;).reduce((<span class=\"keyword\">params</span>, item) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> &#123; key, <span class=\"keyword\">value</span> &#125; = item</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 判断key是否存在, 注意:不能使用 if (!params[key]) ,因为可能出现值为 0 的情况</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> <span class=\"keyword\">params</span>[key] === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">params</span>[key] = <span class=\"keyword\">value</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 存在key,那么把相同value放数组内</span></div><div class=\"line\">      <span class=\"keyword\">params</span>[key] = Array.isArray(<span class=\"keyword\">params</span>[key]) ? <span class=\"keyword\">params</span>[key].concat(<span class=\"keyword\">value</span>) : [].concat(<span class=\"keyword\">params</span>[key], <span class=\"keyword\">value</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">params</span></div><div class=\"line\">  &#125;, &#123;&#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">params</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(getURLParams(URL))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 运行结果</span></div><div class=\"line\"><span class=\"comment\">// &#123; user: 'anonymous',</span></div><div class=\"line\"><span class=\"comment\">//   id: [ 0, 456 ],</span></div><div class=\"line\"><span class=\"comment\">//   city: '北京',</span></div><div class=\"line\"><span class=\"comment\">//   d: true,</span></div><div class=\"line\"><span class=\"comment\">//   enabled: true &#125;</span></div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>不借助第三方库的条件下，用 JS 编写函数从下面的 URL 串中解析出所有的参数：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://www.domain.com/?user=anonymous&amp;id=<span class=\"number\">123</span>&amp;id=<span class=\"number\">456</span>&amp;city=<span class=\"symbol\">%E5</span><span class=\"symbol\">%8</span>C<span class=\"symbol\">%97</span><span class=\"symbol\">%E4</span><span class=\"symbol\">%BA</span><span class=\"symbol\">%AC</span>&amp;d&amp;enabled</div></pre></td></tr></table></figure>\n<p>期望的返回结果格式如下：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attribute\">user</span>: <span class=\"string\">'anonymous'</span>,</div><div class=\"line\">  <span class=\"attribute\">id</span>: [<span class=\"number\">123</span>, <span class=\"number\">456</span>],     <span class=\"comment\">// 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></div><div class=\"line\">  <span class=\"attribute\">city</span>: <span class=\"string\">'北京'</span>,        <span class=\"comment\">// 中文</span></div><div class=\"line\">  <span class=\"attribute\">enabled</span>: true,      <span class=\"comment\">// 未指定值的 key 约定值为 true</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> URL = <span class=\"string\">'http://www.domain.com/?user=anonymous&amp;id=0&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">function <span class=\"title\">getURLParams</span> (<span class=\"params\">url</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (url &amp;&amp; <span class=\"keyword\">typeof</span> url !== <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 如果没传URL,默认解析浏览器当前URL</span></div><div class=\"line\">  <span class=\"keyword\">let</span> URL = url || window.location.href</div><div class=\"line\">  <span class=\"keyword\">let</span> searchOfURL = URL.split(<span class=\"string\">'?'</span>)[<span class=\"number\">1</span>] || <span class=\"literal\">null</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//如果没有查询参数,那么直接返回</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!searchOfURL) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 处理查询参数</span></div><div class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">params</span> = decodeURIComponent(searchOfURL).split(<span class=\"string\">'&amp;'</span>).map(item =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> param = item.split(<span class=\"string\">'='</span>),</div><div class=\"line\">        key   = param[<span class=\"number\">0</span>],</div><div class=\"line\">        <span class=\"keyword\">value</span> = param[<span class=\"number\">1</span>] || <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">value</span> === <span class=\"string\">'string'</span> &amp;&amp; !isNaN(Number(<span class=\"keyword\">value</span>))) &#123;</div><div class=\"line\">      <span class=\"keyword\">value</span> = Number(<span class=\"keyword\">value</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123; key, <span class=\"keyword\">value</span> &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;).reduce((<span class=\"keyword\">params</span>, item) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> &#123; key, <span class=\"keyword\">value</span> &#125; = item</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 判断key是否存在, 注意:不能使用 if (!params[key]) ,因为可能出现值为 0 的情况</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> <span class=\"keyword\">params</span>[key] === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">params</span>[key] = <span class=\"keyword\">value</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 存在key,那么把相同value放数组内</span></div><div class=\"line\">      <span class=\"keyword\">params</span>[key] = Array.isArray(<span class=\"keyword\">params</span>[key]) ? <span class=\"keyword\">params</span>[key].concat(<span class=\"keyword\">value</span>) : [].concat(<span class=\"keyword\">params</span>[key], <span class=\"keyword\">value</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">params</span></div><div class=\"line\">  &#125;, &#123;&#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">params</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(getURLParams(URL))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 运行结果</span></div><div class=\"line\"><span class=\"comment\">// &#123; user: 'anonymous',</span></div><div class=\"line\"><span class=\"comment\">//   id: [ 0, 456 ],</span></div><div class=\"line\"><span class=\"comment\">//   city: '北京',</span></div><div class=\"line\"><span class=\"comment\">//   d: true,</span></div><div class=\"line\"><span class=\"comment\">//   enabled: true &#125;</span></div></pre></td></tr></table></figure>"},{"title":"时间格式化工具函数","date":"2017-07-24T07:37:08.000Z","author":"Damon","header-img":"/img/about-bg.jpg","_content":"\n\n\n## 时间格式化函数\n\n时间格式化工具,一般比较常用. moment.js库基本上能满足,日常开发大部分需求. \n心血来来潮,想造一把轮子.  下面我简单实现一个时间格式化函数.\n\n```\n// 简单粗暴,直接在Date的原型上实现一个format函数\nDate.prototype.Format = function (fmt) {\n    var o = {\n        \"Y+\": this.getFullYear(),    \n        \"M+\": '0' + (this.getMonth() + 1), //特别注意月份是从0开始!  (fucking js!)   \n        \"D+\": this.getDate(), //日 \n        \"h+\": this.getHours(), //小时 \n        \"m+\": this.getMinutes(), //分 \n        \"s+\": this.getSeconds(), //秒 \n        \"Q+\": Math.floor((this.getMonth() + 3) / 3) //季度 \n    };\n\n    for (var key in o) {\n        fmt = fmt.replace(new RegExp('(' + key + ')'), (match) => {\n            return (o[key] + '').slice(-match.length)\n        })\n    }\n\n    return fmt;\n}\n\nconsole.log(new Date().Format('YYYY-MM-DD hh:mm:ss'))\n// '2017-07-23 15:33:00'\n```\n\n以上,完成了一个简单时间格式化函数!   哟,是不是很简单? ","source":"_posts/时间格式化工具函数.md","raw":"---\ntitle: 时间格式化工具函数\ndate: 2017-07-24 15:37:08\nauthor: \"Damon\"\nheader-img: \"/img/about-bg.jpg\"\ntags:\n    - JS\n---\n\n\n\n## 时间格式化函数\n\n时间格式化工具,一般比较常用. moment.js库基本上能满足,日常开发大部分需求. \n心血来来潮,想造一把轮子.  下面我简单实现一个时间格式化函数.\n\n```\n// 简单粗暴,直接在Date的原型上实现一个format函数\nDate.prototype.Format = function (fmt) {\n    var o = {\n        \"Y+\": this.getFullYear(),    \n        \"M+\": '0' + (this.getMonth() + 1), //特别注意月份是从0开始!  (fucking js!)   \n        \"D+\": this.getDate(), //日 \n        \"h+\": this.getHours(), //小时 \n        \"m+\": this.getMinutes(), //分 \n        \"s+\": this.getSeconds(), //秒 \n        \"Q+\": Math.floor((this.getMonth() + 3) / 3) //季度 \n    };\n\n    for (var key in o) {\n        fmt = fmt.replace(new RegExp('(' + key + ')'), (match) => {\n            return (o[key] + '').slice(-match.length)\n        })\n    }\n\n    return fmt;\n}\n\nconsole.log(new Date().Format('YYYY-MM-DD hh:mm:ss'))\n// '2017-07-23 15:33:00'\n```\n\n以上,完成了一个简单时间格式化函数!   哟,是不是很简单? ","slug":"时间格式化工具函数","published":1,"updated":"2017-09-12T10:06:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjagvsnjw000j4ouv894cp3qj","content":"<h2 id=\"时间格式化函数\"><a href=\"#时间格式化函数\" class=\"headerlink\" title=\"时间格式化函数\"></a>时间格式化函数</h2><p>时间格式化工具,一般比较常用. moment.js库基本上能满足,日常开发大部分需求.<br>心血来来潮,想造一把轮子.  下面我简单实现一个时间格式化函数.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 简单粗暴,直接在Date的原型上实现一个format函数</span></div><div class=\"line\"><span class=\"built_in\">Date</span>.prototype.Format = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fmt</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">        <span class=\"string\">\"Y+\"</span>: <span class=\"keyword\">this</span>.getFullYear(),    </div><div class=\"line\">        <span class=\"string\">\"M+\"</span>: <span class=\"string\">'0'</span> + (<span class=\"keyword\">this</span>.getMonth() + <span class=\"number\">1</span>), <span class=\"comment\">//特别注意月份是从0开始!  (fucking js!)   </span></div><div class=\"line\">        <span class=\"string\">\"D+\"</span>: <span class=\"keyword\">this</span>.getDate(), <span class=\"comment\">//日 </span></div><div class=\"line\">        <span class=\"string\">\"h+\"</span>: <span class=\"keyword\">this</span>.getHours(), <span class=\"comment\">//小时 </span></div><div class=\"line\">        <span class=\"string\">\"m+\"</span>: <span class=\"keyword\">this</span>.getMinutes(), <span class=\"comment\">//分 </span></div><div class=\"line\">        <span class=\"string\">\"s+\"</span>: <span class=\"keyword\">this</span>.getSeconds(), <span class=\"comment\">//秒 </span></div><div class=\"line\">        <span class=\"string\">\"Q+\"</span>: <span class=\"built_in\">Math</span>.floor((<span class=\"keyword\">this</span>.getMonth() + <span class=\"number\">3</span>) / <span class=\"number\">3</span>) <span class=\"comment\">//季度 </span></div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> o) &#123;</div><div class=\"line\">        fmt = fmt.replace(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'('</span> + key + <span class=\"string\">')'</span>), <span class=\"function\">(<span class=\"params\">match</span>) =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> (o[key] + <span class=\"string\">''</span>).slice(-match.length)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> fmt;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().Format(<span class=\"string\">'YYYY-MM-DD hh:mm:ss'</span>))</div><div class=\"line\"><span class=\"comment\">// '2017-07-23 15:33:00'</span></div></pre></td></tr></table></figure>\n<p>以上,完成了一个简单时间格式化函数!   哟,是不是很简单? </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"时间格式化函数\"><a href=\"#时间格式化函数\" class=\"headerlink\" title=\"时间格式化函数\"></a>时间格式化函数</h2><p>时间格式化工具,一般比较常用. moment.js库基本上能满足,日常开发大部分需求.<br>心血来来潮,想造一把轮子.  下面我简单实现一个时间格式化函数.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 简单粗暴,直接在Date的原型上实现一个format函数</span></div><div class=\"line\"><span class=\"built_in\">Date</span>.prototype.Format = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fmt</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">        <span class=\"string\">\"Y+\"</span>: <span class=\"keyword\">this</span>.getFullYear(),    </div><div class=\"line\">        <span class=\"string\">\"M+\"</span>: <span class=\"string\">'0'</span> + (<span class=\"keyword\">this</span>.getMonth() + <span class=\"number\">1</span>), <span class=\"comment\">//特别注意月份是从0开始!  (fucking js!)   </span></div><div class=\"line\">        <span class=\"string\">\"D+\"</span>: <span class=\"keyword\">this</span>.getDate(), <span class=\"comment\">//日 </span></div><div class=\"line\">        <span class=\"string\">\"h+\"</span>: <span class=\"keyword\">this</span>.getHours(), <span class=\"comment\">//小时 </span></div><div class=\"line\">        <span class=\"string\">\"m+\"</span>: <span class=\"keyword\">this</span>.getMinutes(), <span class=\"comment\">//分 </span></div><div class=\"line\">        <span class=\"string\">\"s+\"</span>: <span class=\"keyword\">this</span>.getSeconds(), <span class=\"comment\">//秒 </span></div><div class=\"line\">        <span class=\"string\">\"Q+\"</span>: <span class=\"built_in\">Math</span>.floor((<span class=\"keyword\">this</span>.getMonth() + <span class=\"number\">3</span>) / <span class=\"number\">3</span>) <span class=\"comment\">//季度 </span></div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> o) &#123;</div><div class=\"line\">        fmt = fmt.replace(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'('</span> + key + <span class=\"string\">')'</span>), <span class=\"function\">(<span class=\"params\">match</span>) =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> (o[key] + <span class=\"string\">''</span>).slice(-match.length)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> fmt;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().Format(<span class=\"string\">'YYYY-MM-DD hh:mm:ss'</span>))</div><div class=\"line\"><span class=\"comment\">// '2017-07-23 15:33:00'</span></div></pre></td></tr></table></figure>\n<p>以上,完成了一个简单时间格式化函数!   哟,是不是很简单? </p>\n"},{"title":"缓存机制","date":"2017-09-04T13:54:58.000Z","_content":"\n## 缓存的分类\n缓存分为服务端侧（比如：Nginx、Apache）和客户端侧（比如：web brower）。\n\n- 服务端缓存又分为代理服务器缓存和反向代理服务端缓存（也叫网关缓存，比如Nginx反向代理、Squid等），其实广泛使用的CDN也是一种服务端缓存，目的都是让用户的请求走捷径，并且都是缓存图片、文件等静态资源。\n- 客户端缓存一般指的是浏览器缓存，目的就是加速各种静态资源的访问，想想现在的大型网站，随便一个页面都是一两百个请求，每天pv都是亿级别，如果没有缓存，用户体验会急剧下降，同时服务器压力和网络带宽都面临严重的考验。\n\n## 浏览器缓存机制详解\n浏览器缓存控制机制有两种：HTML Meta标签 和 HTTP头信息。\n\n### HTML Meta标签控制缓存 \n浏览器缓存机制，其实就是HTTP协议定制的缓存机制（如：Expires; Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta标签，Web开发者可以在HTML页面的<head>节点中加入<meta>标签，代码如下：\n\n```\n<meta http-equiv=\"Pragma\" content=\"no-cache\">\n```\n\n上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。而广泛应用的还是HTTP头信息来控制缓存，下面主要介绍HTTP协议定义的缓存机制。\n\n### HTTP头信息控制缓存\n#### 浏览器请求流程\n- 浏览器第一次请求流程图：\n![image](http://static.oschina.net/uploads/space/2015/0119/015343_psx2_568818.png?_=4807408)\n\n- 浏览器再次请求时：\n![image](http://static.oschina.net/uploads/space/2015/0119/015353_P04w_568818.png?_=4807408)\n\n#### 几个重要概念解释\n- Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires是HTTP 1.0的东西，现在浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires的一个缺点就是，返回的到期是服务端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版本开始，使用“Cache-Control: max-age=秒”替代。\n- Cache-Control策略：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。设置列表如下：\n\n属性 | 解释\n---|---\nPublic | 指示响应可以被任何缓存区缓存。\nPrivate | 指示对于单个用户的的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。\nno-cache | 指示请求或响应消息不能缓存。\nno-store | 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不适用缓存，完全不存下来。\nmax-age | 指示客户端可以接收生存期不大于指定时间（以秒为单位）的响应。\nmin-fresh | 指示客户端可以接收响应时间小于当前时间加上指定时间的响应。\nmax-stale | 指示客户端可以接收超出超时时间的响应消息。\n\n- Last-Modified/If-Modified-Since: Last-Modified/If-Modified-Since要配合Cache-Control使用。\n\n\n属性 | 解释\n---|---\nLast-Modified | 标识这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。\nIf-Modified-Since | 当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。\n\n- Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。\n\n\n属性 | 解释\n---|---\nEtag | web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。\nIf-None-Match | 当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。\n\n- 既生Last-Modified何生Etag？你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：**Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间\n如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存\n有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形**\n- Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与Etag一起使用时，服务器会优先验证Etag。\n\n总结以下几种状态码的区别：\n\n名称 | 解释\n---|---\n200状态 | 当浏览器本地有没缓存或者下一层失效时，或者用户强制刷新时，浏览器直接去服务器下载最新数据。\n304状态 | 这一层由Last-Modified/Etag控制。当下一层失效时或者用户刷新时，浏览器就会发送请求给服务器，如果服务端没有变化，则返回304给浏览器。\n200状态（from cache） | 这一层由expires/cache-control控制。expires（http 1.0版有效）是绝对时间。cache-control（http 1.1版有效）是相对时间。两者都存在时，cache-control覆盖expores，只要没有失效，浏览器只访问自己的缓存。\n\n## 用户行为与缓存\n浏览器缓存行为与用户的行为有关，总结如下：\n\n用户操作 | Expries/Cache-control | Last-Modified/Etag\n---|---|---\n地址栏回车 | 有效 | 有效\n页面链接跳转 | 有效 | 有效\n新开窗口 | 有效 | 有效\n前进、后退 | 有效 | 有效\nF5刷新 | 无效（BR重置max-age=0） | 有效\nCrtl+F5刷新 | 无效（重置CC=no-cache） | 无效（请求头丢弃该选项）\n\n## 相关参考\n1. 浏览器缓存机制：http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html\n2. Web开发人员需知的Web缓存知识：http://www.oschina.net/news/41397/web-cache-knowledge\n3. 浏览器缓存详解:expires,cache-control,last-modified,etag详细说明：http://blog.csdn.net/eroswang/article/details/8302191\n4. 在浏览器地址栏按回车、F5、Ctrl+F5刷新网页的区别：http://blog.csdn.net/yui/article/details/6584401\n5.  Cache Control与ETag：https://blog.othree.net/log/2012/12/22/cache-control-and-etag/\n6.  缓存的故事：http://segmentfault.com/blog/animabear/1190000000375344\n7.  Google的PageSpeed网站优化理论中提到使用Etag可以减少服务器负担：https://developers.google.com/speed/docs/pss/AddEtags\n8.  yahoo的Yslow法则中则提示谨慎设置Etag：http://developer.yahoo.com/performance/rules.html#etags\n","source":"_posts/缓存机制.md","raw":"---\ntitle: 缓存机制\ndate: 2017-09-04 21:54:58\ntags: 前端基础 \n---\n\n## 缓存的分类\n缓存分为服务端侧（比如：Nginx、Apache）和客户端侧（比如：web brower）。\n\n- 服务端缓存又分为代理服务器缓存和反向代理服务端缓存（也叫网关缓存，比如Nginx反向代理、Squid等），其实广泛使用的CDN也是一种服务端缓存，目的都是让用户的请求走捷径，并且都是缓存图片、文件等静态资源。\n- 客户端缓存一般指的是浏览器缓存，目的就是加速各种静态资源的访问，想想现在的大型网站，随便一个页面都是一两百个请求，每天pv都是亿级别，如果没有缓存，用户体验会急剧下降，同时服务器压力和网络带宽都面临严重的考验。\n\n## 浏览器缓存机制详解\n浏览器缓存控制机制有两种：HTML Meta标签 和 HTTP头信息。\n\n### HTML Meta标签控制缓存 \n浏览器缓存机制，其实就是HTTP协议定制的缓存机制（如：Expires; Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta标签，Web开发者可以在HTML页面的<head>节点中加入<meta>标签，代码如下：\n\n```\n<meta http-equiv=\"Pragma\" content=\"no-cache\">\n```\n\n上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。而广泛应用的还是HTTP头信息来控制缓存，下面主要介绍HTTP协议定义的缓存机制。\n\n### HTTP头信息控制缓存\n#### 浏览器请求流程\n- 浏览器第一次请求流程图：\n![image](http://static.oschina.net/uploads/space/2015/0119/015343_psx2_568818.png?_=4807408)\n\n- 浏览器再次请求时：\n![image](http://static.oschina.net/uploads/space/2015/0119/015353_P04w_568818.png?_=4807408)\n\n#### 几个重要概念解释\n- Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires是HTTP 1.0的东西，现在浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires的一个缺点就是，返回的到期是服务端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版本开始，使用“Cache-Control: max-age=秒”替代。\n- Cache-Control策略：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。设置列表如下：\n\n属性 | 解释\n---|---\nPublic | 指示响应可以被任何缓存区缓存。\nPrivate | 指示对于单个用户的的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。\nno-cache | 指示请求或响应消息不能缓存。\nno-store | 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不适用缓存，完全不存下来。\nmax-age | 指示客户端可以接收生存期不大于指定时间（以秒为单位）的响应。\nmin-fresh | 指示客户端可以接收响应时间小于当前时间加上指定时间的响应。\nmax-stale | 指示客户端可以接收超出超时时间的响应消息。\n\n- Last-Modified/If-Modified-Since: Last-Modified/If-Modified-Since要配合Cache-Control使用。\n\n\n属性 | 解释\n---|---\nLast-Modified | 标识这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。\nIf-Modified-Since | 当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。\n\n- Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。\n\n\n属性 | 解释\n---|---\nEtag | web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。\nIf-None-Match | 当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。\n\n- 既生Last-Modified何生Etag？你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：**Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间\n如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存\n有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形**\n- Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与Etag一起使用时，服务器会优先验证Etag。\n\n总结以下几种状态码的区别：\n\n名称 | 解释\n---|---\n200状态 | 当浏览器本地有没缓存或者下一层失效时，或者用户强制刷新时，浏览器直接去服务器下载最新数据。\n304状态 | 这一层由Last-Modified/Etag控制。当下一层失效时或者用户刷新时，浏览器就会发送请求给服务器，如果服务端没有变化，则返回304给浏览器。\n200状态（from cache） | 这一层由expires/cache-control控制。expires（http 1.0版有效）是绝对时间。cache-control（http 1.1版有效）是相对时间。两者都存在时，cache-control覆盖expores，只要没有失效，浏览器只访问自己的缓存。\n\n## 用户行为与缓存\n浏览器缓存行为与用户的行为有关，总结如下：\n\n用户操作 | Expries/Cache-control | Last-Modified/Etag\n---|---|---\n地址栏回车 | 有效 | 有效\n页面链接跳转 | 有效 | 有效\n新开窗口 | 有效 | 有效\n前进、后退 | 有效 | 有效\nF5刷新 | 无效（BR重置max-age=0） | 有效\nCrtl+F5刷新 | 无效（重置CC=no-cache） | 无效（请求头丢弃该选项）\n\n## 相关参考\n1. 浏览器缓存机制：http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html\n2. Web开发人员需知的Web缓存知识：http://www.oschina.net/news/41397/web-cache-knowledge\n3. 浏览器缓存详解:expires,cache-control,last-modified,etag详细说明：http://blog.csdn.net/eroswang/article/details/8302191\n4. 在浏览器地址栏按回车、F5、Ctrl+F5刷新网页的区别：http://blog.csdn.net/yui/article/details/6584401\n5.  Cache Control与ETag：https://blog.othree.net/log/2012/12/22/cache-control-and-etag/\n6.  缓存的故事：http://segmentfault.com/blog/animabear/1190000000375344\n7.  Google的PageSpeed网站优化理论中提到使用Etag可以减少服务器负担：https://developers.google.com/speed/docs/pss/AddEtags\n8.  yahoo的Yslow法则中则提示谨慎设置Etag：http://developer.yahoo.com/performance/rules.html#etags\n","slug":"缓存机制","published":1,"updated":"2017-09-12T10:06:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjagvsnjx000l4ouv0cvi9eax","content":"<h2 id=\"缓存的分类\"><a href=\"#缓存的分类\" class=\"headerlink\" title=\"缓存的分类\"></a>缓存的分类</h2><p>缓存分为服务端侧（比如：Nginx、Apache）和客户端侧（比如：web brower）。</p>\n<ul>\n<li>服务端缓存又分为代理服务器缓存和反向代理服务端缓存（也叫网关缓存，比如Nginx反向代理、Squid等），其实广泛使用的CDN也是一种服务端缓存，目的都是让用户的请求走捷径，并且都是缓存图片、文件等静态资源。</li>\n<li>客户端缓存一般指的是浏览器缓存，目的就是加速各种静态资源的访问，想想现在的大型网站，随便一个页面都是一两百个请求，每天pv都是亿级别，如果没有缓存，用户体验会急剧下降，同时服务器压力和网络带宽都面临严重的考验。</li>\n</ul>\n<h2 id=\"浏览器缓存机制详解\"><a href=\"#浏览器缓存机制详解\" class=\"headerlink\" title=\"浏览器缓存机制详解\"></a>浏览器缓存机制详解</h2><p>浏览器缓存控制机制有两种：HTML Meta标签 和 HTTP头信息。</p>\n<h3 id=\"HTML-Meta标签控制缓存\"><a href=\"#HTML-Meta标签控制缓存\" class=\"headerlink\" title=\"HTML Meta标签控制缓存\"></a>HTML Meta标签控制缓存</h3><p>浏览器缓存机制，其实就是HTTP协议定制的缓存机制（如：Expires; Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta标签，Web开发者可以在HTML页面的<head>节点中加入<meta>标签，代码如下：</head></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;meta <span class=\"attribute\">http-equiv</span>=<span class=\"string\">\"Pragma\"</span> <span class=\"attribute\">content</span>=<span class=\"string\">\"no-cache\"</span>&gt;</div></pre></td></tr></table></figure>\n<p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。而广泛应用的还是HTTP头信息来控制缓存，下面主要介绍HTTP协议定义的缓存机制。</p>\n<h3 id=\"HTTP头信息控制缓存\"><a href=\"#HTTP头信息控制缓存\" class=\"headerlink\" title=\"HTTP头信息控制缓存\"></a>HTTP头信息控制缓存</h3><h4 id=\"浏览器请求流程\"><a href=\"#浏览器请求流程\" class=\"headerlink\" title=\"浏览器请求流程\"></a>浏览器请求流程</h4><ul>\n<li><p>浏览器第一次请求流程图：<br><img src=\"http://static.oschina.net/uploads/space/2015/0119/015343_psx2_568818.png?_=4807408\" alt=\"image\"></p>\n</li>\n<li><p>浏览器再次请求时：<br><img src=\"http://static.oschina.net/uploads/space/2015/0119/015353_P04w_568818.png?_=4807408\" alt=\"image\"></p>\n</li>\n</ul>\n<h4 id=\"几个重要概念解释\"><a href=\"#几个重要概念解释\" class=\"headerlink\" title=\"几个重要概念解释\"></a>几个重要概念解释</h4><ul>\n<li>Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires是HTTP 1.0的东西，现在浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires的一个缺点就是，返回的到期是服务端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版本开始，使用“Cache-Control: max-age=秒”替代。</li>\n<li>Cache-Control策略：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。设置列表如下：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Public</td>\n<td>指示响应可以被任何缓存区缓存。</td>\n</tr>\n<tr>\n<td>Private</td>\n<td>指示对于单个用户的的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。</td>\n</tr>\n<tr>\n<td>no-cache</td>\n<td>指示请求或响应消息不能缓存。</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不适用缓存，完全不存下来。</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td>指示客户端可以接收生存期不大于指定时间（以秒为单位）的响应。</td>\n</tr>\n<tr>\n<td>min-fresh</td>\n<td>指示客户端可以接收响应时间小于当前时间加上指定时间的响应。</td>\n</tr>\n<tr>\n<td>max-stale</td>\n<td>指示客户端可以接收超出超时时间的响应消息。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Last-Modified/If-Modified-Since: Last-Modified/If-Modified-Since要配合Cache-Control使用。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Last-Modified</td>\n<td>标识这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Etag</td>\n<td>web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>既生Last-Modified何生Etag？你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：<strong>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间<br>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存<br>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</strong></li>\n<li>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与Etag一起使用时，服务器会优先验证Etag。</li>\n</ul>\n<p>总结以下几种状态码的区别：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200状态</td>\n<td>当浏览器本地有没缓存或者下一层失效时，或者用户强制刷新时，浏览器直接去服务器下载最新数据。</td>\n</tr>\n<tr>\n<td>304状态</td>\n<td>这一层由Last-Modified/Etag控制。当下一层失效时或者用户刷新时，浏览器就会发送请求给服务器，如果服务端没有变化，则返回304给浏览器。</td>\n</tr>\n<tr>\n<td>200状态（from cache）</td>\n<td>这一层由expires/cache-control控制。expires（http 1.0版有效）是绝对时间。cache-control（http 1.1版有效）是相对时间。两者都存在时，cache-control覆盖expores，只要没有失效，浏览器只访问自己的缓存。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"用户行为与缓存\"><a href=\"#用户行为与缓存\" class=\"headerlink\" title=\"用户行为与缓存\"></a>用户行为与缓存</h2><p>浏览器缓存行为与用户的行为有关，总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>用户操作</th>\n<th>Expries/Cache-control</th>\n<th>Last-Modified/Etag</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>地址栏回车</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>页面链接跳转</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>新开窗口</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>前进、后退</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>F5刷新</td>\n<td>无效（BR重置max-age=0）</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>Crtl+F5刷新</td>\n<td>无效（重置CC=no-cache）</td>\n<td>无效（请求头丢弃该选项）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"相关参考\"><a href=\"#相关参考\" class=\"headerlink\" title=\"相关参考\"></a>相关参考</h2><ol>\n<li>浏览器缓存机制：<a href=\"http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></li>\n<li>Web开发人员需知的Web缓存知识：<a href=\"http://www.oschina.net/news/41397/web-cache-knowledge\" target=\"_blank\" rel=\"external\">http://www.oschina.net/news/41397/web-cache-knowledge</a></li>\n<li>浏览器缓存详解:expires,cache-control,last-modified,etag详细说明：<a href=\"http://blog.csdn.net/eroswang/article/details/8302191\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/eroswang/article/details/8302191</a></li>\n<li>在浏览器地址栏按回车、F5、Ctrl+F5刷新网页的区别：<a href=\"http://blog.csdn.net/yui/article/details/6584401\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/yui/article/details/6584401</a></li>\n<li>Cache Control与ETag：<a href=\"https://blog.othree.net/log/2012/12/22/cache-control-and-etag/\" target=\"_blank\" rel=\"external\">https://blog.othree.net/log/2012/12/22/cache-control-and-etag/</a></li>\n<li>缓存的故事：<a href=\"http://segmentfault.com/blog/animabear/1190000000375344\" target=\"_blank\" rel=\"external\">http://segmentfault.com/blog/animabear/1190000000375344</a></li>\n<li>Google的PageSpeed网站优化理论中提到使用Etag可以减少服务器负担：<a href=\"https://developers.google.com/speed/docs/pss/AddEtags\" target=\"_blank\" rel=\"external\">https://developers.google.com/speed/docs/pss/AddEtags</a></li>\n<li>yahoo的Yslow法则中则提示谨慎设置Etag：<a href=\"http://developer.yahoo.com/performance/rules.html#etags\" target=\"_blank\" rel=\"external\">http://developer.yahoo.com/performance/rules.html#etags</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"缓存的分类\"><a href=\"#缓存的分类\" class=\"headerlink\" title=\"缓存的分类\"></a>缓存的分类</h2><p>缓存分为服务端侧（比如：Nginx、Apache）和客户端侧（比如：web brower）。</p>\n<ul>\n<li>服务端缓存又分为代理服务器缓存和反向代理服务端缓存（也叫网关缓存，比如Nginx反向代理、Squid等），其实广泛使用的CDN也是一种服务端缓存，目的都是让用户的请求走捷径，并且都是缓存图片、文件等静态资源。</li>\n<li>客户端缓存一般指的是浏览器缓存，目的就是加速各种静态资源的访问，想想现在的大型网站，随便一个页面都是一两百个请求，每天pv都是亿级别，如果没有缓存，用户体验会急剧下降，同时服务器压力和网络带宽都面临严重的考验。</li>\n</ul>\n<h2 id=\"浏览器缓存机制详解\"><a href=\"#浏览器缓存机制详解\" class=\"headerlink\" title=\"浏览器缓存机制详解\"></a>浏览器缓存机制详解</h2><p>浏览器缓存控制机制有两种：HTML Meta标签 和 HTTP头信息。</p>\n<h3 id=\"HTML-Meta标签控制缓存\"><a href=\"#HTML-Meta标签控制缓存\" class=\"headerlink\" title=\"HTML Meta标签控制缓存\"></a>HTML Meta标签控制缓存</h3><p>浏览器缓存机制，其实就是HTTP协议定制的缓存机制（如：Expires; Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta标签，Web开发者可以在HTML页面的<head>节点中加入<meta>标签，代码如下：</head></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;meta <span class=\"attribute\">http-equiv</span>=<span class=\"string\">\"Pragma\"</span> <span class=\"attribute\">content</span>=<span class=\"string\">\"no-cache\"</span>&gt;</div></pre></td></tr></table></figure>\n<p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。而广泛应用的还是HTTP头信息来控制缓存，下面主要介绍HTTP协议定义的缓存机制。</p>\n<h3 id=\"HTTP头信息控制缓存\"><a href=\"#HTTP头信息控制缓存\" class=\"headerlink\" title=\"HTTP头信息控制缓存\"></a>HTTP头信息控制缓存</h3><h4 id=\"浏览器请求流程\"><a href=\"#浏览器请求流程\" class=\"headerlink\" title=\"浏览器请求流程\"></a>浏览器请求流程</h4><ul>\n<li><p>浏览器第一次请求流程图：<br><img src=\"http://static.oschina.net/uploads/space/2015/0119/015343_psx2_568818.png?_=4807408\" alt=\"image\"></p>\n</li>\n<li><p>浏览器再次请求时：<br><img src=\"http://static.oschina.net/uploads/space/2015/0119/015353_P04w_568818.png?_=4807408\" alt=\"image\"></p>\n</li>\n</ul>\n<h4 id=\"几个重要概念解释\"><a href=\"#几个重要概念解释\" class=\"headerlink\" title=\"几个重要概念解释\"></a>几个重要概念解释</h4><ul>\n<li>Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires是HTTP 1.0的东西，现在浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires的一个缺点就是，返回的到期是服务端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版本开始，使用“Cache-Control: max-age=秒”替代。</li>\n<li>Cache-Control策略：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。设置列表如下：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Public</td>\n<td>指示响应可以被任何缓存区缓存。</td>\n</tr>\n<tr>\n<td>Private</td>\n<td>指示对于单个用户的的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。</td>\n</tr>\n<tr>\n<td>no-cache</td>\n<td>指示请求或响应消息不能缓存。</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不适用缓存，完全不存下来。</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td>指示客户端可以接收生存期不大于指定时间（以秒为单位）的响应。</td>\n</tr>\n<tr>\n<td>min-fresh</td>\n<td>指示客户端可以接收响应时间小于当前时间加上指定时间的响应。</td>\n</tr>\n<tr>\n<td>max-stale</td>\n<td>指示客户端可以接收超出超时时间的响应消息。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Last-Modified/If-Modified-Since: Last-Modified/If-Modified-Since要配合Cache-Control使用。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Last-Modified</td>\n<td>标识这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Etag</td>\n<td>web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>既生Last-Modified何生Etag？你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：<strong>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间<br>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存<br>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</strong></li>\n<li>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与Etag一起使用时，服务器会优先验证Etag。</li>\n</ul>\n<p>总结以下几种状态码的区别：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200状态</td>\n<td>当浏览器本地有没缓存或者下一层失效时，或者用户强制刷新时，浏览器直接去服务器下载最新数据。</td>\n</tr>\n<tr>\n<td>304状态</td>\n<td>这一层由Last-Modified/Etag控制。当下一层失效时或者用户刷新时，浏览器就会发送请求给服务器，如果服务端没有变化，则返回304给浏览器。</td>\n</tr>\n<tr>\n<td>200状态（from cache）</td>\n<td>这一层由expires/cache-control控制。expires（http 1.0版有效）是绝对时间。cache-control（http 1.1版有效）是相对时间。两者都存在时，cache-control覆盖expores，只要没有失效，浏览器只访问自己的缓存。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"用户行为与缓存\"><a href=\"#用户行为与缓存\" class=\"headerlink\" title=\"用户行为与缓存\"></a>用户行为与缓存</h2><p>浏览器缓存行为与用户的行为有关，总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>用户操作</th>\n<th>Expries/Cache-control</th>\n<th>Last-Modified/Etag</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>地址栏回车</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>页面链接跳转</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>新开窗口</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>前进、后退</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>F5刷新</td>\n<td>无效（BR重置max-age=0）</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>Crtl+F5刷新</td>\n<td>无效（重置CC=no-cache）</td>\n<td>无效（请求头丢弃该选项）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"相关参考\"><a href=\"#相关参考\" class=\"headerlink\" title=\"相关参考\"></a>相关参考</h2><ol>\n<li>浏览器缓存机制：<a href=\"http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></li>\n<li>Web开发人员需知的Web缓存知识：<a href=\"http://www.oschina.net/news/41397/web-cache-knowledge\" target=\"_blank\" rel=\"external\">http://www.oschina.net/news/41397/web-cache-knowledge</a></li>\n<li>浏览器缓存详解:expires,cache-control,last-modified,etag详细说明：<a href=\"http://blog.csdn.net/eroswang/article/details/8302191\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/eroswang/article/details/8302191</a></li>\n<li>在浏览器地址栏按回车、F5、Ctrl+F5刷新网页的区别：<a href=\"http://blog.csdn.net/yui/article/details/6584401\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/yui/article/details/6584401</a></li>\n<li>Cache Control与ETag：<a href=\"https://blog.othree.net/log/2012/12/22/cache-control-and-etag/\" target=\"_blank\" rel=\"external\">https://blog.othree.net/log/2012/12/22/cache-control-and-etag/</a></li>\n<li>缓存的故事：<a href=\"http://segmentfault.com/blog/animabear/1190000000375344\" target=\"_blank\" rel=\"external\">http://segmentfault.com/blog/animabear/1190000000375344</a></li>\n<li>Google的PageSpeed网站优化理论中提到使用Etag可以减少服务器负担：<a href=\"https://developers.google.com/speed/docs/pss/AddEtags\" target=\"_blank\" rel=\"external\">https://developers.google.com/speed/docs/pss/AddEtags</a></li>\n<li>yahoo的Yslow法则中则提示谨慎设置Etag：<a href=\"http://developer.yahoo.com/performance/rules.html#etags\" target=\"_blank\" rel=\"external\">http://developer.yahoo.com/performance/rules.html#etags</a></li>\n</ol>\n"}],"PostAsset":[{"_id":"source/_posts/JS实现快速排序/post-bg-js-version.jpg","slug":"post-bg-js-version.jpg","post":"cjagvsnjk00034ouv9ihqeuhc","modified":0,"renderable":0},{"_id":"source/_posts/hello-blog/post-bg-unix-linux.jpg","slug":"post-bg-unix-linux.jpg","post":"cjagvsnjp00094ouv4ki5t0nz","modified":0,"renderable":0},{"_id":"source/_posts/javascript-module-loader/post-bg-js-module.jpg","slug":"post-bg-js-module.jpg","post":"cjagvsnjr000c4ouve7tarv8r","modified":0,"renderable":0},{"_id":"source/_posts/实现链式LazyMan/post-bg-js-version.jpg","slug":"post-bg-js-version.jpg","post":"cjagvsnjt000f4ouvcayhe95t","modified":0,"renderable":0},{"_id":"source/_posts/about-javascript/javascript-java.jpg","slug":"javascript-java.jpg","post":"cjagvsnjo00084ouvxa04z9tz","modified":0,"renderable":0},{"_id":"source/_posts/about-javascript/keep-calm-and-learn-javascript.png","slug":"keep-calm-and-learn-javascript.png","post":"cjagvsnjo00084ouvxa04z9tz","modified":0,"renderable":0},{"_id":"source/_posts/about-javascript/post-bg-js-version.jpg","slug":"post-bg-js-version.jpg","post":"cjagvsnjo00084ouvxa04z9tz","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjagvsnjg00014ouvielm5q3h","tag_id":"cjagvsnjm00054ouv6sx6ys9g","_id":"cjagvsnjr000b4ouvx0u4rrpv"},{"post_id":"cjagvsnjt000f4ouvcayhe95t","tag_id":"cjagvsnjq000a4ouvrj4moxf7","_id":"cjagvsnjv000i4ouvqijkpq5b"},{"post_id":"cjagvsnjt000f4ouvcayhe95t","tag_id":"cjagvsnjt000e4ouvkqqerv1f","_id":"cjagvsnjx000k4ouv3uxtl963"},{"post_id":"cjagvsnjk00034ouv9ihqeuhc","tag_id":"cjagvsnjq000a4ouvrj4moxf7","_id":"cjagvsnjy000n4ouvmgveomup"},{"post_id":"cjagvsnjk00034ouv9ihqeuhc","tag_id":"cjagvsnjt000e4ouvkqqerv1f","_id":"cjagvsnjz000o4ouvxgs3ljah"},{"post_id":"cjagvsnju000g4ouvt68ewrp9","tag_id":"cjagvsnjq000a4ouvrj4moxf7","_id":"cjagvsnjz000q4ouvtsovt9w6"},{"post_id":"cjagvsnju000g4ouvt68ewrp9","tag_id":"cjagvsnjt000e4ouvkqqerv1f","_id":"cjagvsnjz000r4ouvy8uhdqdt"},{"post_id":"cjagvsnjw000j4ouv894cp3qj","tag_id":"cjagvsnjq000a4ouvrj4moxf7","_id":"cjagvsnjz000s4ouv7tld8ka8"},{"post_id":"cjagvsnjn00064ouvrnyqpbph","tag_id":"cjagvsnjq000a4ouvrj4moxf7","_id":"cjagvsnjz000u4ouv67o6oiwh"},{"post_id":"cjagvsnjn00064ouvrnyqpbph","tag_id":"cjagvsnjt000e4ouvkqqerv1f","_id":"cjagvsnk0000v4ouvf6g54c97"},{"post_id":"cjagvsnjo00084ouvxa04z9tz","tag_id":"cjagvsnjz000p4ouv2qh99piq","_id":"cjagvsnk0000x4ouvqs94on4j"},{"post_id":"cjagvsnjo00084ouvxa04z9tz","tag_id":"cjagvsnjz000t4ouvgqeu0cne","_id":"cjagvsnk0000y4ouv9487eroa"},{"post_id":"cjagvsnjp00094ouv4ki5t0nz","tag_id":"cjagvsnk0000w4ouv4kzvm6bq","_id":"cjagvsnk000104ouvzc3glw4a"},{"post_id":"cjagvsnjr000c4ouve7tarv8r","tag_id":"cjagvsnk0000z4ouv1i4maqvh","_id":"cjagvsnk200134ouvtsz4a1hk"},{"post_id":"cjagvsnjr000c4ouve7tarv8r","tag_id":"cjagvsnjz000p4ouv2qh99piq","_id":"cjagvsnk200144ouvk28nvu6b"},{"post_id":"cjagvsnjs000d4ouvmul8pc7p","tag_id":"cjagvsnjq000a4ouvrj4moxf7","_id":"cjagvsnk200164ouvw1hyp136"},{"post_id":"cjagvsnjs000d4ouvmul8pc7p","tag_id":"cjagvsnjt000e4ouvkqqerv1f","_id":"cjagvsnk300174ouv5fbhnmiu"},{"post_id":"cjagvsnjx000l4ouv0cvi9eax","tag_id":"cjagvsnk200154ouvg84suud0","_id":"cjagvsnk300184ouv5qvnisg2"}],"Tag":[{"name":"React","_id":"cjagvsnjm00054ouv6sx6ys9g"},{"name":"JS","_id":"cjagvsnjq000a4ouvrj4moxf7"},{"name":"前端面试","_id":"cjagvsnjt000e4ouvkqqerv1f"},{"name":"JavaScript","_id":"cjagvsnjz000p4ouv2qh99piq"},{"name":"翻译","_id":"cjagvsnjz000t4ouvgqeu0cne"},{"name":"生活","_id":"cjagvsnk0000w4ouv4kzvm6bq"},{"name":"前端开发","_id":"cjagvsnk0000z4ouv1i4maqvh"},{"name":"前端基础","_id":"cjagvsnk200154ouvg84suud0"}]}}
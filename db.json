{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/tag-bg.jpg","path":"img/tag-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/home-bg-o.jpg","path":"img/home-bg-o.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.css","path":"css/hux-blog.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"themes/huxblog/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490629254631},{"_id":"source/404.md","hash":"8d0d831a77fe92a9e1530366ed90dec6d73d3aef","modified":1490629254537},{"_id":"source/CNAME","hash":"380684ab67adbffcd99a9d75ce51da32425c84b6","modified":1490629797236},{"_id":"themes/huxblog/LICENSE","hash":"c48eaae47a703282e0ffe7b91d69366452046214","modified":1490629254631},{"_id":"themes/huxblog/_config.yml","hash":"3c458e042f452e22ad3aa87001bc30970f5aa077","modified":1490629254631},{"_id":"source/_posts/about-javascript.md","hash":"e010bf9a68eb83c58baf021125fa2e736ff76364","modified":1490629254537},{"_id":"source/_posts/hello-blog.md","hash":"dd95269aeab2a7e30197244636f7192f4aabe263","modified":1490629254552},{"_id":"source/_posts/javascript-module-loader.md","hash":"c9a3e4a978a2e0ad1a75f852864e645d356600c3","modified":1490629254568},{"_id":"source/_posts/实现链式LazyMan.md","hash":"5c5da7054d0e7712e7562a054e2cd7dcf5f95c59","modified":1492348829763},{"_id":"source/about/index.md","hash":"810fd4abd0dadfe3e812258fd06f9ba6f34a5600","modified":1490629254584},{"_id":"source/archives/index.md","hash":"b0f0f87f4ea983caebc293c8dabef1c6f6dd110d","modified":1490629254584},{"_id":"source/img/avatar.jpg","hash":"49cfa597392c4a116584c07690efbbc06354acc7","modified":1490629254599},{"_id":"source/img/favicon.ico","hash":"a8ee7712f6560180efccb68546de6ea0d937fff3","modified":1490629254599},{"_id":"source/img/icon_wechat.png","hash":"7fdb00c9017236e05c1b3e6da38a2cc382fd69fa","modified":1490629254615},{"_id":"source/tags/index.md","hash":"bc710b5b8db6f01940957ce744a37fd564752c3b","modified":1490629254631},{"_id":"themes/huxblog/languages_to_be_added/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1490629254646},{"_id":"themes/huxblog/languages_to_be_added/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1490629254646},{"_id":"themes/huxblog/languages_to_be_added/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1490629254646},{"_id":"themes/huxblog/languages_to_be_added/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1490629254646},{"_id":"themes/huxblog/languages_to_be_added/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1490629254646},{"_id":"themes/huxblog/languages_to_be_added/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1490629254662},{"_id":"themes/huxblog/languages_to_be_added/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1490629254662},{"_id":"themes/huxblog/languages_to_be_added/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1490629254662},{"_id":"themes/huxblog/languages_to_be_added/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1490629254662},{"_id":"themes/huxblog/layout/404.ejs","hash":"c9b488d74c21fe9f35f642a5d19a138099ddf8a8","modified":1490629254677},{"_id":"themes/huxblog/layout/about.ejs","hash":"0671d30031c2c64dc4d8ef8a3b7632ddce38c6d1","modified":1490629254787},{"_id":"themes/huxblog/layout/archive.ejs","hash":"6c3ed5d914379319efe835a4aa505abbc616c328","modified":1490629254787},{"_id":"themes/huxblog/layout/archives.ejs","hash":"75665b1537a56be6f227fd05ca21ae0e7af82e6e","modified":1490629254802},{"_id":"themes/huxblog/layout/index.ejs","hash":"fe992342f8f96f87521c78cc3a164ff01086aa9b","modified":1490629254818},{"_id":"themes/huxblog/layout/keynote.ejs","hash":"e177b9e4a159f40b512f4ae1bfd928be4ab60840","modified":1490629254865},{"_id":"themes/huxblog/layout/layout.ejs","hash":"a98fcc3a80f9e9cdedf3a613ff402806f8de7218","modified":1490629254865},{"_id":"themes/huxblog/layout/page.ejs","hash":"b38e42a4bd0364755d341c4897a46a3acd62a0fd","modified":1490629254900},{"_id":"themes/huxblog/layout/post.ejs","hash":"63a269d180a78e72e2ff5853ab579cf59ac943fa","modified":1490629254947},{"_id":"themes/huxblog/layout/tags.ejs","hash":"3b5cb37b097895e6045b4dca91b8d4e39535f806","modified":1490629254963},{"_id":"source/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1490629254631},{"_id":"source/_posts/about-javascript/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1490629254552},{"_id":"source/_posts/about-javascript/keep-calm-and-learn-javascript.png","hash":"49ea101b92ce5e136a19e6b11162f8f4126fe01f","modified":1490629254537},{"_id":"source/_posts/实现链式LazyMan/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1490629254552},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1490629254584},{"_id":"source/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1490629254615},{"_id":"themes/huxblog/layout/_partial/footer.ejs","hash":"5ac7025be02d6d6a605e7e20d02afaab1506fca3","modified":1490629254740},{"_id":"themes/huxblog/layout/_partial/head.ejs","hash":"40d885fe82dc350f16698565440ddced47aeda3b","modified":1490629254756},{"_id":"themes/huxblog/layout/_partial/nav.ejs","hash":"e65bfec3d14a9eb9f1e09b592bb34023e6bf6e83","modified":1490629254771},{"_id":"themes/huxblog/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1490629254771},{"_id":"themes/huxblog/source/css/highlight.styl","hash":"831f8195f3577ba5bea374f2e24b90054d445055","modified":1490629254978},{"_id":"themes/huxblog/source/css/hux-blog.css","hash":"50e36726c65ec8c6428ccbc375bcab79f76f2bc8","modified":1490629254978},{"_id":"themes/huxblog/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1490629254978},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1490629254994},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1490629255010},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1490629255025},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1490629255025},{"_id":"themes/huxblog/source/js/bootstrap.min.js","hash":"313da686ebbe387064f2d1899c64ea562b81eb40","modified":1490629255072},{"_id":"themes/huxblog/source/js/hux-blog.js","hash":"3d3c93e42a9990b2a2e6df5a08e9816f9a221e0f","modified":1490629255088},{"_id":"themes/huxblog/source/js/hux-blog.min.js","hash":"ee99af17a1a69ac8d85a695fed0349ba202789ae","modified":1490629255088},{"_id":"themes/huxblog/source/js/jquery.nav.js","hash":"bc6383fa2aa8f437978cf044a3b6f10a65114398","modified":1490629255197},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","hash":"448017ff32f75f444ed7985d10a21b3ad92ab100","modified":1490629255197},{"_id":"source/_posts/about-javascript/javascript-java.jpg","hash":"881e35e241a8be40f3c4e3a6f57d5402247c1eb3","modified":1490629254537},{"_id":"source/_posts/hello-blog/post-bg-unix-linux.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1490629254552},{"_id":"source/_posts/javascript-module-loader/post-bg-js-module.jpg","hash":"4a43bfa6b69c79a6ef90bd852fe5756d241733cd","modified":1490629254568},{"_id":"source/img/home-bg.jpg","hash":"a191201c3a98728e6ea66d6827df827ecfcc9d33","modified":1490629254615},{"_id":"themes/huxblog/source/css/bootstrap.min.css","hash":"d2333a926ae25bbd3056814f13fec0843468e49e","modified":1490629254963},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1490629255010},{"_id":"themes/huxblog/source/js/bootstrap.js","hash":"5d69034fb6eded2e5961ea54dd47129a88cd5182","modified":1490629255041},{"_id":"themes/huxblog/source/js/jquery.min.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1490629255166},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1490629254599},{"_id":"themes/huxblog/source/css/bootstrap.css","hash":"d1a24afac31222d70b4e001e0361ef045aa42043","modified":1490629254963},{"_id":"themes/huxblog/source/js/jquery.js","hash":"4bb763dc96da604aed08ac024a1a3f5de73eea39","modified":1490629255135},{"_id":"source/img/about-bg.jpg","hash":"b5814b2d10eb38dfda0072365567f3823bc34aba","modified":1490629254599},{"_id":"public/404.html","hash":"d5ef2f785e44c365485d15535675c1c7c8a86875","modified":1492348888862},{"_id":"public/archives/index.html","hash":"0ba7b903cd5b69cc4bfcf18adb085c8c88cdbc3e","modified":1492348888862},{"_id":"public/i_dont_wanna_use_default_archives/index.html","hash":"09c3280ced9020da81845d5c56709fa1a082f43f","modified":1492348888863},{"_id":"public/i_dont_wanna_use_default_archives/2017/index.html","hash":"7bd99d4dd7423ed4b20a8fe20f6c4190147b0fa9","modified":1492348888863},{"_id":"public/i_dont_wanna_use_default_archives/2017/03/index.html","hash":"66cdc72b18a4863044c855283c8a6801abb46d0c","modified":1492348888863},{"_id":"public/i_dont_wanna_use_default_archives/2017/04/index.html","hash":"f6dc275069bffeb94d405212b9897db684551512","modified":1492348888863},{"_id":"public/tags/JavaScript/index.html","hash":"861594e389c5640b1970e666ffeb06b9b73562fb","modified":1492348888863},{"_id":"public/tags/翻译/index.html","hash":"83a5c316ad50afd88506edf29c060df9e5a24e20","modified":1492348888864},{"_id":"public/tags/生活/index.html","hash":"a60ed607d637e6f6b216d86f743c0de6cbdc6e86","modified":1492348888864},{"_id":"public/tags/前端开发/index.html","hash":"ade1642029b6caf82101d42d4ee6220db0f13b2b","modified":1492348888864},{"_id":"public/tags/JS/index.html","hash":"ecce4fb4d338e5728d4ba9e150c8965849c9d404","modified":1492348888864},{"_id":"public/tags/前端面试/index.html","hash":"ce14f7209588aba52ed702307c162c024819636e","modified":1492348888864},{"_id":"public/tags/index.html","hash":"85629e21bf0dad8b373cc8ef12977e8119cf5060","modified":1492348888865},{"_id":"public/2017/04/09/实现链式LazyMan/index.html","hash":"7f17a536ace38669c2ee1d9a5a9d49a6cc852587","modified":1492348888865},{"_id":"public/2017/03/23/javascript-module-loader/index.html","hash":"0fff8fbf74cb36c1aef6f0d3c89c38e10c62b73c","modified":1492348888867},{"_id":"public/2017/03/23/about-javascript/index.html","hash":"03eb3fa1324b9a390e551a3030930c81d2a46ca9","modified":1492348888868},{"_id":"public/2017/03/18/hello-blog/index.html","hash":"d14e8e53a4c986b5c9bbc002511afeaaebcf5f4b","modified":1492348888868},{"_id":"public/about/index.html","hash":"a3cbe48621130b7159e7c06601309425827fb719","modified":1492348888868},{"_id":"public/index.html","hash":"1cc0f88303aba82d0ddb882662081f5b49967899","modified":1492348888868},{"_id":"public/CNAME","hash":"380684ab67adbffcd99a9d75ce51da32425c84b6","modified":1492348888901},{"_id":"public/img/avatar.jpg","hash":"49cfa597392c4a116584c07690efbbc06354acc7","modified":1492348888901},{"_id":"public/img/favicon.ico","hash":"a8ee7712f6560180efccb68546de6ea0d937fff3","modified":1492348888901},{"_id":"public/img/icon_wechat.png","hash":"7fdb00c9017236e05c1b3e6da38a2cc382fd69fa","modified":1492348888901},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1492348888902},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1492348888902},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1492348888902},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1492348888902},{"_id":"public/2017/04/09/实现链式LazyMan/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1492348888902},{"_id":"public/2017/03/23/about-javascript/keep-calm-and-learn-javascript.png","hash":"49ea101b92ce5e136a19e6b11162f8f4126fe01f","modified":1492348888902},{"_id":"public/2017/03/23/about-javascript/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1492348888902},{"_id":"public/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1492348889503},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1492348889504},{"_id":"public/2017/03/18/hello-blog/post-bg-unix-linux.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1492348889508},{"_id":"public/2017/03/23/javascript-module-loader/post-bg-js-module.jpg","hash":"4a43bfa6b69c79a6ef90bd852fe5756d241733cd","modified":1492348889508},{"_id":"public/2017/03/23/about-javascript/javascript-java.jpg","hash":"881e35e241a8be40f3c4e3a6f57d5402247c1eb3","modified":1492348889508},{"_id":"public/css/highlight.css","hash":"8bc5e670b028eda8097f58bdc85269c5124c2951","modified":1492348889518},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1492348889519},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1492348889519},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1492348889519},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1492348889519},{"_id":"public/css/hux-blog.css","hash":"c1b0a32ad8075ac09d99fb4d64a9fbc84163abf8","modified":1492348889519},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1492348889519},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1492348889519},{"_id":"public/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1492348889520},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1492348889520},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1492348889520},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1492348889520},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1492348889520},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1492348889520},{"_id":"public/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1492348889520},{"_id":"public/img/home-bg.jpg","hash":"a191201c3a98728e6ea66d6827df827ecfcc9d33","modified":1492348889564},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1492348889568},{"_id":"public/img/about-bg.jpg","hash":"b5814b2d10eb38dfda0072365567f3823bc34aba","modified":1492348890066}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2017-03-27T15:40:54.537Z","updated":"2017-03-27T15:40:54.537Z","path":"404.html","title":"","comments":1,"_id":"cj1kpzv2m0000k0e31us225g0","content":"","excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Hey, this is me.","header-img":"img/about-bg.jpg","comments":1,"_content":"\n\n>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。--Breaking Bad.\n>写写代码，过好生活，思考人生.\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Hey, this is me.\"\nheader-img: \"img/about-bg.jpg\"\ncomments: true\n---\n\n\n>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。--Breaking Bad.\n>写写代码，过好生活，思考人生.\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","updated":"2017-03-27T15:40:54.584Z","path":"about/index.html","_id":"cj1kpzv3r0002k0e3k4g5zkjl","content":"<blockquote>\n<p>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。–Breaking Bad.<br>写写代码，过好生活，思考人生.</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\" target=\"_blank\" rel=\"external\">李书航 － 什么是「共产中文腔调」？ </a><br></p>","excerpt":"","more":"<blockquote>\n<p>你永远没有你想象中的那么坚定，也没有想象中的那么好。那些危险的因子永远存在于你内心的一部分。–Breaking Bad.<br>写写代码，过好生活，思考人生.</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a><br></p>"},{"layout":"archives","title":"Archives","description":"Yo~ Man. go go go!","header-img":"img/tag-bg.jpg","_content":"","source":"archives/index.md","raw":"---\nlayout: \"archives\"\ntitle: \"Archives\"\ndescription: \"Yo~ Man. go go go!\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2017-03-27T15:40:54.584Z","updated":"2017-03-27T15:40:54.584Z","path":"archives/index.html","comments":1,"_id":"cj1kpzv3y0004k0e32j4kmmro","content":"","excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/tag-bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2017-03-27T15:40:54.631Z","updated":"2017-03-27T15:40:54.631Z","path":"tags/index.html","comments":1,"_id":"cj1kpzv480007k0e3r9uvy93z","content":"","excerpt":"","more":""}],"Post":[{"layout":"post","title":"About Javascript","date":"2017-03-22T16:00:00.000Z","author":"chaoming","header-img":"post-bg-js-version.jpg","_content":"\n\nJavaScript 有着很奇怪的命名史。\n\n1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript *（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）*\n\n![java-javascript](javascript-java.jpg)\n<small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small>\n\n> 译者注：[wikipedia 的 JavaScript 词条](https://en.wikipedia.org/wiki/JavaScript#History) 更详细的叙述了这段历史\n\n1996 年，网景将 JavaScript 提交给 [ECMA International（欧洲计算机制造商协会）](http://www.ecma-international.org/) 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。\n\n\n> 术语（译者注）：\n>\n> * *标准（Standard）*： 用于定义与其他事物区别的一套规则\n> * *实现（Implementation）*： 某个标准的具体实施/真实实践\n\n\n不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。\n\n> 译者注：[ECMAScript 第四版草案](https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29)由于太过激进而被抛弃，Adobe 的 [ActionScript 3.0](https://en.wikipedia.org/wiki/ActionScript) 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）\n\n到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）\n\n目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 [decorators（装饰者）](https://github.com/wycats/javascript-decorators)，[async-await（async-await 异步编程模型）](https://github.com/lukehoban/ecmascript-asyncawait) 和 [static class properties（静态类属性）](https://github.com/jeffmo/es-class-properties)。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 [Babel 的官网](https://babeljs.io/docs/usage/experimental/) 上查看各个提案目前都在哪个阶段了。\n\n所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：\n\n* **ECMAScript**：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。\n* **JavaScript**：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。\n* **ECMAScript 5 (ES5)**：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。\n* **ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)**：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅[这张兼容性表](http://kangax.github.io/compat-table/es6/)来查看不同浏览器和工具的实现情况。\n* **ECMAScript 2016**：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定\n* **ECMAScript Proposals**：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。\n\n在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。\n\n#### 一些资源\n\n\n\n* TC39 的 [Github 仓库](https://github.com/tc39/ecma262)上可以看到所有目前公开的提案\n* 如果你还不熟悉 ES6，Babel 有一个[很不错的特性概览](https://babeljs.io/docs/learn-es2015/)\n* 如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 [Exploring ES6](http://exploringjs.com/)和 Nicholas Zakas 的 [Understanding ECMAScript 6](https://leanpub.com/understandinges6)。Axel 的博客 [2ality](http://www.2ality.com/) 也是很不错的 ES6 资源\n\n<img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\" />\n<small class=\"img-hint\">来学 JavaScript 吧！</small>\n\n#### 著作权声明\n\n本文译自 [ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?](http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/)\n译者 [黄玄](http://weibo.com/huxpro)，转载请保留以上链接。\n学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。\n\n\n","source":"_posts/about-javascript.md","raw":"---\nlayout:     post\ntitle:      \"About Javascript\"\ndate:       2017-03-23\nauthor:     \"chaoming\"\nheader-img: \"post-bg-js-version.jpg\"\ntags:\n    - JavaScript\n    - 翻译\n---\n\n\nJavaScript 有着很奇怪的命名史。\n\n1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript *（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）*\n\n![java-javascript](javascript-java.jpg)\n<small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small>\n\n> 译者注：[wikipedia 的 JavaScript 词条](https://en.wikipedia.org/wiki/JavaScript#History) 更详细的叙述了这段历史\n\n1996 年，网景将 JavaScript 提交给 [ECMA International（欧洲计算机制造商协会）](http://www.ecma-international.org/) 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。\n\n\n> 术语（译者注）：\n>\n> * *标准（Standard）*： 用于定义与其他事物区别的一套规则\n> * *实现（Implementation）*： 某个标准的具体实施/真实实践\n\n\n不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。\n\n> 译者注：[ECMAScript 第四版草案](https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29)由于太过激进而被抛弃，Adobe 的 [ActionScript 3.0](https://en.wikipedia.org/wiki/ActionScript) 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）\n\n到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）\n\n目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 [decorators（装饰者）](https://github.com/wycats/javascript-decorators)，[async-await（async-await 异步编程模型）](https://github.com/lukehoban/ecmascript-asyncawait) 和 [static class properties（静态类属性）](https://github.com/jeffmo/es-class-properties)。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 [Babel 的官网](https://babeljs.io/docs/usage/experimental/) 上查看各个提案目前都在哪个阶段了。\n\n所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：\n\n* **ECMAScript**：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。\n* **JavaScript**：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。\n* **ECMAScript 5 (ES5)**：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。\n* **ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)**：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅[这张兼容性表](http://kangax.github.io/compat-table/es6/)来查看不同浏览器和工具的实现情况。\n* **ECMAScript 2016**：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定\n* **ECMAScript Proposals**：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。\n\n在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。\n\n#### 一些资源\n\n\n\n* TC39 的 [Github 仓库](https://github.com/tc39/ecma262)上可以看到所有目前公开的提案\n* 如果你还不熟悉 ES6，Babel 有一个[很不错的特性概览](https://babeljs.io/docs/learn-es2015/)\n* 如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 [Exploring ES6](http://exploringjs.com/)和 Nicholas Zakas 的 [Understanding ECMAScript 6](https://leanpub.com/understandinges6)。Axel 的博客 [2ality](http://www.2ality.com/) 也是很不错的 ES6 资源\n\n<img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\" />\n<small class=\"img-hint\">来学 JavaScript 吧！</small>\n\n#### 著作权声明\n\n本文译自 [ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?](http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/)\n译者 [黄玄](http://weibo.com/huxpro)，转载请保留以上链接。\n学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。\n\n\n","slug":"about-javascript","published":1,"updated":"2017-03-27T15:40:54.537Z","comments":1,"photos":[],"link":"","_id":"cj1kpzv3m0001k0e3nt0krp96","content":"<p>JavaScript 有着很奇怪的命名史。</p>\n<p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p>\n<p><img src=\"javascript-java.jpg\" alt=\"java-javascript\"><br><small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small></p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/JavaScript#History\" target=\"_blank\" rel=\"external\">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p>\n</blockquote>\n<p>1996 年，网景将 JavaScript 提交给 <a href=\"http://www.ecma-international.org/\" target=\"_blank\" rel=\"external\">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p>\n<blockquote>\n<p>术语（译者注）：</p>\n<ul>\n<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>\n<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>\n</ul>\n</blockquote>\n<p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29\" target=\"_blank\" rel=\"external\">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href=\"https://en.wikipedia.org/wiki/ActionScript\" target=\"_blank\" rel=\"external\">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p>\n</blockquote>\n<p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p>\n<p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href=\"https://github.com/wycats/javascript-decorators\" target=\"_blank\" rel=\"external\">decorators（装饰者）</a>，<a href=\"https://github.com/lukehoban/ecmascript-asyncawait\" target=\"_blank\" rel=\"external\">async-await（async-await 异步编程模型）</a> 和 <a href=\"https://github.com/jeffmo/es-class-properties\" target=\"_blank\" rel=\"external\">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href=\"https://babeljs.io/docs/usage/experimental/\" target=\"_blank\" rel=\"external\">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p>\n<p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p>\n<ul>\n<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>\n<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>\n<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>\n<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"external\">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>\n<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>\n<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>\n</ul>\n<p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p>\n<h4 id=\"一些资源\"><a href=\"#一些资源\" class=\"headerlink\" title=\"一些资源\"></a>一些资源</h4><ul>\n<li>TC39 的 <a href=\"https://github.com/tc39/ecma262\" target=\"_blank\" rel=\"external\">Github 仓库</a>上可以看到所有目前公开的提案</li>\n<li>如果你还不熟悉 ES6，Babel 有一个<a href=\"https://babeljs.io/docs/learn-es2015/\" target=\"_blank\" rel=\"external\">很不错的特性概览</a></li>\n<li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href=\"http://exploringjs.com/\" target=\"_blank\" rel=\"external\">Exploring ES6</a>和 Nicholas Zakas 的 <a href=\"https://leanpub.com/understandinges6\" target=\"_blank\" rel=\"external\">Understanding ECMAScript 6</a>。Axel 的博客 <a href=\"http://www.2ality.com/\" target=\"_blank\" rel=\"external\">2ality</a> 也是很不错的 ES6 资源</li>\n</ul>\n<p><img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\"><br><small class=\"img-hint\">来学 JavaScript 吧！</small></p>\n<h4 id=\"著作权声明\"><a href=\"#著作权声明\" class=\"headerlink\" title=\"著作权声明\"></a>著作权声明</h4><p>本文译自 <a href=\"http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/\" target=\"_blank\" rel=\"external\">ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?</a><br>译者 <a href=\"http://weibo.com/huxpro\" target=\"_blank\" rel=\"external\">黄玄</a>，转载请保留以上链接。<br>学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。</p>\n","excerpt":"","more":"<p>JavaScript 有着很奇怪的命名史。</p>\n<p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p>\n<p><img src=\"javascript-java.jpg\" alt=\"java-javascript\"><br><small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small></p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/JavaScript#History\">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p>\n</blockquote>\n<p>1996 年，网景将 JavaScript 提交给 <a href=\"http://www.ecma-international.org/\">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p>\n<blockquote>\n<p>术语（译者注）：</p>\n<ul>\n<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>\n<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>\n</ul>\n</blockquote>\n<p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29\">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href=\"https://en.wikipedia.org/wiki/ActionScript\">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p>\n</blockquote>\n<p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p>\n<p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href=\"https://github.com/wycats/javascript-decorators\">decorators（装饰者）</a>，<a href=\"https://github.com/lukehoban/ecmascript-asyncawait\">async-await（async-await 异步编程模型）</a> 和 <a href=\"https://github.com/jeffmo/es-class-properties\">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href=\"https://babeljs.io/docs/usage/experimental/\">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p>\n<p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p>\n<ul>\n<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>\n<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>\n<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>\n<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href=\"http://kangax.github.io/compat-table/es6/\">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>\n<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>\n<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>\n</ul>\n<p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p>\n<h4 id=\"一些资源\"><a href=\"#一些资源\" class=\"headerlink\" title=\"一些资源\"></a>一些资源</h4><ul>\n<li>TC39 的 <a href=\"https://github.com/tc39/ecma262\">Github 仓库</a>上可以看到所有目前公开的提案</li>\n<li>如果你还不熟悉 ES6，Babel 有一个<a href=\"https://babeljs.io/docs/learn-es2015/\">很不错的特性概览</a></li>\n<li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href=\"http://exploringjs.com/\">Exploring ES6</a>和 Nicholas Zakas 的 <a href=\"https://leanpub.com/understandinges6\">Understanding ECMAScript 6</a>。Axel 的博客 <a href=\"http://www.2ality.com/\">2ality</a> 也是很不错的 ES6 资源</li>\n</ul>\n<p><img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\" /><br><small class=\"img-hint\">来学 JavaScript 吧！</small></p>\n<h4 id=\"著作权声明\"><a href=\"#著作权声明\" class=\"headerlink\" title=\"著作权声明\"></a>著作权声明</h4><p>本文译自 <a href=\"http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/\">ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?</a><br>译者 <a href=\"http://weibo.com/huxpro\">黄玄</a>，转载请保留以上链接。<br>学习JavaScript那么久，无意之间看到这篇介绍，挺有意思特意转载。</p>\n"},{"layout":"post","title":"Welcome to Chaoming Blog","subtitle":" \"Hello World, Hello Blog\"","date":"2017-03-18T03:23:26.000Z","author":"Damon","header-img":"post-bg-unix-linux.jpg","_content":"\n> “Yeah It's on. ”\n\n\n## 前言\n\nChaoming 的 Blog 就这么开通了。\n\n[跳过废话，直接看技术实现 ](#build)\n\n\n\n2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。\n\n\n作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。\n\n这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!\n<p id = \"build\"></p>\n---\n\n## 正文\n\n接下来说说搭建这个博客的技术细节。  \n\nHexo其优点非常明显：\n\n* **Markdown** 带来的优雅写作体验\n* 非常熟悉的 Git workflow ，**Git Commit 即 Blog Post**\n* 利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机\n    * 如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了\n\n\n本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个[镜像](http://huxpro.gitcafe.io)出来，结果还是巨慢。\n\n哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 **pending 在了 Google Fonts** 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。  \n忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!\n\n---\n\n配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。\n\nTheme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接**hexo d**提交到自己github上。这真的超级方便！瞬间爱上Hexo！\n\n不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用**hexo d**提交代码的时候就出事了,直接报错&%$*&^*%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。\n\n最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。\n\n以后，好好说话呗。。。\n\n\n\n","source":"_posts/hello-blog.md","raw":"---\nlayout:     post\ntitle:      \"Welcome to Chaoming Blog\"\nsubtitle:   \" \\\"Hello World, Hello Blog\\\"\"\ndate:       2017-03-18 11:23:26\nauthor:     \"Damon\"\nheader-img: \"post-bg-unix-linux.jpg\"\ntags:\n    - 生活\n---\n\n> “Yeah It's on. ”\n\n\n## 前言\n\nChaoming 的 Blog 就这么开通了。\n\n[跳过废话，直接看技术实现 ](#build)\n\n\n\n2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。\n\n\n作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。\n\n这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!\n<p id = \"build\"></p>\n---\n\n## 正文\n\n接下来说说搭建这个博客的技术细节。  \n\nHexo其优点非常明显：\n\n* **Markdown** 带来的优雅写作体验\n* 非常熟悉的 Git workflow ，**Git Commit 即 Blog Post**\n* 利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机\n    * 如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了\n\n\n本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个[镜像](http://huxpro.gitcafe.io)出来，结果还是巨慢。\n\n哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 **pending 在了 Google Fonts** 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。  \n忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!\n\n---\n\n配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。\n\nTheme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接**hexo d**提交到自己github上。这真的超级方便！瞬间爱上Hexo！\n\n不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用**hexo d**提交代码的时候就出事了,直接报错&%$*&^*%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。\n\n最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。\n\n以后，好好说话呗。。。\n\n\n\n","slug":"hello-blog","published":1,"updated":"2017-03-27T15:40:54.552Z","comments":1,"photos":[],"link":"","_id":"cj1kpzv3u0003k0e34sll07ys","content":"<blockquote>\n<p>“Yeah It’s on. ”</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Chaoming 的 Blog 就这么开通了。</p>\n<p><a href=\"#build\">跳过废话，直接看技术实现 </a></p>\n<p>2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。</p>\n<p>作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。</p>\n<p>这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p id=\"build\"></p></h2><h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p>\n<p>Hexo其优点非常明显：</p>\n<ul>\n<li><strong>Markdown</strong> 带来的优雅写作体验</li>\n<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>\n<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机<ul>\n<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li>\n</ul>\n</li>\n</ul>\n<p>本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个<a href=\"http://huxpro.gitcafe.io\" target=\"_blank\" rel=\"external\">镜像</a>出来，结果还是巨慢。</p>\n<p>哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 <strong>pending 在了 Google Fonts</strong> 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。<br>忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!</p>\n<hr>\n<p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。</p>\n<p>Theme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接<strong>hexo d</strong>提交到自己github上。这真的超级方便！瞬间爱上Hexo！</p>\n<p>不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用<strong>hexo d</strong>提交代码的时候就出事了,直接报错&amp;%$<em>&amp;^</em>%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。</p>\n<p>最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。</p>\n<p>以后，好好说话呗。。。</p>\n","excerpt":"","more":"<blockquote>\n<p>“Yeah It’s on. ”</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Chaoming 的 Blog 就这么开通了。</p>\n<p><a href=\"#build\">跳过废话，直接看技术实现 </a></p>\n<p>2017 年，学习web前端快2年了,终于抽出了时间把自己的博客搞起来。让文字有个安身的地方。</p>\n<p>作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。</p>\n<p>这段时间上github的时候hexo引起了我的注意，hexo理念是快速简洁,加上可以使用Markdown语法写博文,正合我胃口!</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p id = \"build\"></p></h2><h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p>\n<p>Hexo其优点非常明显：</p>\n<ul>\n<li><strong>Markdown</strong> 带来的优雅写作体验</li>\n<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>\n<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机<ul>\n<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li>\n</ul>\n</li>\n</ul>\n<p>本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个<a href=\"http://huxpro.gitcafe.io\">镜像</a>出来，结果还是巨慢。</p>\n<p>哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 <strong>pending 在了 Google Fonts</strong> 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。<br>忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了!</p>\n<hr>\n<p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手。</p>\n<p>Theme 我是直接使用huxblog的主题,因为绝命毒师头像一下子吸引了我,最爱这部神美剧了有木有。加上自己懒得重新布局页面的，全部沿用huxblog的主题元素。这么一来,博客一下午弄了3个小时就上线了，直接<strong>hexo d</strong>提交到自己github上。这真的超级方便！瞬间爱上Hexo！</p>\n<p>不得不说，提交git的时候遇到了一个小坑。因为我写这个Markdown的时候用的命令行是sublimetext提供的powershell，运行啊，开服务啊之类的都通通不是问题。但是到了我使用<strong>hexo d</strong>提交代码的时候就出事了,直接报错&amp;%$<em>&amp;^</em>%^。 气死~  后来才找到原因，原来powershell没有权限让我输入git的用户名和密码，所以才提交失败。后来立马换上git bash命令行，果然瞬间解决了问题，就是上传速度还是硬伤（一如既往的慢）。</p>\n<p>最后，博客顺利上线。决定以后要多写写文字，多弄弄博客，在写这篇博文的过程中，才发现自己的文字表达能力比起以前退步很多很多，有时候词穷了，有时候逻辑不清晰了，各种毛病。一句话总结就是，不能好好说话了。</p>\n<p>以后，好好说话呗。。。</p>\n"},{"layout":"post","title":"JS模块加载","subtitle":"CommonJS，RequireJS，SeaJS 归纳笔记","date":"2017-03-23T14:45:58.000Z","author":"Damon","catalog":true,"header-img":"post-bg-js-module.jpg","_content":"\n\n\n## Foreword\n\n> Here comes Module!\n\n随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。\n\n于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。\n\n\n---\n\n## Catalog\n\n\n1.  [CommonJS & Node](#commonjs--node)\n3.  [History](#history)\n4.  [RequireJS & AMD](#requirejs--amd)\n5.  [SeaJS & CMD](#seajs--cmd)\n6.  [AMD vs CMD](#amd-vs-cmd)\n7.  [WebPack](#webpack)\n\n\n\n```\nfunction autoDetect(){\n    console.log('ye, it is written in JavaScript!')\n}\n```\n\n## CommonJS & Node\n\n> Javascript: not just for browsers any more! —— CommonJS Slogen\n\n前端模块化的事实标准之一，2009 年 8 月，[CommonJS](http://wiki.commonjs.org/wiki/CommonJS) 诞生。\n\nCommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。\n\n\n让我们看看 Node 中的实现：\n{% codeblock lang:js %}\n// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper\n// \"as though the module was wrapped in a function\"\n\nvar a = require('./a')  // 加载模块（同步加载）\na.doSomething()         // 等上一句执行完才会执行\n\nexports.b = function(){ // 暴露 b 函数接口\n  // do something\n}\n{% endcodeblock %}\n\n\n`exports`是一个内置对象，就像`require`是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写`module.exports`就可以了。\n\nCommonJS 前身叫 ServerJS ，**后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS** 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。\n\n\n因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：\n\n* 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）\n* 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。\n* 都在向着 **COMMON** 的方向进化：**兼容不同风格，兼容浏览器和服务器两种环境**\n\n本文接下来要讨论的典例是：\n\n* RequireJS & AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）\n* SeaJS & CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）\n\n\n\n\n\n## History\n\n<!--<h2 id=\"history\"> History </h2>-->\n\n> 此段落参考自玉伯的 [前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588)\n\n09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 [Modules/1.0](http://wiki.commonjs.org/wiki/Modules) 规范，并且在 Node.js 等环境下取得了很不错的实践。\n\n09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：\n\n\n1. **Modules/1.x** 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 [Modules/Transport](http://wiki.commonjs.org/wiki/Modules/Transport) 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。\n2. **Modules/Async** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 [AMD](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 规范及其实现 [RequireJS](http://requirejs.org/)。这个稍后再细说。\n3. **Modules/2.0** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了\n\n\n补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 `add`和`use` 两个源自于 YUI Modules 的函数名替换了 `define` 和 `require` ，但其原理更接近 RequireJS ，与 YUI Modules 的 `Y` 沙箱 Attach 机制并不相同\n\n\n## RequireJS & AMD\n\n[AMD (Async Module Definition)](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\n> RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments\n\nRequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：\n\n{% gist 65481dbbf6d16e831a6cc89c3e37e6e5 display-emails-from-database.php %}\n\n\n> As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?\n\n所以我们需要 **Function Wrapping** 来获取依赖并且提前通过 script tag 提前加载进来\n\n\n{% jsfiddle shorttag [tabs] [skin] [width] [height] %}\n\n\n当依赖模块非常多时，这种**依赖前置**的写法会显得有点奇怪，所以 AMD 给了一个语法糖， **simplified CommonJS wrapping**，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：\n\n```js\ndefine(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\nThe AMD loader will parse out the `require('')` calls by using `Function.prototype.toString()`, then internally convert the above define call into this:\n\n```js\ndefine(['require', 'dependency1', 'dependency2'], function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\n\n出于`Function.prototype.toString()`兼容性和性能的考虑，最好的做法还是做一次 **optimized build**\n\n\n\nAMD 和 CommonJS 的核心争议如下：\n\n### 1. **执行时机**\n\nModules/1.0:\n\n```js\nvar a = require(\"./a\") // 执行到此时，a.js 才同步下载并执行\n```\n\nAMD: （使用 require 的语法糖时）\n\n```js\ndefine([\"require\"],function(require)){\n    // 在这里，a.js 已经下载并且执行好了\n    // 使用 require() 并不是 AMD 的推荐写法\n    var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n})\n```\n\nAMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）\n\n但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。\n\n### 2. **书写风格**\n\nAMD 推荐的风格并不使用`require`，而是通过参数传入，破坏了**依赖就近**：\n\n```js\ndefine([\"a\", \"b\", \"c\"],function(a, b, c){\n    // 提前申明了并初始化了所有模块\n\n    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。\n})\n```\n\n不过，在笔者看来，风格喜好因人而异，主要还是**预执行**和**懒执行**的差异。\n\n另外，require 2.0 也开始思考异步处理**软依赖**（区别于一定需要的**硬依赖**）的问题，提出了这样的方案：\n\n```js\n// 函数体内：\nif(status){\n    async(['a'],function(a){\n        a.doSomething()\n    })\n}\n```\n\n## SeaJS & CMD\n\nCMD (Common Module Definition) 是 [SeaJS](http://seajs.org/docs/) 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。\n\n不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。\n\n* CMD Specification\n    * [English (CMDJS-repo)](https://github.com/cmdjs/specification/blob/master/draft/module.md)\n    * [Chinese (SeaJS-repo)](https://github.com/seajs/seajs/issues/242)\n\n\nCMD 主要有 define, factory, require, export 这么几个东西\n\n * define `define(id?, deps?, factory)`\n * factory `factory(require, exports, module)`\n * require `require(id)`\n * exports `Object`\n\n\nCMD 推荐的 Code Style 是使用 CommonJS 风格的 `require`：\n\n* 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已\n\n```js\ndefine(function(require, exports) {\n\n    // 获取模块 a 的接口\n    var a = require('./a');\n    // 调用模块 a 的方法\n    a.doSomething();\n\n    // 对外提供 foo 属性\n    exports.foo = 'bar';\n    // 对外提供 doSomething 方法\n    exports.doSomething = function() {};\n\n});\n```\n\n但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n    // 模块代码...\n\n    // 直接通过 return 暴露接口\n    return {\n        foo: 'bar',\n        doSomething: function() {}\n    };\n\n});\n```\n\n\n\nSea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。\n\n\n\n## AMD vs CMD\n\n**虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：**\n\n1. 对于依赖的模块，AMD 是**提前执行**，CMD 是**懒执行**。（都是先加载）\n*  CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。\n\n看代码：\n\n```js\n// AMD 默认推荐\n\ndefine(['./a', './b'], function(a, b) {  // 依赖前置，提前执行\n\n    a.doSomething()\n    b.doSomething()\n\n})\n\n```\n\n```js\n// CMD\n\ndefine(function(require, exports, module) {\n\n    var a = require('./a')\n    a.doSomething()\n\n    var b = require('./b') // 依赖就近，延迟执行\n    b.doSomething()\n})\n```\n\n\n\n\n\n\n## WebPack\n\n> 后续文章,展开补充...\n\n","source":"_posts/javascript-module-loader.md","raw":"---\nlayout:     post\ntitle:      \"JS模块加载\"\nsubtitle:   \"CommonJS，RequireJS，SeaJS 归纳笔记\"\ndate:       2017-03-23 22:45:58\nauthor:     \"Damon\"\ncatalog:    true\nheader-img: \"post-bg-js-module.jpg\"\ntags:\n    - 前端开发\n    - JavaScript\n---\n\n\n\n## Foreword\n\n> Here comes Module!\n\n随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。\n\n于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。\n\n\n---\n\n## Catalog\n\n\n1.  [CommonJS & Node](#commonjs--node)\n3.  [History](#history)\n4.  [RequireJS & AMD](#requirejs--amd)\n5.  [SeaJS & CMD](#seajs--cmd)\n6.  [AMD vs CMD](#amd-vs-cmd)\n7.  [WebPack](#webpack)\n\n\n\n```\nfunction autoDetect(){\n    console.log('ye, it is written in JavaScript!')\n}\n```\n\n## CommonJS & Node\n\n> Javascript: not just for browsers any more! —— CommonJS Slogen\n\n前端模块化的事实标准之一，2009 年 8 月，[CommonJS](http://wiki.commonjs.org/wiki/CommonJS) 诞生。\n\nCommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。\n\n\n让我们看看 Node 中的实现：\n{% codeblock lang:js %}\n// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper\n// \"as though the module was wrapped in a function\"\n\nvar a = require('./a')  // 加载模块（同步加载）\na.doSomething()         // 等上一句执行完才会执行\n\nexports.b = function(){ // 暴露 b 函数接口\n  // do something\n}\n{% endcodeblock %}\n\n\n`exports`是一个内置对象，就像`require`是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写`module.exports`就可以了。\n\nCommonJS 前身叫 ServerJS ，**后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS** 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。\n\n\n因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：\n\n* 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）\n* 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。\n* 都在向着 **COMMON** 的方向进化：**兼容不同风格，兼容浏览器和服务器两种环境**\n\n本文接下来要讨论的典例是：\n\n* RequireJS & AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）\n* SeaJS & CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）\n\n\n\n\n\n## History\n\n<!--<h2 id=\"history\"> History </h2>-->\n\n> 此段落参考自玉伯的 [前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588)\n\n09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 [Modules/1.0](http://wiki.commonjs.org/wiki/Modules) 规范，并且在 Node.js 等环境下取得了很不错的实践。\n\n09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：\n\n\n1. **Modules/1.x** 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 [Modules/Transport](http://wiki.commonjs.org/wiki/Modules/Transport) 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。\n2. **Modules/Async** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 [AMD](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 规范及其实现 [RequireJS](http://requirejs.org/)。这个稍后再细说。\n3. **Modules/2.0** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了\n\n\n补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 `add`和`use` 两个源自于 YUI Modules 的函数名替换了 `define` 和 `require` ，但其原理更接近 RequireJS ，与 YUI Modules 的 `Y` 沙箱 Attach 机制并不相同\n\n\n## RequireJS & AMD\n\n[AMD (Async Module Definition)](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\n> RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments\n\nRequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：\n\n{% gist 65481dbbf6d16e831a6cc89c3e37e6e5 display-emails-from-database.php %}\n\n\n> As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?\n\n所以我们需要 **Function Wrapping** 来获取依赖并且提前通过 script tag 提前加载进来\n\n\n{% jsfiddle shorttag [tabs] [skin] [width] [height] %}\n\n\n当依赖模块非常多时，这种**依赖前置**的写法会显得有点奇怪，所以 AMD 给了一个语法糖， **simplified CommonJS wrapping**，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：\n\n```js\ndefine(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\nThe AMD loader will parse out the `require('')` calls by using `Function.prototype.toString()`, then internally convert the above define call into this:\n\n```js\ndefine(['require', 'dependency1', 'dependency2'], function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\n\n出于`Function.prototype.toString()`兼容性和性能的考虑，最好的做法还是做一次 **optimized build**\n\n\n\nAMD 和 CommonJS 的核心争议如下：\n\n### 1. **执行时机**\n\nModules/1.0:\n\n```js\nvar a = require(\"./a\") // 执行到此时，a.js 才同步下载并执行\n```\n\nAMD: （使用 require 的语法糖时）\n\n```js\ndefine([\"require\"],function(require)){\n    // 在这里，a.js 已经下载并且执行好了\n    // 使用 require() 并不是 AMD 的推荐写法\n    var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n})\n```\n\nAMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）\n\n但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。\n\n### 2. **书写风格**\n\nAMD 推荐的风格并不使用`require`，而是通过参数传入，破坏了**依赖就近**：\n\n```js\ndefine([\"a\", \"b\", \"c\"],function(a, b, c){\n    // 提前申明了并初始化了所有模块\n\n    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。\n})\n```\n\n不过，在笔者看来，风格喜好因人而异，主要还是**预执行**和**懒执行**的差异。\n\n另外，require 2.0 也开始思考异步处理**软依赖**（区别于一定需要的**硬依赖**）的问题，提出了这样的方案：\n\n```js\n// 函数体内：\nif(status){\n    async(['a'],function(a){\n        a.doSomething()\n    })\n}\n```\n\n## SeaJS & CMD\n\nCMD (Common Module Definition) 是 [SeaJS](http://seajs.org/docs/) 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。\n\n不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。\n\n* CMD Specification\n    * [English (CMDJS-repo)](https://github.com/cmdjs/specification/blob/master/draft/module.md)\n    * [Chinese (SeaJS-repo)](https://github.com/seajs/seajs/issues/242)\n\n\nCMD 主要有 define, factory, require, export 这么几个东西\n\n * define `define(id?, deps?, factory)`\n * factory `factory(require, exports, module)`\n * require `require(id)`\n * exports `Object`\n\n\nCMD 推荐的 Code Style 是使用 CommonJS 风格的 `require`：\n\n* 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已\n\n```js\ndefine(function(require, exports) {\n\n    // 获取模块 a 的接口\n    var a = require('./a');\n    // 调用模块 a 的方法\n    a.doSomething();\n\n    // 对外提供 foo 属性\n    exports.foo = 'bar';\n    // 对外提供 doSomething 方法\n    exports.doSomething = function() {};\n\n});\n```\n\n但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n    // 模块代码...\n\n    // 直接通过 return 暴露接口\n    return {\n        foo: 'bar',\n        doSomething: function() {}\n    };\n\n});\n```\n\n\n\nSea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。\n\n\n\n## AMD vs CMD\n\n**虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：**\n\n1. 对于依赖的模块，AMD 是**提前执行**，CMD 是**懒执行**。（都是先加载）\n*  CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。\n\n看代码：\n\n```js\n// AMD 默认推荐\n\ndefine(['./a', './b'], function(a, b) {  // 依赖前置，提前执行\n\n    a.doSomething()\n    b.doSomething()\n\n})\n\n```\n\n```js\n// CMD\n\ndefine(function(require, exports, module) {\n\n    var a = require('./a')\n    a.doSomething()\n\n    var b = require('./b') // 依赖就近，延迟执行\n    b.doSomething()\n})\n```\n\n\n\n\n\n\n## WebPack\n\n> 后续文章,展开补充...\n\n","slug":"javascript-module-loader","published":1,"updated":"2017-03-27T15:40:54.568Z","comments":1,"photos":[],"link":"","_id":"cj1kpzv460006k0e3gutov98e","content":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><blockquote>\n<p>Here comes Module!</p>\n</blockquote>\n<p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p>\n<p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p>\n<hr>\n<h2 id=\"Catalog\"><a href=\"#Catalog\" class=\"headerlink\" title=\"Catalog\"></a>Catalog</h2><ol>\n<li><a href=\"#commonjs--node\">CommonJS &amp; Node</a></li>\n<li><a href=\"#history\">History</a></li>\n<li><a href=\"#requirejs--amd\">RequireJS &amp; AMD</a></li>\n<li><a href=\"#seajs--cmd\">SeaJS &amp; CMD</a></li>\n<li><a href=\"#amd-vs-cmd\">AMD vs CMD</a></li>\n<li><a href=\"#webpack\">WebPack</a></li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">autoDetect</span>()&#123;</div><div class=\"line\">    console.log('ye, it <span class=\"keyword\">is</span> written <span class=\"keyword\">in</span> JavaScript!')</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"CommonJS-amp-Node\"><a href=\"#CommonJS-amp-Node\" class=\"headerlink\" title=\"CommonJS &amp; Node\"></a>CommonJS &amp; Node</h2><blockquote>\n<p>Javascript: not just for browsers any more! —— CommonJS Slogen</p>\n</blockquote>\n<p>前端模块化的事实标准之一，2009 年 8 月，<a href=\"http://wiki.commonjs.org/wiki/CommonJS\" target=\"_blank\" rel=\"external\">CommonJS</a> 诞生。</p>\n<p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p>\n<p>让我们看看 Node 中的实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></div><div class=\"line\"><span class=\"comment\">// \"as though the module was wrapped in a function\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)  <span class=\"comment\">// 加载模块（同步加载）</span></div><div class=\"line\">a.doSomething()         <span class=\"comment\">// 等上一句执行完才会执行</span></div><div class=\"line\"></div><div class=\"line\">exports.b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 暴露 b 函数接口</span></div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p>\n<p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>\n<p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p>\n<ul>\n<li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li>\n<li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li>\n<li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li>\n</ul>\n<p>本文接下来要讨论的典例是：</p>\n<ul>\n<li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li>\n<li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li>\n</ul>\n<h2 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h2><!--<h2 id=\"history\"> History </h2>-->\n<blockquote>\n<p>此段落参考自玉伯的 <a href=\"https://github.com/seajs/seajs/issues/588\" target=\"_blank\" rel=\"external\">前端模块化开发那点历史</a></p>\n</blockquote>\n<p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href=\"http://wiki.commonjs.org/wiki/Modules\" target=\"_blank\" rel=\"external\">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p>\n<p>09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>\n<ol>\n<li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\" target=\"_blank\" rel=\"external\">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li>\n<li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD</a> 规范及其实现 <a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"external\">RequireJS</a>。这个稍后再细说。</li>\n<li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li>\n</ol>\n<p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p>\n<h2 id=\"RequireJS-amp-AMD\"><a href=\"#RequireJS-amp-AMD\" class=\"headerlink\" title=\"RequireJS &amp; AMD\"></a>RequireJS &amp; AMD</h2><p><a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<blockquote>\n<p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p>\n</blockquote>\n<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p>\n<script src=\"//gist.github.com/65481dbbf6d16e831a6cc89c3e37e6e5.js?file=display-emails-from-database.php\"></script>\n<blockquote>\n<p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>\n</blockquote>\n<p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p>\n<iframe scrolling=\"no\" width=\"[width]\" height=\"[height]\" src=\"http://jsfiddle.net/shorttag/embedded/[tabs]/[skin]\" frameborder=\"0\" allowfullscreen></iframe>\n<p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>The AMD loader will parse out the <code>require(&#39;&#39;)</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">'require'</span>, <span class=\"string\">'dependency1'</span>, <span class=\"string\">'dependency2'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p>\n<p>AMD 和 CommonJS 的核心争议如下：</p>\n<h3 id=\"1-执行时机\"><a href=\"#1-执行时机\" class=\"headerlink\" title=\"1. 执行时机\"></a>1. <strong>执行时机</strong></h3><p>Modules/1.0:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 执行到此时，a.js 才同步下载并执行</span></div></pre></td></tr></table></figure>\n<p>AMD: （使用 require 的语法糖时）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"require\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>))</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在这里，a.js 已经下载并且执行好了</span></div><div class=\"line\">    <span class=\"comment\">// 使用 require() 并不是 AMD 的推荐写法</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 此处仅仅是取模块 a 的 exports</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>\n<p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>\n<h3 id=\"2-书写风格\"><a href=\"#2-书写风格\" class=\"headerlink\" title=\"2. 书写风格\"></a>2. <strong>书写风格</strong></h3><p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 提前申明了并初始化了所有模块</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"literal\">true</span> || b.foo(); <span class=\"comment\">//即便根本没用到模块 b，但 b 还是提前执行了。</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p>\n<p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数体内：</span></div><div class=\"line\"><span class=\"keyword\">if</span>(status)&#123;</div><div class=\"line\">    <span class=\"keyword\">async</span>([<span class=\"string\">'a'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">        a.doSomething()</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"SeaJS-amp-CMD\"><a href=\"#SeaJS-amp-CMD\" class=\"headerlink\" title=\"SeaJS &amp; CMD\"></a>SeaJS &amp; CMD</h2><p>CMD (Common Module Definition) 是 <a href=\"http://seajs.org/docs/\" target=\"_blank\" rel=\"external\">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>\n<p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p>\n<ul>\n<li>CMD Specification<ul>\n<li><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\" target=\"_blank\" rel=\"external\">English (CMDJS-repo)</a></li>\n<li><a href=\"https://github.com/seajs/seajs/issues/242\" target=\"_blank\" rel=\"external\">Chinese (SeaJS-repo)</a></li>\n</ul>\n</li>\n</ul>\n<p>CMD 主要有 define, factory, require, export 这么几个东西</p>\n<ul>\n<li>define <code>define(id?, deps?, factory)</code></li>\n<li>factory <code>factory(require, exports, module)</code></li>\n<li>require <code>require(id)</code></li>\n<li>exports <code>Object</code></li>\n</ul>\n<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p>\n<ul>\n<li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 获取模块 a 的接口</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</div><div class=\"line\">    <span class=\"comment\">// 调用模块 a 的方法</span></div><div class=\"line\">    a.doSomething();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 对外提供 foo 属性</span></div><div class=\"line\">    exports.foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">    <span class=\"comment\">// 对外提供 doSomething 方法</span></div><div class=\"line\">    exports.doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"string\">'hello'</span>, [<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 模块代码...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 直接通过 return 暴露接口</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>,</div><div class=\"line\">        <span class=\"attr\">doSomething</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>\n<h2 id=\"AMD-vs-CMD\"><a href=\"#AMD-vs-CMD\" class=\"headerlink\" title=\"AMD vs CMD\"></a>AMD vs CMD</h2><p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p>\n<ol>\n<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li>\n</ol>\n<ul>\n<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</li>\n</ul>\n<p>看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></div><div class=\"line\"></div><div class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖前置，提前执行</span></div><div class=\"line\"></div><div class=\"line\">    a.doSomething()</div><div class=\"line\">    b.doSomething()</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CMD</span></div><div class=\"line\"></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</div><div class=\"line\">    a.doSomething()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖就近，延迟执行</span></div><div class=\"line\">    b.doSomething()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"WebPack\"><a href=\"#WebPack\" class=\"headerlink\" title=\"WebPack\"></a>WebPack</h2><blockquote>\n<p>后续文章,展开补充…</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><blockquote>\n<p>Here comes Module!</p>\n</blockquote>\n<p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p>\n<p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p>\n<hr>\n<h2 id=\"Catalog\"><a href=\"#Catalog\" class=\"headerlink\" title=\"Catalog\"></a>Catalog</h2><ol>\n<li><a href=\"#commonjs--node\">CommonJS &amp; Node</a></li>\n<li><a href=\"#history\">History</a></li>\n<li><a href=\"#requirejs--amd\">RequireJS &amp; AMD</a></li>\n<li><a href=\"#seajs--cmd\">SeaJS &amp; CMD</a></li>\n<li><a href=\"#amd-vs-cmd\">AMD vs CMD</a></li>\n<li><a href=\"#webpack\">WebPack</a></li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">autoDetect</span>()&#123;</div><div class=\"line\">    console.log('ye, it <span class=\"keyword\">is</span> written <span class=\"keyword\">in</span> JavaScript!')</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"CommonJS-amp-Node\"><a href=\"#CommonJS-amp-Node\" class=\"headerlink\" title=\"CommonJS &amp; Node\"></a>CommonJS &amp; Node</h2><blockquote>\n<p>Javascript: not just for browsers any more! —— CommonJS Slogen</p>\n</blockquote>\n<p>前端模块化的事实标准之一，2009 年 8 月，<a href=\"http://wiki.commonjs.org/wiki/CommonJS\">CommonJS</a> 诞生。</p>\n<p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p>\n<p>让我们看看 Node 中的实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></div><div class=\"line\"><span class=\"comment\">// \"as though the module was wrapped in a function\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)  <span class=\"comment\">// 加载模块（同步加载）</span></div><div class=\"line\">a.doSomething()         <span class=\"comment\">// 等上一句执行完才会执行</span></div><div class=\"line\"></div><div class=\"line\">exports.b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 暴露 b 函数接口</span></div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p>\n<p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>\n<p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p>\n<ul>\n<li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li>\n<li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li>\n<li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li>\n</ul>\n<p>本文接下来要讨论的典例是：</p>\n<ul>\n<li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li>\n<li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li>\n</ul>\n<h2 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h2><!--<h2 id=\"history\"> History </h2>-->\n<blockquote>\n<p>此段落参考自玉伯的 <a href=\"https://github.com/seajs/seajs/issues/588\">前端模块化开发那点历史</a></p>\n</blockquote>\n<p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href=\"http://wiki.commonjs.org/wiki/Modules\">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p>\n<p>09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>\n<ol>\n<li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li>\n<li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\">AMD</a> 规范及其实现 <a href=\"http://requirejs.org/\">RequireJS</a>。这个稍后再细说。</li>\n<li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li>\n</ol>\n<p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p>\n<h2 id=\"RequireJS-amp-AMD\"><a href=\"#RequireJS-amp-AMD\" class=\"headerlink\" title=\"RequireJS &amp; AMD\"></a>RequireJS &amp; AMD</h2><p><a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<blockquote>\n<p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p>\n</blockquote>\n<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p>\n<script src=\"//gist.github.com/65481dbbf6d16e831a6cc89c3e37e6e5.js?file=display-emails-from-database.php\"></script>\n<blockquote>\n<p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>\n</blockquote>\n<p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p>\n<iframe scrolling=\"no\" width=\"[width]\" height=\"[height]\" src=\"http://jsfiddle.net/shorttag/embedded/[tabs]/[skin]\" frameborder=\"0\" allowfullscreen></iframe>\n<p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>The AMD loader will parse out the <code>require(&#39;&#39;)</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">'require'</span>, <span class=\"string\">'dependency1'</span>, <span class=\"string\">'dependency2'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p>\n<p>AMD 和 CommonJS 的核心争议如下：</p>\n<h3 id=\"1-执行时机\"><a href=\"#1-执行时机\" class=\"headerlink\" title=\"1. 执行时机\"></a>1. <strong>执行时机</strong></h3><p>Modules/1.0:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 执行到此时，a.js 才同步下载并执行</span></div></pre></td></tr></table></figure>\n<p>AMD: （使用 require 的语法糖时）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"require\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>))</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在这里，a.js 已经下载并且执行好了</span></div><div class=\"line\">    <span class=\"comment\">// 使用 require() 并不是 AMD 的推荐写法</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 此处仅仅是取模块 a 的 exports</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>\n<p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>\n<h3 id=\"2-书写风格\"><a href=\"#2-书写风格\" class=\"headerlink\" title=\"2. 书写风格\"></a>2. <strong>书写风格</strong></h3><p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 提前申明了并初始化了所有模块</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"literal\">true</span> || b.foo(); <span class=\"comment\">//即便根本没用到模块 b，但 b 还是提前执行了。</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p>\n<p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数体内：</span></div><div class=\"line\"><span class=\"keyword\">if</span>(status)&#123;</div><div class=\"line\">    <span class=\"keyword\">async</span>([<span class=\"string\">'a'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">        a.doSomething()</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"SeaJS-amp-CMD\"><a href=\"#SeaJS-amp-CMD\" class=\"headerlink\" title=\"SeaJS &amp; CMD\"></a>SeaJS &amp; CMD</h2><p>CMD (Common Module Definition) 是 <a href=\"http://seajs.org/docs/\">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>\n<p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p>\n<ul>\n<li>CMD Specification<ul>\n<li><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\">English (CMDJS-repo)</a></li>\n<li><a href=\"https://github.com/seajs/seajs/issues/242\">Chinese (SeaJS-repo)</a></li>\n</ul>\n</li>\n</ul>\n<p>CMD 主要有 define, factory, require, export 这么几个东西</p>\n<ul>\n<li>define <code>define(id?, deps?, factory)</code></li>\n<li>factory <code>factory(require, exports, module)</code></li>\n<li>require <code>require(id)</code></li>\n<li>exports <code>Object</code></li>\n</ul>\n<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p>\n<ul>\n<li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 获取模块 a 的接口</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</div><div class=\"line\">    <span class=\"comment\">// 调用模块 a 的方法</span></div><div class=\"line\">    a.doSomething();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 对外提供 foo 属性</span></div><div class=\"line\">    exports.foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">    <span class=\"comment\">// 对外提供 doSomething 方法</span></div><div class=\"line\">    exports.doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"string\">'hello'</span>, [<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 模块代码...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 直接通过 return 暴露接口</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>,</div><div class=\"line\">        <span class=\"attr\">doSomething</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>\n<h2 id=\"AMD-vs-CMD\"><a href=\"#AMD-vs-CMD\" class=\"headerlink\" title=\"AMD vs CMD\"></a>AMD vs CMD</h2><p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p>\n<ol>\n<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li>\n</ol>\n<ul>\n<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</li>\n</ul>\n<p>看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></div><div class=\"line\"></div><div class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖前置，提前执行</span></div><div class=\"line\"></div><div class=\"line\">    a.doSomething()</div><div class=\"line\">    b.doSomething()</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CMD</span></div><div class=\"line\"></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</div><div class=\"line\">    a.doSomething()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖就近，延迟执行</span></div><div class=\"line\">    b.doSomething()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"WebPack\"><a href=\"#WebPack\" class=\"headerlink\" title=\"WebPack\"></a>WebPack</h2><blockquote>\n<p>后续文章,展开补充…</p>\n</blockquote>\n"},{"title":"实现链式调用LazyMan","subtitle":"原型链 链式调用实现","author":"Damon","header-img":"post-bg-js-version.jpg","date":"2017-04-09T01:43:13.000Z","_content":"\n## 前言\n\n昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。\n\n---\n\n## 题目\n\n实现下面的函数:\n\n```\nLazyMan(“Hank”)\n//Hi! This is Hank!\n\nLazyMan(“Hank”).sleep(10).eat(“dinner”)\n// Hi! This is Hank!\n// 等待10秒..\n// Wake up after 10\n// Eat dinner~\n\nLazyMan(“Hank”).eat(“dinner”).eat(“supper”)\n// Hi This is Hank!\n// Eat dinner~\n// Eat supper~\n\nLazyMan(“Hank”).sleepFirst(5).eat(“supper”)\n// 等待5秒\n// Wake up after 5\n// Hi This is Hank!\n// Eat supper\n\n```\n\n这道题看起来很简单,不就是jquery经常使用的链式调用吗?\n但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.\n\n## 代码实现\n\n废话不多说直接上代码:\n\n```\nfunction _LazyMan(man) {\n    var self = this;\n    // 任务队列\n    self.task = [];\n    var fn = function () {\n        console.log('I am ' + man);\n        self.next();\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n\n    // 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务\n    setTimeout(function () {\n        self.next();\n    }, 0)\n\n    return self;\n}\n\n_LazyMan.prototype.firstSleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾开头加入一个任务\n    self.task.unshift(fn);\n\n    return self;\n}\n\n_LazyMan.prototype.sleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n_LazyMan.prototype.eat = function (food) {\n    var self = this;\n\n    var fn = function () {\n        console.log('eat ' + food);\n\n        self.next();\n    }\n\n    // 向队列尾加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n// next实现\n_LazyMan.prototype.next = function () {\n    // 删除队列的第一位元素\n    var runFunc = this.task.shift();\n\n    // 如果renFunc 不是undefined,那么执行runFunc\n    runFunc && runFunc();\n\n}\n\nfunction LazyMan(man) {\n    return new _LazyMan(man);\n}\n\nLazyMan('Hank').firstSleep(1).sleep(2).eat('egg');\n\n/* 运行结果 */\n// Wake up after 1 s!\n//     I am Hank\n// Wake up after 2 s!\n//     eat egg\n\n```\n## 总结\n\n实现要点:\n1. 在实例上创建一个任务队列数组(先进先出).\n2. 实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.\n3. 在实例化LazyMan的时候,使用setTimeout执行第一次next方法.\n\n* 注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，\nsetTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/实现链式LazyMan.md","raw":"---\ntitle: 实现链式调用LazyMan\nsubtitle: \"原型链 链式调用实现\"\nauthor: \"Damon\"\nheader-img: \"post-bg-js-version.jpg\"\ndate: 2017-04-09 09:43:13\ntags:\n    - JS\n    - 前端面试\n---\n\n## 前言\n\n昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。\n\n---\n\n## 题目\n\n实现下面的函数:\n\n```\nLazyMan(“Hank”)\n//Hi! This is Hank!\n\nLazyMan(“Hank”).sleep(10).eat(“dinner”)\n// Hi! This is Hank!\n// 等待10秒..\n// Wake up after 10\n// Eat dinner~\n\nLazyMan(“Hank”).eat(“dinner”).eat(“supper”)\n// Hi This is Hank!\n// Eat dinner~\n// Eat supper~\n\nLazyMan(“Hank”).sleepFirst(5).eat(“supper”)\n// 等待5秒\n// Wake up after 5\n// Hi This is Hank!\n// Eat supper\n\n```\n\n这道题看起来很简单,不就是jquery经常使用的链式调用吗?\n但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.\n\n## 代码实现\n\n废话不多说直接上代码:\n\n```\nfunction _LazyMan(man) {\n    var self = this;\n    // 任务队列\n    self.task = [];\n    var fn = function () {\n        console.log('I am ' + man);\n        self.next();\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n\n    // 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务\n    setTimeout(function () {\n        self.next();\n    }, 0)\n\n    return self;\n}\n\n_LazyMan.prototype.firstSleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾开头加入一个任务\n    self.task.unshift(fn);\n\n    return self;\n}\n\n_LazyMan.prototype.sleep = function (second) {\n    var self = this;\n\n    var fn = function () {\n        setTimeout(function () {\n            console.log('Wake up after ' + second + ' s!');\n            self.next();\n        }, second * 1000)\n    }\n\n    // 向队列尾中加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n_LazyMan.prototype.eat = function (food) {\n    var self = this;\n\n    var fn = function () {\n        console.log('eat ' + food);\n\n        self.next();\n    }\n\n    // 向队列尾加入一个任务\n    self.task.push(fn);\n    return self;\n}\n\n// next实现\n_LazyMan.prototype.next = function () {\n    // 删除队列的第一位元素\n    var runFunc = this.task.shift();\n\n    // 如果renFunc 不是undefined,那么执行runFunc\n    runFunc && runFunc();\n\n}\n\nfunction LazyMan(man) {\n    return new _LazyMan(man);\n}\n\nLazyMan('Hank').firstSleep(1).sleep(2).eat('egg');\n\n/* 运行结果 */\n// Wake up after 1 s!\n//     I am Hank\n// Wake up after 2 s!\n//     eat egg\n\n```\n## 总结\n\n实现要点:\n1. 在实例上创建一个任务队列数组(先进先出).\n2. 实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.\n3. 在实例化LazyMan的时候,使用setTimeout执行第一次next方法.\n\n* 注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，\nsetTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"实现链式LazyMan","published":1,"updated":"2017-04-16T13:20:29.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1kpzv4d0008k0e35grl4vbi","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。</p>\n<hr>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>实现下面的函数:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span></div><div class=\"line\"><span class=\"comment\">//Hi! This is Hank!</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleep(<span class=\"number\">10</span>).eat(“dinner”)</div><div class=\"line\"><span class=\"comment\">// Hi! This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// 等待10秒..</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 10</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.eat(“dinner”).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"><span class=\"comment\">// Eat supper~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleepFirst(<span class=\"number\">5</span>).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// 等待5秒</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 5</span></div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat supper</span></div></pre></td></tr></table></figure>\n<p>这道题看起来很简单,不就是jquery经常使用的链式调用吗?<br>但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>废话不多说直接上代码:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\">    <span class=\"comment\">// 任务队列</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task = [];</div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'I am '</span> + man);</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务</span></div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;, <span class=\"number\">0</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.firstSleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾开头加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.unshift(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.sleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(food)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'eat '</span> + food);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// next实现</span></div><div class=\"line\">_LazyMan.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 删除队列的第一位元素</span></div><div class=\"line\">    <span class=\"keyword\">var</span> runFunc = this.task.shift();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果renFunc 不是undefined,那么执行runFunc</span></div><div class=\"line\">    runFunc &amp;&amp; runFunc();</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(man);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">LazyMan(<span class=\"string\">'Hank'</span>).firstSleep(<span class=\"number\">1</span>).sleep(<span class=\"number\">2</span>).eat(<span class=\"string\">'egg'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 运行结果 */</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 1 s!</span></div><div class=\"line\"><span class=\"comment\">//     I am Hank</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 2 s!</span></div><div class=\"line\"><span class=\"comment\">//     eat egg</span></div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实现要点:</p>\n<ol>\n<li>在实例上创建一个任务队列数组(先进先出).</li>\n<li>实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.</li>\n<li>在实例化LazyMan的时候,使用setTimeout执行第一次next方法.</li>\n</ol>\n<ul>\n<li>注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，<br>setTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>昨天面试碰到一条非常有意思的面试题，关于链式调用和流程控制的写法，下面把我自己的实现分享一下。</p>\n<hr>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>实现下面的函数:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span></div><div class=\"line\"><span class=\"comment\">//Hi! This is Hank!</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleep(<span class=\"number\">10</span>).eat(“dinner”)</div><div class=\"line\"><span class=\"comment\">// Hi! This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// 等待10秒..</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 10</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.eat(“dinner”).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat dinner~</span></div><div class=\"line\"><span class=\"comment\">// Eat supper~</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">LazyMan</span><span class=\"params\">(“Hank”)</span></span>.sleepFirst(<span class=\"number\">5</span>).eat(“supper”)</div><div class=\"line\"><span class=\"comment\">// 等待5秒</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 5</span></div><div class=\"line\"><span class=\"comment\">// Hi This is Hank!</span></div><div class=\"line\"><span class=\"comment\">// Eat supper</span></div></pre></td></tr></table></figure>\n<p>这道题看起来很简单,不就是jquery经常使用的链式调用吗?<br>但是看到最后一步sleepfirst,就发现实现没有想象中那么简单.</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>废话不多说直接上代码:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\">    <span class=\"comment\">// 任务队列</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task = [];</div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'I am '</span> + man);</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 这里使用setTimeout,是确保链式调用上所有任务都加入队列后,在JS下一个事件循环,开始第一个任务</span></div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;, <span class=\"number\">0</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.firstSleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾开头加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.unshift(fn);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.sleep = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(second)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            console.log(<span class=\"string\">'Wake up after '</span> + second + <span class=\"string\">' s!'</span>);</div><div class=\"line\">            <span class=\"keyword\">self</span>.next();</div><div class=\"line\">        &#125;, second * <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾中加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(food)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">self</span> = this;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        console.log(<span class=\"string\">'eat '</span> + food);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">self</span>.next();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 向队列尾加入一个任务</span></div><div class=\"line\">    <span class=\"keyword\">self</span>.task.push(fn);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// next实现</span></div><div class=\"line\">_LazyMan.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 删除队列的第一位元素</span></div><div class=\"line\">    <span class=\"keyword\">var</span> runFunc = this.task.shift();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果renFunc 不是undefined,那么执行runFunc</span></div><div class=\"line\">    runFunc &amp;&amp; runFunc();</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span><span class=\"params\">(man)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(man);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">LazyMan(<span class=\"string\">'Hank'</span>).firstSleep(<span class=\"number\">1</span>).sleep(<span class=\"number\">2</span>).eat(<span class=\"string\">'egg'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 运行结果 */</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 1 s!</span></div><div class=\"line\"><span class=\"comment\">//     I am Hank</span></div><div class=\"line\"><span class=\"comment\">// Wake up after 2 s!</span></div><div class=\"line\"><span class=\"comment\">//     eat egg</span></div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实现要点:</p>\n<ol>\n<li>在实例上创建一个任务队列数组(先进先出).</li>\n<li>实现一个next方法,按照先进先执行的规则,依次执行并删除队列中的函数.</li>\n<li>在实例化LazyMan的时候,使用setTimeout执行第一次next方法.</li>\n</ol>\n<ul>\n<li>注:setTimeout的延时为0时并不会立即触发，一个是浏览器自身就有一个几毫秒更新频率，另一个就是异步队列的问题，<br>setTimeout中的回调函数会加入等待队列，在等待延迟触发的过程中，有新的同步脚本需要执行的话，新的同步脚本不会排在setTimeout的回调函数之后，而是立即执行。</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/hello-blog/post-bg-unix-linux.jpg","post":"cj1kpzv3u0003k0e34sll07ys","slug":"post-bg-unix-linux.jpg","modified":1,"renderable":1},{"_id":"source/_posts/javascript-module-loader/post-bg-js-module.jpg","post":"cj1kpzv460006k0e3gutov98e","slug":"post-bg-js-module.jpg","modified":1,"renderable":1},{"_id":"source/_posts/实现链式LazyMan/post-bg-js-version.jpg","post":"cj1kpzv4d0008k0e35grl4vbi","slug":"post-bg-js-version.jpg","modified":1,"renderable":1},{"_id":"source/_posts/about-javascript/javascript-java.jpg","post":"cj1kpzv3m0001k0e3nt0krp96","slug":"javascript-java.jpg","modified":1,"renderable":1},{"_id":"source/_posts/about-javascript/keep-calm-and-learn-javascript.png","post":"cj1kpzv3m0001k0e3nt0krp96","slug":"keep-calm-and-learn-javascript.png","modified":1,"renderable":1},{"_id":"source/_posts/about-javascript/post-bg-js-version.jpg","post":"cj1kpzv3m0001k0e3nt0krp96","slug":"post-bg-js-version.jpg","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cj1kpzv3m0001k0e3nt0krp96","tag_id":"cj1kpzv420005k0e36fn5zv0n","_id":"cj1kpzv4k000bk0e3yemn5xdh"},{"post_id":"cj1kpzv3m0001k0e3nt0krp96","tag_id":"cj1kpzv4g0009k0e3xk3zn8d8","_id":"cj1kpzv4l000ck0e37ual2ua4"},{"post_id":"cj1kpzv3u0003k0e34sll07ys","tag_id":"cj1kpzv4j000ak0e3bwputvhu","_id":"cj1kpzv4n000ek0e3wlbp7aqs"},{"post_id":"cj1kpzv460006k0e3gutov98e","tag_id":"cj1kpzv4l000dk0e3o50ubfra","_id":"cj1kpzv4q000hk0e3z1a2vgsl"},{"post_id":"cj1kpzv460006k0e3gutov98e","tag_id":"cj1kpzv420005k0e36fn5zv0n","_id":"cj1kpzv4q000ik0e3e9c18q1w"},{"post_id":"cj1kpzv4d0008k0e35grl4vbi","tag_id":"cj1kpzv4p000gk0e38cck6wac","_id":"cj1kpzv4q000kk0e3udqy89lo"},{"post_id":"cj1kpzv4d0008k0e35grl4vbi","tag_id":"cj1kpzv4q000jk0e3kgtwf8sk","_id":"cj1kpzv4r000lk0e3doqfhzms"}],"Tag":[{"name":"JavaScript","_id":"cj1kpzv420005k0e36fn5zv0n"},{"name":"翻译","_id":"cj1kpzv4g0009k0e3xk3zn8d8"},{"name":"生活","_id":"cj1kpzv4j000ak0e3bwputvhu"},{"name":"前端开发","_id":"cj1kpzv4l000dk0e3o50ubfra"},{"name":"JS","_id":"cj1kpzv4p000gk0e38cck6wac"},{"name":"前端面试","_id":"cj1kpzv4q000jk0e3kgtwf8sk"}]}}